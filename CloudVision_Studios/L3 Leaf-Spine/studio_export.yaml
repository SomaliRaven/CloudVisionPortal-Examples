# This is the L3 Leaf Spine Studio
#
-   service: arista.studio.v1.StudioConfigService
    method: Set
    body:
        value:
            key:
                studio_id: studio-l3ls
                workspace_id: &workspace_id ws-l3ls
            display_name: 'L3 Leaf-Spine Fabric'
            description: 'Deploy and manage an Arista validated L3 leaf-spine fabric, including support for a multi-tenant BGP EVPN overlay.'

-   service: arista.studio.v1.StudioConfigService
    method: Set
    body:
        value:
            key:
                studio_id: studio-l3ls
                workspace_id: *workspace_id
            input_schema:
                fields:
                    values:
                        mlagLinkSubnet:
                            id: mlagLinkSubnet
                            name: mlagPeerLinkSubnet
                            label: 'MLAG Peer Link Subnet'
                            description: 'Define the subnet from which to allocate IP addresses for the MLAG source interfaces.  By setting a subnet with a subnet mask of 30 or 31, you will re-use the same IP addresses for MLAG source interfaces across all leaf MLAG pairs in your network. To use unique IP addresses for every MLAG source interface, enter a subnet with a subnet mask less than 30'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 192.168.255.254/31
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        internalVlan:
                            id: internalVlan
                            name: mlagVlan
                            label: 'MLAG Peer Link VLAN'
                            description: 'Define the VLAN ID to use for MLAG peer communication'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '4094'
                                range: null
                                static_options: null
                                dynamic_options: null
                        mlagPortChannelId:
                            id: mlagPortChannelId
                            name: mlagPortChannelId
                            label: 'MLAG Port Channel ID'
                            description: 'Define the VLAN ID to use for MLAG peer communication'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '2000'
                                range: null
                                static_options: null
                                dynamic_options: null
                        virtualRouterMac:
                            id: virtualRouterMac
                            name: virtualRouterMacAddress
                            label: 'Virtual Router MAC Address'
                            description: 'Assign a virtual MAC address for redundant host and switch connections'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '00:1c:73:00:00:99'
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        mlagSubnetMask:
                            id: mlagSubnetMask
                            name: mlagSubnetMask
                            label: 'MLAG Subnet Mask'
                            description: 'Set the subnet mask for the MLAG interface connections in the fabric'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '31'
                                range: null
                                static_options:
                                    values:
                                        - '31'
                                        - '30'
                                dynamic_options: null
                        lacpMode:
                            id: lacpMode
                            name: lacpMode
                            label: 'LACP Mode'
                            description: 'Define the LACP mode used for member interfaces of the MLAG peer link port channel'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: active
                                static_options:
                                    values:
                                        - active
                                        - passive
                                        - 'on (static)'
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        commonMlagConfig:
                            id: commonMlagConfig
                            name: commonMlagConfig
                            label: 'MLAG Configuration'
                            description: 'Configure the parameters for the MLAG pairs in this Pod.'
                            required: true
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - mlagLinkSubnet
                                        - internalVlan
                                        - mlagPortChannelId
                                        - virtualRouterMac
                                        - mlagSubnetMask
                                        - lacpMode
                        spineAS:
                            id: spineAS
                            name: spineAsn
                            label: 'Spine ASN'
                            description: 'Define the BGP ASN assigned to spine switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '65000'
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafASbase:
                            id: leafASbase
                            name: leafAsnRange
                            label: 'Leaf ASN Range'
                            description: 'Define the BGP ASN range used to assign ASNs to leaf switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 65001-65535
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        spineLoopback0Subnet:
                            id: spineLoopback0Subnet
                            name: spineLoopback0Subnet
                            label: 'Spine Router ID Subnet'
                            description: 'Define the subnet from which IP addresses are allocated to each spine''s Loopback0 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.0.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafLoopback0Subnet:
                            id: leafLoopback0Subnet
                            name: leafLoopback0Subnet
                            label: 'Leaf Router ID Subnet'
                            description: 'Define the subnet from which IP addresses are allocated to each leaf''s Loopback0 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.0.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        spineBGPDynamicNeighbors:
                            id: spineBGPDynamicNeighbors
                            name: spineBGPDynamicNeighbors
                            label: 'Spine BGP Dynamic Neighbors'
                            description: 'Enable to set up dynamic BGP peering on the spine switches'
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        evpnEnabled:
                            id: evpnEnabled
                            name: evpnEnabled
                            label: 'BGP EVPN Enabled'
                            description: 'Enable to form EVPN adjacencies for the control plane of a VXLAN overlay'
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        commonBGPConfig:
                            id: commonBGPConfig
                            name: commonBGPConfig
                            label: 'BGP Configuration'
                            description: 'Configure the BGP settings for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - spineAS
                                        - leafASbase
                                        - spineLoopback0Subnet
                                        - leafLoopback0Subnet
                                        - spineBGPDynamicNeighbors
                                        - evpnEnabled
                        spineNotes:
                            id: spineNotes
                            name: spineNotes
                            label: Notes
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        spines:
                            id: spines
                            name: spines
                            label: Spines
                            description: 'Specify the spine switches in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: spineNotes
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: device
                                tag_filter_query: 'Role:Spine '
                        asNumber:
                            id: asNumber
                            name: asn
                            label: ASN
                            description: 'Override the automatic ASN allocation for this leaf domain by entering a value.'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: null
                                range: null
                                static_options: null
                                dynamic_options: null
                        leafNotes:
                            id: leafNotes
                            name: leafNotes
                            label: Notes
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafDetails:
                            id: leafDetails
                            name: l3LeafDetails
                            label: 'L3 Leaf Details'
                            description: 'Summary of leaf devices in this leaf domain.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: leafNotes
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: device
                                tag_filter_query: null
                        leafDomain:
                            id: leafDomain
                            name: l3LeafDomain
                            label: 'Leaf Domain'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - asNumber
                                        - leafDetails
                        leafDomains:
                            id: leafDomains
                            name: LeafDomains
                            label: 'Leaf Domains'
                            description: 'Specify the MLAG pairs or standalone leaf switches in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: leafDomain
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: Leaf-Domain
                                tag_filter_query: null
                        spanningTreeMode:
                            id: spanningTreeMode
                            name: spanningTreeMode
                            label: 'Spanning Tree Mode'
                            description: 'Select the spanning tree mode for devices in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options:
                                    values:
                                        - MSTP
                                        - Rapid-PVST
                                        - RSTP
                                        - None
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        fabricSubnetMask:
                            id: fabricSubnetMask
                            name: underlayFabricSubnetMask
                            label: 'Fabric Subnet Mask'
                            description: 'Set the subnet mask for the transit connections in the fabric'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '31'
                                static_options:
                                    values:
                                        - '30'
                                        - '31'
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        underlayRoutingProtocol:
                            id: underlayRoutingProtocol
                            name: underlayRoutingProtocol
                            label: 'Routing Protocol'
                            description: 'Set the routing protocol used for underlay connectivity'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options:
                                    values:
                                        - BGP
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        fabricLinksSubnet:
                            id: fabricLinksSubnet
                            name: underlayFabricSubnet
                            label: 'Fabric Subnet'
                            description: 'Define a subnet in CIDR notation for the IP transit links for use by all spines or create a list of subnets so that each spine uses one subnet for IP allocation. If creating a list, separate each subnet with a comma'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.200.0/24
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        underlayRouting:
                            id: underlayRouting
                            name: underlayRouting
                            label: 'Underlay Routing'
                            description: 'Specify the underlay routing details for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - fabricSubnetMask
                                        - underlayRoutingProtocol
                                        - fabricLinksSubnet
                        vxlanOverlay:
                            id: vxlanOverlay
                            name: vxlanOverlay
                            label: 'VXLAN Overlay'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        leafLoopback1Subnet:
                            id: leafLoopback1Subnet
                            name: leafLoopback1Subnet
                            label: 'VTEP Address Range'
                            description: 'Define a subnet in CIDR notation from which to allocate VXLAN tunnel source IP addresses. These IP addresses will be assigned to the leaf switch''s Loopback1 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.1.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        vVtepAddress:
                            id: vVtepAddress
                            name: vVtepAddress
                            label: 'vVTEP Address'
                            description: 'If you are not using an integrated routing and bridging model, enter an IP address in CIDR notation. This addess will be a secondary IP address on the Loopback1 interface of all leaf switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        overlayDetails:
                            id: overlayDetails
                            name: overlayDetails
                            label: 'Overlay Details'
                            description: 'Configure the VXLAN overlay settings for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - vxlanOverlay
                                        - leafLoopback1Subnet
                                        - vVtepAddress
                        maxSpines:
                            id: maxSpines
                            name: maxSpines
                            label: 'Maximum Number of Spines'
                            description: 'If no number is entered, the spine limit will be set to the greatest ''Spine-Number'' tag value in this Pod'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: null
                                range: null
                                static_options: null
                                dynamic_options: null
                        maximums:
                            id: maximums
                            name: maximums
                            label: 'Spine Limit'
                            description: 'Limit the potential growth of spine nodes to a maximum number. This prevents the fabric''s IP addresses from being recalculated when additional spines are added in the future.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - maxSpines
                        pod:
                            id: pod
                            name: pod
                            label: Pod
                            description: "Configure a leaf-spine module for your fabric."
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - commonMlagConfig
                                        - commonBGPConfig
                                        - spines
                                        - leafDomains
                                        - spanningTreeMode
                                        - underlayRouting
                                        - overlayDetails
                                        - maximums
                        pods:
                            id: pods
                            name: pods
                            label: Pods
                            description: 'Configure a leaf-spine module for your fabric.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: pod
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: DC-Pod
                                tag_filter_query: null
                        dataCenter:
                            id: dataCenter
                            name: dataCenter
                            label: 'Data Center'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - pods
                        dataCenters:
                            id: dataCenters
                            name: dataCenters
                            label: 'Data Centers'
                            description: "Select a data center using the tag label DC."
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: dataCenter
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: DC
                                tag_filter_query: null
                        root:
                            id: root
                            name: ""
                            label: ""
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - dataCenters
                layout:
                    value: |
                        {
                            "pod":{
                                "key":"pod",
                                "type":"INPUT",
                                "order":[
                                    "spines",
                                    "leafDomains",
                                    "commonMlagConfig",
                                    "underlayRouting",
                                    "commonBGPConfig",
                                    "overlayDetails",
                                    "spanningTreeMode",
                                    "maximums"
                                ]
                            },
                            "commonMlagConfig":{
                                "key":"commonMlagConfig",
                                "type":"INPUT",
                                "order":[
                                    "mlagLinkSubnet",
                                    "mlagSubnetMask",
                                    "internalVlan",
                                    "mlagPortChannelId",
                                    "virtualRouterMac",
                                    "lacpMode"
                                ]
                            },
                            "underlayRouting":{
                                "key":"underlayRouting",
                                "type":"INPUT",
                                "order":[
                                    "underlayRoutingProtocol",
                                    "fabricLinksSubnet",
                                    "fabricSubnetMask"
                                ]
                            },
                            "leafLoopback1Subnet":{
                                "key":"leafLoopback1Subnet",
                                "type":"INPUT",
                                "dependency":{
                                    "vxlanOverlay":{
                                        "value":[
                                        false
                                        ],
                                        "mode":"HIDE"
                                    }
                                }
                            },
                            "vVtepAddress":{
                                "key":"vVtepAddress",
                                "type":"INPUT",
                                "dependency":{
                                    "vxlanOverlay":{
                                        "value":[
                                        false
                                        ],
                                        "mode":"HIDE"
                                    }
                                }
                            }
                        }


-   service: arista.studio.v1.StudioConfigService
    method: Set
    body:
        value:
            key:
                studio_id: studio-l3ls
                workspace_id: *workspace_id
            template:
                type: TEMPLATE_TYPE_MAKO
                body: |
                    <%
                    import sys, os, json, ipaddress, re
                    from collections import OrderedDict
                    import tagsearch_python.tagsearch_pb2_grpc as tsgr
                    import tagsearch_python.tagsearch_pb2 as tspb
                    from arista.tag.v2.services import TagServiceStub, TagAssignmentServiceStub, TagConfigServiceStub, TagAssignmentConfigServiceStub
                    from arista.tag.v2.services.gen_pb2 import TagRequest, TagConfigSetRequest, TagStreamRequest, TagConfigStreamRequest, TagAssignmentStreamRequest, TagAssignmentConfigSetRequest, TagAssignmentConfigStreamRequest
                    from arista.tag.v2.tag_pb2 import Tag, TagKey, TagAssignment, TagAssignmentKey, TagAssignmentConfig

                    studio_input_data = dataCenters.resolve()
                    workspace_id = ctx.studio.workspaceId
                    my_device = ctx.getDevice()
                    my_device_id = my_device.id

                    jericho_platform_regexes = [
                        r'7048T',
                        r'7280',
                        r'75\d\d',
                        r'780\d'
                    ]

                    def convert(text):
                        return int(text) if text.isdigit() else text.lower()

                    def alphanum_key(key):
                        return [convert(c) for c in re.split('([0-9]+)', str(key))]

                    def natural_sort(iterable):
                        if iterable is None:
                            return list()
                        return sorted(iterable, key=alphanum_key)

                    def string_to_list(string_to_convert):
                        numbers = []
                        segments = [ segment.strip() for segment in string_to_convert.split(",") ]
                        for segment in segments:
                            if "-" in segment:
                                for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                                    if i not in numbers:
                                        numbers.append(i)
                            else:
                                if i not in numbers:
                                    numbers.append(int(segment))    
                        return numbers

                    def get_tag_values_applied_to_device(tag_assignment_key):
                        label = tag_assignment_key.label.value
                        value = tag_assignment_key.value.value
                        device_id = tag_assignment_key.device_id.value
                        workspace_id = tag_assignment_key.workspace_id.value
                        #Create tagstub
                        tsclient = ctx.getApiClient(tsgr.TagSearchStub)

                        matching_tags = []

                        #Create TagValueSearchRequest
                        tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                        for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                            query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                            tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                            tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                            for match in tagmresp.matches:
                                if match.device.device_id == device_id:
                                    matching_tags.append(tag)

                        return matching_tags

                    def create_tag(tag_key):
                        '''
                        tag_key is a TagKey
                        '''
                        tcsr = TagConfigSetRequest()
                        tcsr.value.key.workspace_id.value = tag_key.workspace_id.value
                        tcsr.value.key.element_type = tag_key.element_type
                        tcsr.value.key.label.value = tag_key.label.value
                        tcsr.value.key.value.value = tag_key.value.value
                        client = ctx.getApiClient(TagConfigServiceStub)
                        client.Set(tcsr)

                    def apply_tag(tag_assignment_key):
                        '''
                        tag_assignment_key is a TagAssignmentKey
                        '''
                        tacsr = TagAssignmentConfigSetRequest()
                        tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
                        tacsr.value.key.element_type = tag_assignment_key.element_type
                        tacsr.value.key.label.value = tag_assignment_key.label.value
                        tacsr.value.key.value.value = tag_assignment_key.value.value
                        tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
                        tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
                        tacsr.value.remove.value = False
                        client = ctx.getApiClient(TagAssignmentConfigServiceStub)
                        client.Set(tacsr)

                    def remove_tag(tag_assignment_key):
                        '''
                        tag_assignment_key is a TagAssignmentKey
                        '''
                        tacsr = TagAssignmentConfigSetRequest()
                        tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
                        tacsr.value.key.element_type = tag_assignment_key.element_type
                        tacsr.value.key.label.value = tag_assignment_key.label.value
                        tacsr.value.key.value.value = tag_assignment_key.value.value
                        tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
                        tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
                        tacsr.value.remove.value = True
                        client = ctx.getApiClient(TagAssignmentConfigServiceStub)
                        client.Set(tacsr)

                    class Pod:
                        def __init__(self):
                            self.id = None
                            self.dc = None
                            self.underlay_routing_protocol = "bgp" #< BGP or OSPF* or ISIS* | Default -> BGP >
                            self.overlay_routing_protocol = "bgp" #<EBGP or IBGP | default -> EBGP >
                            self.p2p_uplinks_mtu = 9214 #< 0-9214 | default -> 9214 >
                            self.underlay_p2p_network_summaries = [] # IP Summary subnets for Point to Point interfaces between L3 leafs and spines/superspines used for underlay peering | Required
                            self.underlay_p2p_subnet_mask = 31  # 30 or 31 | Default -> 31
                            self.max_spines = None
                            self.overlay_loopback_network_summary_super_spines = None # IP address summary for BGP evpn overlay peering loopback for supeer spines
                            self.overlay_loopback_network_summary_spines = None # IP address summary for BGP evpn overlay peering loopback for spines
                            self.overlay_loopback_network_summary_leafs = None # IP address summary for BGP evpn overlay peering loopback for L3 leafs  
                            self.vxlan_overlay = False
                            self.vtep_loopback_network_summary = None # IP address summary VTEP VXLAN Tunnel source loopback1 IP for L3 leafs | Required
                            self.vtep_vvtep_ip = None # IP Address used as Virtual VTEP. Will be configured as secondary IP on loopback1 | Optional
                            self.manually_allocated_leaf_asns = {}
                            self.mlag = {
                                "mlag_ip_subnet": None, # Subnet to pull mlag svi addresses from
                                "mlag_subnet_mask": 31, # 30 or 31 | Default -> 31
                                "mlag_peer_link_id": None, # port-channel interface used for MLAG peer link | Default -> "Port-Channel2000"
                                "mlag_peer_vlan": 4094, # VLAN used for MLAG control plane traffic | Default -> 4094
                                "ip_virtual_router_mac_address": "00:1c:73:00:00:99", # virtual router mac address | Default -> "00:1c:73:00:00:99"
                                "mlag_vlan_name": "MLAG-PEER-VLAN",
                                "mlag_vlan_trunk_group_name": "MLAG-PEER",
                                "mlag_peer_link_description": "MLAG Peer Link",
                                "mlag_peer_link_member_iface_description": "MLAG peer link to {}:{}",
                                "mlag_domain_id": "MLAG",
                                "lacp_mode": "active",
                                "reload_delay_mlag": 300,
                                "reload_delay_non_mlag": 330
                            }
                            self.bgp = {
                                "super_spines_asn": None,
                                "spines_asn": None,
                                "leafs_asn_range": None,
                                "ecmp": 4,  #< number_of_ecmp_paths | default -> 4 >
                                "maximum_paths": 4,  #< number_of_max_paths | default -> 4 >
                                "peer_groups": {
                                    "leaf": {
                                        "IPv4_UNDERLAY_PEERS": {
                                            "name": "IPv4_UNDERLAY_PEERS",
                                            "description": "ipv4 peering",
                                            "send_community": "all",
                                            "password": None,
                                            ## "bfd": True,
                                            "maximum_routes": 12000
                                        },
                                        "MLAG_IPv4_UNDERLAY_PEER":{
                                            "name": "MLAG_IPv4_UNDERLAY_PEER",
                                            "description": "ipv4 with mlag neighbor",
                                            "send_community": "all",
                                            "password": None,
                                            "next_hop_self": True,
                                            ## "bfd": True,
                                            "maximum_routes": 12000
                                        },
                                        "EVPN_OVERLAY_PEERS": {
                                            "name": "EVPN_OVERLAY_PEERS",
                                            "description": "evpn overlay peering",
                                            "update_source": "Loopback0",
                                            "send_community": "all",
                                            "bfd": True,
                                            "password": None,
                                            "ebgp_multihop": 3, #< ebgp_multihop | default -> 3 >
                                            "maximum_routes": 0,
                                            "maximum_routes_warning_limit": 12000
                                        }
                                    },
                                    "spine": {
                                        "IPv4_UNDERLAY_PEERS": {
                                            "name": "IPv4_UNDERLAY_PEERS",
                                            "description": "ipv4 peering",
                                            "send_community": "all",
                                            "password": None,
                                            ## "bfd": True,
                                            "maximum_routes": 12000
                                        },
                                        "EVPN_OVERLAY_PEERS": {
                                            "name": "EVPN_OVERLAY_PEERS",
                                            "description": "evpn overlay peering",
                                            "update_source": "Loopback0",
                                            "next_hop_unchanged": True,
                                            "send_community": "all",
                                            "bfd": True,
                                            "password": None,
                                            "ebgp_multihop": 3, #< ebgp_multihop | default -> 3 >
                                            "maximum_routes": 0,
                                            "maximum_routes_warning_limit": 12000
                                        }
                                    }
                                },
                                "spine_defaults": [
                                    "update wait-for-convergence",
                                    "update wait-install",
                                    "no bgp default ipv4-unicast",
                                    "distance bgp 20 200 200",
                                    "graceful-restart restart-time 300",
                                    "graceful-restart"
                                ],
                                "leaf_defaults": [
                                    "update wait-install",
                                    "no bgp default ipv4-unicast",
                                    "distance bgp 20 200 200",
                                    "graceful-restart restart-time 300",
                                    "graceful-restart"
                                ],
                                "dynamic_peering": True,
                                "evpn_enabled": True
                            }
                            self.spanning_tree_mode = None
                            self.filters = {
                                "route_maps": {
                                    "connected_to_bgp":{
                                        "name": "RM-CONN-2-BGP"
                                    }
                                },
                                "prefix_lists": {
                                    "loopbacks":{
                                        "name": "PL_LOOPBACKS"
                                    },
                                    "transit":{
                                        "name": "PL_P2P_UNDERLAY"
                                    }
                                },
                                "peer_filters": {
                                    "bgp_range_accept" : {
                                        "name": "LEAF-AS-Range"
                                    }
                                }
                            }

                    def get_pod_details(studios_schema_input):
                        pod = Pod()
                        dc = studios_schema_input["dataCenter"]
                        dcPods = dc["pods"].resolve()
                        if dcPods is None or dcPods['pod'] is None:
                            return None
                        lacp_mode_mapper = {
                            "active": "active",
                            "passive": "passive",
                            "on (static)": "on"
                        }
                        pod.underlay_routing_protocol = dcPods["pod"]["underlayRouting"]["underlayRoutingProtocol"].lower()
                        pod.overlay_routing_protocol = "bgp"
                        pod.underlay_p2p_network_summaries = [ subnet.strip() for subnet in dcPods["pod"]["underlayRouting"]["underlayFabricSubnet"].split(",") ]
                        pod.underlay_p2p_subnet_mask = int(dcPods["pod"]["underlayRouting"]["underlayFabricSubnetMask"])
                        try:
                            pod.max_spines = dcPods["pod"]["maximums"]["maxSpines"]
                        except (KeyError, ValueError, TypeError):
                            pod.max_spines = None
                        pod.overlay_loopback_network_summary_spines = dcPods["pod"]["commonBGPConfig"]["spineLoopback0Subnet"]
                        pod.overlay_loopback_network_summary_leafs = dcPods["pod"]["commonBGPConfig"]["leafLoopback0Subnet"]
                        pod.vxlan_overlay = dcPods["pod"]["overlayDetails"]["vxlanOverlay"]
                        pod.vtep_loopback_network_summary =  dcPods["pod"]["overlayDetails"]["leafLoopback1Subnet"]
                        pod.vtep_vvtep_ip = dcPods["pod"]["overlayDetails"]["vVtepAddress"] if dcPods["pod"]["overlayDetails"]["vVtepAddress"].strip() != "" else None
                        pod.spanning_tree_mode = dcPods["pod"]["spanningTreeMode"].lower()
                        pod.mlag["mlag_ip_subnet"] = dcPods["pod"]["commonMlagConfig"]["mlagPeerLinkSubnet"]
                        pod.mlag["mlag_subnet_mask"] = int(dcPods["pod"]["commonMlagConfig"]["mlagSubnetMask"])
                        pod.mlag["mlag_peer_link_id"] = int(dcPods["pod"]["commonMlagConfig"]["mlagPortChannelId"])
                        pod.mlag["mlag_peer_vlan"] = int(dcPods["pod"]["commonMlagConfig"]["mlagVlan"])
                        pod.mlag["lacp_mode"] = lacp_mode_mapper[ dcPods["pod"]["commonMlagConfig"]["lacpMode"] ]
                        pod.mlag["ip_virtual_router_mac_address"] = dcPods["pod"]["commonMlagConfig"]["virtualRouterMacAddress"]
                        pod.bgp["spines_asn"] = dcPods["pod"]["commonBGPConfig"]["spineAsn"]
                        pod.bgp["leafs_asn_range"] = dcPods["pod"]["commonBGPConfig"]["leafAsnRange"]
                        pod.bgp["dynamic_peering"] = dcPods["pod"]["commonBGPConfig"]["spineBGPDynamicNeighbors"]
                        pod.bgp["evpn_enabled"] = dcPods["pod"]["commonBGPConfig"]["evpnEnabled"]
                        return pod

                    class SwitchDetails:
                        def __init__(self):
                            self.id = None
                            self.model = None #Model tag
                            self.eos_version = None #Eos version tag
                            self.role= None #Role tag
                            self.hostname = None #hostname tag
                            self.dc = None #DC tag
                            self.dc_pod = None #DC-Pod tag
                            self.uplink_interfaces = {}
                            self.downlink_interfaces = {}
                            self.mlag_peer_link_interfaces = {}
                            self.config = {
                                "ip_routing": False,
                                "service_routing_protocols_model": None,
                                "ip_virtual_router_mac_address": None,
                                "vlans": {},
                                "spanning_tree":{
                                    "mode": None,
                                    "no_spanning_tree_vlan": None
                                },
                                "ethernet_interfaces": {},
                                "port_channel_interfaces": {},
                                "loopback_interfaces": {},
                                "vlan_interfaces": {},
                                "vxlan_tunnel_interface": None,
                                "mlag_configuration":{
                                    "enabled": False,
                                    "domain_id": None,
                                    "local_interace": None,
                                    "peer_address": None,
                                    "peer_link": None,
                                    "reload_delay_mlag": 300,
                                    "reload_delay_non_mlag": 330
                                },
                                "prefix_lists": {},
                                "route_maps": {},
                                "router_bgp":{
                                    "as": None,
                                    "router_id": None,
                                    "ecmp": None,
                                    "maximum_paths": None,
                                    "bgp_defaults": [],
                                    "peer_groups": {},
                                    "neighbors": {},
                                    "redistribute_routes":{
                                        "connected": {

                                        }
                                    }
                                }
                            }

                        def set_bgp_tags(self):
                            #Set ASN and Router_ID Tags
                            tag_labels = {"router_bgp.as": self.config["router_bgp"]["as"], "router_bgp.router_id":self.config["router_bgp"]["router_id"]}
                            for label, config_path in tag_labels.items():
                                #Create desired tag (will not create tag if it already exists):
                                tag_key = TagKey()
                                tag_key.workspace_id.value = workspace_id
                                tag_key.element_type = 1
                                tag_key.label.value = label
                                tag_key.value.value = str(config_path)
                                create_tag(tag_key)

                                #Apply desired tag
                                tag_assignment_key = TagAssignmentKey()
                                tag_assignment_key.workspace_id.value = workspace_id
                                tag_assignment_key.element_type = 1
                                tag_assignment_key.label.value = label
                                tag_assignment_key.value.value = str(config_path)
                                tag_assignment_key.device_id.value = self.id
                                apply_tag(tag_assignment_key)

                                #Remove other tags with same label that don't match proper value
                                tag_assignment_key = TagAssignmentKey()
                                tag_assignment_key.workspace_id.value = workspace_id
                                tag_assignment_key.element_type = 1
                                tag_assignment_key.label.value = label
                                tag_assignment_key.device_id.value =  self.id
                                applied_tags = get_tag_values_applied_to_device(tag_assignment_key)
                                for tag in applied_tags:
                                    if tag.value != str(config_path):
                                        tag_assignment_key.value.value = tag.value
                                        remove_tag(tag_assignment_key)

                        def get_highest_role_number(self, role):
                            '''
                            role ( str ) -> Options are ether "Leaf", "Spine", or "Super-Spine"

                            Returns ( int ) -> Highest role index number within dc or pod
                            '''
                            role_to_attr = {
                                "Leaf": "leaf_number",
                                "Spine": "spine_number",
                                "Super-Spine": "super_spine_number"
                            }
                            highest_index = 0
                            device_ids_in_same_pod_or_dc = []

                            #Get devices in same pod or DC
                            for switch, switch_object in switches_in_dc.items():
                                if switch_object.role == role:
                                    if role != "Super-Spine":
                                        if switch_object.dc_pod == self.dc_pod and int(getattr(switch_object, role_to_attr[role])) > highest_index:
                                            highest_index = int(getattr(switch_object, role_to_attr[role]))
                                    else:
                                        if switch_object.dc == self.dc and int(getattr(switch_object, role_to_attr[role])) > highest_index:
                                            highest_index = int(getattr(switch_object, role_to_attr[role]))

                            return highest_index

                        def set_spanning_tree(self, pod):
                            self.config["spanning_tree"]["mode"] = pod.spanning_tree_mode

                        def merge_multilane_interfaces(self):
                            ''' 
                            Combines ethernet interface lanes that share common LLDP neighbor
                            self.x_interfaces looks like { "EthernetX": {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name} }
                            '''
                        
                            #If we see the same neighbor on multiple lanes of an interface - merge the interface lanes
                            interface_attrs = {
                                    "mlag_peer_link_interfaces": self.mlag_peer_link_interfaces,
                                    "uplink_interfaces": self.uplink_interfaces,
                                    "downlink_interfaces": self.downlink_interfaces
                                }
                            for attr, ifaces in interface_attrs.items():
                                sorted_ifaces = natural_sort(ifaces.keys())
                                for iface in sorted_ifaces:
                                    #Check to see if iface has already been removed from interfaces
                                    if not ifaces.get(iface):                        
                                        continue
                                    slash_count = alphanum_key(iface).count("/")
                                    if slash_count == 0:
                                        continue
                                    iface_group = "".join( [ str(i) for i in alphanum_key(iface)[ : slash_count * 2 ] ] )
                                    #Compare rest of the interfaces in that group to see if they have the same neighbor
                                    for member_iface in sorted_ifaces:
                                        if "".join( [ str(i) for i in alphanum_key(member_iface)[ : slash_count * 2 ] ] ) == iface_group and iface != member_iface:
                                            if ifaces[iface]["neighborHostname"] == ifaces[member_iface]["neighborHostname"]:
                                                del ifaces[member_iface]
                                setattr(self, attr, ifaces)

                    class LeafDetails(SwitchDetails):
                        def __init__(self):
                            super().__init__()
                            self.role = "Leaf"
                            self.leaf_number = None #Leaf-Number tag
                            self.leaf_domain = None #Leaf-Domain tag

                        def __str__(self):
                            return "{} - {}\n   role: {}\n   leaf number: {}\n   leaf domain: {}".format(self.hostname, self.id, self.role, self.leaf_number, self.leaf_domain)

                        def check_tags(self):
                            tags = {
                                "dc" : {"label": "DC", "type": str},
                                "dc_pod" : {"label": "DC-Pod", "type": str},
                                "leaf_number" : {"label": "Leaf-Number", "type": int},
                                "leaf_domain" : {"label": "Leaf-Domain", "type": int},
                            }
                            for tag in tags.keys():
                                assert getattr(self, tag) is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                                    tags[tag]["label"], tags[tag]["label"], self.hostname
                                )
                                try:
                                    value_type = tags[tag]["type"](getattr(self, tag))
                                except ValueError:
                                    assert False, "'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}".format(
                                        tags[tag]["label"], self.hostname, getattr(self, tag), tags[tag]["type"]
                                        )

                        def get_interfaces(self):
                            '''
                            Gets and sets the physical ethernet interfaces for connections from switch
                            Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:
                            {
                                "neighborHostname": str,
                                "neighborInterface": str
                            }

                            '''
                            uplink_interfaces = {}
                            downlink_interfaces = {}
                            mlag_peer_link_interfaces = {}
                            for i in my_device.getInterfaces():
                                peer_device, peer_interface = i.getPeerInfo()
                                if peer_device is not None:
                                    if switches_in_dc.get(peer_device.hostName):
                                        neighbor = switches_in_dc.get(peer_device.hostName)
                                        if neighbor.role == "Leaf" and self.leaf_domain == neighbor.leaf_domain:
                                            mlag_peer_link_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                                        elif neighbor.role == "Spine":
                                            uplink_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                                        elif neighbor.role == "L2-Leaf":
                                            downlink_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                            self.uplink_interfaces = uplink_interfaces
                            self.downlink_interfaces = downlink_interfaces
                            self.mlag_peer_link_interfaces = mlag_peer_link_interfaces
                            return

                        def check_mlag_role(self):
                            '''
                            Returns 'Primary', 'Secondary', or None if no MLAG neighbor present
                            '''
                            for switch_object in switches_in_dc.values():
                                #Skip over self and non leaf switches
                                if switch_object.id == self.id or switch_object.role != "Leaf":
                                    continue
                                if switch_object.dc_pod == self.dc_pod and switch_object.leaf_domain == self.leaf_domain:
                                    if int(self.leaf_number) < int(switch_object.leaf_number):
                                        return "Primary"
                                    else:
                                        return "Secondary"
                            return None

                        def get_asn_from_input(self, studios_input):
                            try:
                                asn = int( studios_input["dataCenter"]["pods"].resolve()["pod"]["LeafDomains"].resolve(device=self.id)["l3LeafDomain"]["asn"] )
                            except:
                                return
                            if asn != 0:
                                self.config["router_bgp"]["as"] = asn

                        def set_mlag(self, pod):
                            # check if switch is primary or secondary based on leaf_number
                            mlag_role = self.check_mlag_role()
                            if mlag_role is None:
                                self.config["mlag_configuration"]["enabled"] = False
                                return
                            else:
                                self.config["mlag_configuration"]["enabled"] = True
                            #Set Spanning Tree No Vlan
                            self.config["spanning_tree"]["no_spanning_tree_vlan"] = pod.mlag["mlag_peer_vlan"]

                            #Set Vlans
                            self.config["vlans"][ pod.mlag["mlag_peer_vlan"] ] = {
                                "name": pod.mlag["mlag_vlan_name"],
                                "trunk_groups": [
                                    pod.mlag["mlag_vlan_trunk_group_name"]
                                ]
                            }
                            #Set Port-Channel
                            self.config["port_channel_interfaces"][ "Port-Channel{}".format(pod.mlag["mlag_peer_link_id"]) ] = {
                                "description": pod.mlag["mlag_peer_link_description"],
                                "mode": "trunk",
                                "trunk_groups": [
                                    pod.mlag["mlag_vlan_trunk_group_name"]
                                    ]
                                }
                            #Set Ethernet interfaces
                            for iface, details in self.mlag_peer_link_interfaces.items():
                                self.config["ethernet_interfaces"][iface] = {
                                    #"description": pod.mlag["mlag_peer_link_member_iface_description"].format(info["neighborHostname"], info["neighborInterface"]),
                                    "description": "MLAG peer link member interface",
                                    "channel_group":{
                                        "id" : pod.mlag["mlag_peer_link_id"],
                                        "mode" : pod.mlag["lacp_mode"]
                                    }
                                }
                            #Get MLAG IP info
                            # check MLAG subnet and size of MLAG Subnet mask
                            mlag_subnet = ipaddress.ip_network(pod.mlag["mlag_ip_subnet"])
                            mlag_subnet_mask = pod.mlag["mlag_subnet_mask"]
                            if mlag_subnet_mask != mlag_subnet.prefixlen:
                                mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[ int(self.leaf_domain) - 1 ]

                            if mlag_role == "Primary":
                                mlag_ip = str(list(mlag_subnet.hosts())[0])
                                mlag_peer_ip = str(list(mlag_subnet.hosts())[1])
                            else:
                                mlag_ip = str(list(mlag_subnet.hosts())[1])
                                mlag_peer_ip = str(list(mlag_subnet.hosts())[0])

                            #Set SVI
                            self.config["vlan_interfaces"][ "Vlan{}".format(pod.mlag["mlag_peer_vlan"]) ] = {
                                "description": "MLAG peering source",
                                "mtu": 9214,
                                "no_autostate": True,
                                "ip_address": "{}/{}".format(mlag_ip, mlag_subnet_mask)
                            }
                            if self.model in ["vEOS", "veos", "cEOS", "ceos"]:
                                self.config["vlan_interfaces"][ "Vlan{}".format(pod.mlag["mlag_peer_vlan"]) ]["mtu"] = 1500
                            # Set virtual_router_mac_address
                            self.config["ip_virtual_router_mac_address"] = pod.mlag["ip_virtual_router_mac_address"]

                            #Set MLAG config
                            self.config["mlag_configuration"]["domain_id"] = pod.mlag["mlag_domain_id"]
                            self.config["mlag_configuration"]["local_interface"] = "Vlan{}".format(pod.mlag["mlag_peer_vlan"])
                            self.config["mlag_configuration"]["peer_address"] = mlag_peer_ip
                            self.config["mlag_configuration"]["peer_link"] = "Port-Channel{}".format(pod.mlag["mlag_peer_link_id"])

                            #Change MLAG reload delay timers if Jericho platform
                            for regex in jericho_platform_regexes:
                                if re.search(regex, self.model):
                                    self.config["mlag_configuration"]["reload_delay_mlag"] = 780
                                    self.config["mlag_configuration"]["reload_delay_non_mlag"] = 1020
                                    break

                            #Set BGP peer group parameters
                            if self.config["router_bgp"]["as"] is None:
                                assert  self.config["router_bgp"]["as"] is not None, "{} does not have a BGP AS set".format(self.hostname)

                            self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] ] = {}
                            for k, v in pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"].items():
                                self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] ][k] = v
                        
                            # Set remote as
                            self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] ]["remote_as"] = int(self.config["router_bgp"]["as"])

                            self.config["router_bgp"]["neighbors"][mlag_peer_ip] = {"peer_group": pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] }

                            # Activate ipv4 address family for peer group
                            if self.config["router_bgp"].get("address_family_ipv4") is not None and self.config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
                                self.config["router_bgp"]["address_family_ipv4"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] ] = {"activate": True}
                            else:
                                self.config["router_bgp"]["address_family_ipv4"] = { 
                                    "peer_groups" : {
                                        pod.bgp["peer_groups"]["leaf"]["MLAG_IPv4_UNDERLAY_PEER"]["name"] : {"activate": True}
                                    }
                                }     
                            label = "mlag_configuration.peer_link"
                            value = self.config["mlag_configuration"]["peer_link"]
                            #Create desired tag (will not create tag if it already exists):
                            tag_key = TagKey()
                            tag_key.workspace_id.value = workspace_id
                            tag_key.element_type = 1
                            tag_key.label.value = label
                            tag_key.value.value = str(value)
                            create_tag(tag_key)
                            
                            #Apply desired tag
                            tag_assignment_key = TagAssignmentKey()
                            tag_assignment_key.workspace_id.value = workspace_id
                            tag_assignment_key.element_type = 1
                            tag_assignment_key.label.value = label
                            tag_assignment_key.value.value = str(value)
                            tag_assignment_key.device_id.value = self.id
                            apply_tag(tag_assignment_key)

                            #Remove other tags with same label that don't match proper value
                            tag_assignment_key = TagAssignmentKey()
                            tag_assignment_key.workspace_id.value = workspace_id
                            tag_assignment_key.element_type = 1
                            tag_assignment_key.label.value = label
                            tag_assignment_key.device_id.value =  self.id
                            applied_tags = get_tag_values_applied_to_device(tag_assignment_key)
                            for tag in applied_tags:
                                if tag.value != str(value):
                                    tag_assignment_key.value.value = tag.value
                                    remove_tag(tag_assignment_key)

                        def set_bgp(self, pod):
                            #Set routing protocol model to multi-agent
                            self.config["service_routing_protocols_model"] = "multi-agent"

                            # Function call for number of spines
                            highest_spine_number = self.get_highest_role_number("Spine")
                            
                            #Make pod.underlay_p2p_network_summaries IPv4 Network objects
                            for i, network in enumerate(pod.underlay_p2p_network_summaries):
                                pod.underlay_p2p_network_summaries[i] = ipaddress.ip_network(network)

                            # If we have a mismatch of spines and link subnets, then we split the first item in the list by a number that is a power of 2
                            if len(pod.underlay_p2p_network_summaries) > 1 and len(pod.underlay_p2p_network_summaries) != highest_spine_number:
                                assert False, "Please enter a single underlay subnet or an underlay subnet for each spine in the Pod."

                            max_spines = pod.max_spines if pod.max_spines is not None else highest_spine_number
                            for i, iface in enumerate(natural_sort(self.uplink_interfaces.keys())):
                                uplink_subnet_mask = pod.underlay_p2p_subnet_mask
                                if len(pod.underlay_p2p_network_summaries) > 1:
                                    spine_index = int(switches_in_dc[self.uplink_interfaces[iface]["neighborHostname"]].spine_number)
                                    uplink_subnet = ipaddress.ip_network(pod.underlay_p2p_network_summaries[ spine_index - 1 ])
                                    uplink__child_subnet = list(uplink_subnet.subnets(new_prefix=uplink_subnet_mask))[ (int(self.leaf_number) - 1) ]
                                else:
                                    uplink_subnet = ipaddress.ip_network(pod.underlay_p2p_network_summaries[0])
                                    uplink__child_subnet = list(uplink_subnet.subnets(new_prefix=uplink_subnet_mask))[ ( int(self.leaf_number) - 1) * max_spines + i ]
                                
                                local_ip = None
                                neighbor_ip = None            

                                local_ip = str(list(uplink__child_subnet.hosts())[1]) + '/' + str(uplink_subnet_mask)
                                neighbor_ip = str(list(uplink__child_subnet.hosts())[0])
                                
                                #Update uplink interface details
                                self.uplink_interfaces[iface]["ip_address"] = local_ip
                                self.uplink_interfaces[iface]["neighbor_ip_address"] = neighbor_ip

                                if self.config['ethernet_interfaces'] is None:
                                    self.config['ethernet_interfaces'] = {}

                                self.config['ethernet_interfaces'][iface] = {
                                    "ip_address": local_ip, 
                                    "neighbor_ip_address": neighbor_ip,
                                    "mtu": pod.p2p_uplinks_mtu,
                                    "description": "to {}:{}".format(self.uplink_interfaces[iface]["neighborHostname"], self.uplink_interfaces[iface]["neighborInterface"]),
                                    "type": "routed"
                                }
                                if self.model in ["vEOS", "veos", "cEOS", "ceos"]:
                                    self.config['ethernet_interfaces'][iface]["mtu"] = 1500

                            # Loopback
                            #Set Loopback0 parameters
                            if self.config['loopback_interfaces'] is None:
                                self.config['loopback_interfaces'] = {}
                            
                            if pod.overlay_loopback_network_summary_leafs == pod.overlay_loopback_network_summary_spines:
                                loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_leafs ).hosts() )[ int(self.leaf_number) + int(max_spines) - 1 ])
                            else:
                                loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_leafs ).hosts() )[ int(self.leaf_number) - 1 ])

                            self.config['loopback_interfaces']['Loopback0'] = {
                                "ip_address": loopback0_ip_address + "/32",
                                "description": "BGP Router ID"
                                }
                            # Set Loopback1 parameters
                            if pod.vxlan_overlay == True:
                                self.config['loopback_interfaces']['Loopback1'] = {
                                    "ip_address": str(list( ipaddress.IPv4Network( pod.vtep_loopback_network_summary ).hosts() )[ int(self.leaf_domain) - 1 ]) + "/32",
                                    "description": "VXLAN Tunnel Source"
                                }
                                if pod.vtep_vvtep_ip is not None:
                                    self.config['loopback_interfaces']['Loopback1']["ip_address_secondaries"] = [ str(pod.vtep_vvtep_ip) ]

                                self.config["vxlan_tunnel_interface"] = {
                                    "Vxlan1": {
                                        "source_interface": "Loopback1",
                                        "vxlan_udp_port": "4789",
                                    }
                                }
                                if self.check_mlag_role() is not None:
                                    self.config["vxlan_tunnel_interface"]["Vxlan1"]["virtual_router"] = {"encapsulation_mac_address": "mlag-system-id"}
                            # Enable IP Routing
                            self.config['ip_routing'] = True

                            # IP Prefix Lists
                            #    P2P Underlay
                            self.config["prefix_lists"][ pod.filters["prefix_lists"]["transit"]["name"] ] = { "sequence_numbers": {} }
                            for i, network in enumerate(pod.underlay_p2p_network_summaries):
                                self.config["prefix_lists"][ pod.filters["prefix_lists"]["transit"]["name"] ]["sequence_numbers"][ (i+1) * 10 ] = {
                                    "action": "permit {} le {}".format(network, pod.underlay_p2p_subnet_mask)
                                }
                            #    Loopbacks
                            self.config["prefix_lists"][ pod.filters["prefix_lists"]["loopbacks"]["name"] ] = {
                                "sequence_numbers": {
                                    10 : {
                                        "action": "permit {} eq 32".format(pod.overlay_loopback_network_summary_leafs)
                                    }
                                }
                            }
                            if pod.vxlan_overlay == True:            
                                self.config["prefix_lists"][ pod.filters["prefix_lists"]["loopbacks"]["name"] ]["sequence_numbers"][20] = {
                                    "action": "permit {} eq 32".format(pod.vtep_loopback_network_summary)    
                                }
                            # Routemaps
                            self.config["route_maps"][ pod.filters["route_maps"]["connected_to_bgp"]["name"] ] = {
                                "sequence_numbers":{
                                    10: {
                                        "type": "permit",
                                        "match": [ "ip address prefix-list {}".format(pod.filters["prefix_lists"]["transit"]["name"]) ]
                                    },
                                    20: {
                                        "type": "permit",
                                        "match": [ "ip address prefix-list {}".format(pod.filters["prefix_lists"]["loopbacks"]["name"]) ]
                                    }
                                }
                            }
                            # BGP Config
                            # Set BGP ASN
                            if self.config["router_bgp"]["as"] is None:
                                assert  self.config["router_bgp"]["as"] is not None, "{} does not have a BGP AS set".format(self.hostname)
                            # Set Router ID
                            self.config["router_bgp"]["router_id"] = loopback0_ip_address
                            # Set ECMP and Max Paths
                            self.config["router_bgp"]["ecmp"] = pod.bgp["ecmp"]
                            self.config["router_bgp"]["maximum_paths"] = pod.bgp["maximum_paths"]
                            # Set defaults
                            self.config["router_bgp"]["bgp_defaults"] = pod.bgp["leaf_defaults"]
                            if self.model in ["vEOS", "veos", "cEOS", "ceos"]:
                                try:
                                    self.config["router_bgp"]["bgp_defaults"].remove("update wait-for-convergence")
                                except ValueError:
                                    pass
                                try:
                                    self.config["router_bgp"]["bgp_defaults"].remove("update wait-install")
                                except ValueError:
                                    pass

                            # Set up IPv4 peer groups
                            self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"] ] = {}
                            for k, v in pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"].items():
                                self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"] ][k] = v
                            # Set remote as
                            self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"] ]["remote_as"] = int(pod.bgp["spines_asn"])

                            # Set up IPv4 neighbors
                            for iface, details in self.uplink_interfaces.items():
                                if "neighbor_ip_address" in details.keys():
                                    self.config["router_bgp"]["neighbors"][ str(details["neighbor_ip_address"]) ] = {
                                        "peer_group": pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"]
                                    }

                            # Enable IPv4 address family
                            #  if mlagipv4 peer group is alreeady in address_family_ipv4 peer_group dictionary
                            if ( "address_family_ipv4" in self.config["router_bgp"].keys() ) and ( "peer_groups" in self.config["router_bgp"]["address_family_ipv4"].keys() ):
                                self.config["router_bgp"]["address_family_ipv4"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"] ] = {
                                    "activate": True
                                }
                            else:
                                self.config["router_bgp"]["address_family_ipv4"] = {
                                    "peer_groups":{
                                        pod.bgp["peer_groups"]["leaf"]["IPv4_UNDERLAY_PEERS"]["name"] :{
                                            "activate": True
                                        }
                                    }
                                }

                            # If EVPN is enabled
                            if pod.bgp["evpn_enabled"] == True:
                                # Set up EVPN peer groups and neighbors
                                self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"] ] = {}
                                for k, v in pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"].items():
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"] ][k] = v

                                # Set up EVPN neighbors
                                #Get hosts from max spine/superspine number and pod.overlay_loopback_network_summary_spines/superspines
                                if pod.bgp["super_spines_asn"] is not None and int(pod.bgp["super_spines_asn"]) != 0:
                                    #Add Remote ASN to peer-group
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"] ]["remote_as"] = int(pod.bgp["super_spines_asn"])
                                    
                                    #Configure super spines is EVPN peers
                                    highest_evpn_peer_node_index = self.get_highest_role_number("Super-Spine") # get highest superspine tag
                                    evpn_peering_subnet = ipaddress.ip_network(pod.overlay_loopback_network_summary_super_spines)
                                else:
                                    #Add Remote ASN to peer-group
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"] ]["remote_as"] = int(pod.bgp["spines_asn"])

                                    #Configure spines as EVPN peers
                                    highest_evpn_peer_node_index = self.get_highest_role_number("Spine") # get highest spine tag
                                    evpn_peering_subnet = ipaddress.ip_network(pod.overlay_loopback_network_summary_spines)
                                evpn_peer_addresses = [ str( list( evpn_peering_subnet.hosts() )[i] ) for i in range(0, highest_evpn_peer_node_index) ]
                                for peer_address in evpn_peer_addresses:
                                    self.config["router_bgp"]["neighbors"][ str(peer_address) ] = {
                                        "peer_group": pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"]
                                    }
                                #Enable EVPN address family
                                self.config["router_bgp"]["address_family_evpn"] = {
                                    "peer_groups":{
                                        pod.bgp["peer_groups"]["leaf"]["EVPN_OVERLAY_PEERS"]["name"] :{
                                            "activate": True
                                        }
                                    }
                                }

                            # Set up redistributed connected parameters
                            self.config["router_bgp"]["redistribute_routes"]["connected"] = {
                                "route_map": pod.filters["route_maps"]["connected_to_bgp"]["name"]
                            }

                            # Enabke Vxlan profile in tcam if necessary
                            if pod.vxlan_overlay == True:
                                for regex in jericho_platform_regexes:
                                    if re.search(regex, self.model):
                                        self.config["tcam_profile"] = {
                                            "system": "vxlan-routing"
                                        }
                                        break

                            #Set BGP Tags
                            self.set_bgp_tags()


                        def create_config_parameters(self, pod):
                            '''
                            Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template 
                            '''
                            self.set_spanning_tree(pod)
                            self.set_mlag(pod)
                            self.set_bgp(pod)
                            return self.config

                    class SpineDetails(SwitchDetails):
                        def __init__(self):
                            super().__init__()
                            self.role = "Spine"
                            self.spine_number = None

                        def __str__(self):
                            return "{} - {}\n   role: {}\n   spine number: {}".format(self.hostname, self.id, self.role, self.spine_number)

                        def check_tags(self):
                            tags = {
                                "dc" : {"label": "DC", "type": str},
                                "dc_pod" : {"label": "DC-Pod", "type": str},
                                "spine_number" : {"label": "Spine-Number", "type": int}
                            }
                            for tag in tags.keys():
                                assert getattr(self, tag) is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                                    tags[tag]["label"], tags[tag]["label"], self.hostname
                                )
                                try:
                                    value_type = tags[tag]["type"](getattr(self, tag))
                                except ValueError:
                                    assert False, "'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}".format(
                                        tags[tag]["label"], self.hostname, getattr(self, tag), tags[tag]["type"]
                                        )

                        def get_interfaces(self):
                            '''
                            Gets and sets the physical ethernet interfaces for connections from switch
                            Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:
                            {
                                "neighborHostname": str,
                                "neighborInterface": str
                            }

                            '''
                            uplink_interfaces = {}
                            downlink_interfaces = {}
                            for i in my_device.getInterfaces():
                                peer_device, peer_interface = i.getPeerInfo()
                                if peer_device is not None:
                                    #Check to see if switch name in switches_in_dc
                                    if switches_in_dc.get(peer_device.hostName):
                                        neighbor = switches_in_dc.get(peer_device.hostName)
                                        if neighbor.role == "Super-Spine":
                                            uplink_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                                        elif neighbor.role == "Leaf":
                                            downlink_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                            self.uplink_interfaces = uplink_interfaces
                            self.downlink_interfaces = downlink_interfaces
                            return
                            
                        def set_bgp(self, pod):
                            #Set routing protocol model to multi-agent
                            self.config["service_routing_protocols_model"] = "multi-agent"
                            
                            # Function call for number of spines
                            highest_spine_number = self.get_highest_role_number("Spine")
                            
                            #Make pod.underlay_p2p_network_summaries IPv4 Network objects
                            for i, network in enumerate(pod.underlay_p2p_network_summaries):
                                pod.underlay_p2p_network_summaries[i] = ipaddress.ip_network(network)

                            # If we have a mismatch of spines and link subnets, then we split the first item in the list by a number that is a power of 2
                            if len(pod.underlay_p2p_network_summaries) > 1 and len(pod.underlay_p2p_network_summaries) != highest_spine_number:
                                assert False, "Please enter a single underlay subnet or an underlay subnet for each spine in the Pod."
                            
                            downlink_subnet_mask = pod.underlay_p2p_subnet_mask
                            if len(pod.underlay_p2p_network_summaries) > 1:
                                downlink_subnet = pod.underlay_p2p_network_summaries[ int(self.spine_number) - 1 ]
                            else:
                                downlink_subnet = pod.underlay_p2p_network_summaries[ 0 ]

                            max_spines = pod.max_spines if pod.max_spines is not None else highest_spine_number
                            for i, iface in enumerate(natural_sort(self.downlink_interfaces.keys())):
                                leaf_index = int(switches_in_dc[self.downlink_interfaces[iface]["neighborHostname"]].leaf_number)
                                
                                if len(pod.underlay_p2p_network_summaries) > 1:
                                    downlink_child_subnet = list(downlink_subnet.subnets(new_prefix=downlink_subnet_mask))[ leaf_index - 1 ]
                                else:
                                    downlink_child_subnet = list(downlink_subnet.subnets(new_prefix=downlink_subnet_mask))[ (leaf_index - 1) * max_spines + (int(self.spine_number) - 1) ]

                                local_ip = str(list(downlink_child_subnet.hosts())[0]) + '/' + str(downlink_subnet_mask)
                                neighbor_ip = str(list(downlink_child_subnet.hosts())[1])

                                #Set BGP peer group parameters
                                #Update neighbor asn
                                if switches_in_dc[self.downlink_interfaces[iface]["neighborHostname"]].config["router_bgp"]["as"] is None:
                                    assert  switches_in_dc[self.downlink_interfaces[iface]["neighborHostname"]].config["router_bgp"]["as"] is not None, "{} does not have a BGP AS set".format(self.hostname)
                                else:
                                    neighbor_asn = switches_in_dc[self.downlink_interfaces[iface]["neighborHostname"]].config["router_bgp"]["as"]
                                
                                self.downlink_interfaces[iface]["ip_address"] = local_ip
                                self.downlink_interfaces[iface]["neighbor_ip_address"] = neighbor_ip
                                self.downlink_interfaces[iface]["neighbor_asn"] = neighbor_asn

                                if self.config['ethernet_interfaces'] is None:
                                    self.config['ethernet_interfaces'] = {}

                                self.config['ethernet_interfaces'][iface] = {
                                    "ip_address": local_ip, 
                                    "neighbor_ip_address": neighbor_ip,
                                    "mtu": pod.p2p_uplinks_mtu,
                                    "description": "to {}:{}".format(self.downlink_interfaces[iface]["neighborHostname"], self.downlink_interfaces[iface]["neighborInterface"]),
                                    "type": "routed"
                                    }
                                if self.model in ["vEOS", "veos", "cEOS", "ceos"]:
                                    self.config['ethernet_interfaces'][iface]["mtu"] = 1500
                            # Loopback
                            if self.config['loopback_interfaces'] is None:
                                self.config['loopback_interfaces'] = {}
                            
                            loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_spines ).hosts() )[ int(self.spine_number) - 1 ])
                            self.config['loopback_interfaces']['Loopback0'] = {
                                "ip_address": loopback0_ip_address + "/32",
                                "description": "BGP Router ID"}

                            # Enable IP Routing
                            self.config['ip_routing'] = True

                            # IP Prefix Lists
                            #P2P Underlay
                            self.config["prefix_lists"][ pod.filters["prefix_lists"]["transit"]["name"] ] = { "sequence_numbers": {} }
                            for i, network in enumerate(pod.underlay_p2p_network_summaries):
                                self.config["prefix_lists"][ pod.filters["prefix_lists"]["transit"]["name"] ]["sequence_numbers"][ (i+1) * 10 ] = {
                                    "action": "permit {} le {}".format(network, pod.underlay_p2p_subnet_mask)
                                }
                            # Loopbacks
                            self.config["prefix_lists"][ pod.filters["prefix_lists"]["loopbacks"]["name"] ] = {
                                "sequence_numbers": {
                                    10 : {
                                        "action": "permit {} eq 32".format(pod.overlay_loopback_network_summary_spines)
                                    }
                                }
                            }

                            # Routemaps
                            self.config["route_maps"][ pod.filters["route_maps"]["connected_to_bgp"]["name"] ] = {
                                "sequence_numbers":{
                                    10: {
                                        "type": "permit",
                                        "match": [ "ip address prefix-list {}".format(pod.filters["prefix_lists"]["transit"]["name"]) ]
                                    },
                                    20: {
                                        "type": "permit",
                                        "match": [ "ip address prefix-list {}".format(pod.filters["prefix_lists"]["loopbacks"]["name"]) ]
                                    }
                                }
                            }

                            # BGP Config
                            # Set BGP ASN
                            if self.config["router_bgp"]["as"] is None:
                                self.config["router_bgp"]["as"] = pod.bgp["spines_asn"]
                            # Set Router ID
                            self.config["router_bgp"]["router_id"] = loopback0_ip_address
                            # Set ECMP and Max Paths
                            self.config["router_bgp"]["ecmp"] = pod.bgp["ecmp"]
                            self.config["router_bgp"]["maximum_paths"] = pod.bgp["maximum_paths"]
                            # Set defaults
                            self.config["router_bgp"]["bgp_defaults"] = pod.bgp["spine_defaults"]
                            if self.model in ["vEOS", "veos", "cEOS", "ceos"]:
                                try:
                                    self.config["router_bgp"]["bgp_defaults"].remove("update wait-for-convergence")
                                except ValueError:
                                    pass
                                try:
                                    self.config["router_bgp"]["bgp_defaults"].remove("update wait-install")
                                except ValueError:
                                    pass
                            # Set up IPv4 peer groups
                            self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] ] = {}
                            for k, v in pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"].items():
                                self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] ][k] = v

                            # Set up IPv4 neighbors
                            #Set up dynamic BGP peering or Neighbor based
                            if pod.bgp["dynamic_peering"] == True:
                                #Divide leafs_asn_range into as few continuous asn ranges as possible
                                dynamic_peering_peer_filter_statements = []
                                from operator import itemgetter
                                from itertools import groupby
                                leafs_asn_range = string_to_list(pod.bgp["leafs_asn_range"])
                                if len(leafs_asn_range) > 1:
                                    for k,g in groupby(enumerate(leafs_asn_range),lambda x:x[0]-x[1]):
                                        group = map(itemgetter(1), g)
                                        group = list(map(int,group))
                                        dynamic_peering_peer_filter_statements.append("{}-{}".format(group[0], group[-1]))
                                else:
                                    dynamic_peering_peer_filter_statements = [ pod.bgp["leafs_asn_range"] ]

                                #Define Peer Filer
                                self.config["peer_filters"] = {
                                    pod.filters["peer_filters"]["bgp_range_accept"]["name"] : {
                                        "sequence_numbers" :{
                                        }
                                    }
                                }
                                for i, statement in enumerate(dynamic_peering_peer_filter_statements):
                                    self.config["peer_filters"][pod.filters["peer_filters"]["bgp_range_accept"]["name"]]["sequence_numbers"][(i+1)*10] = {
                                        "match": "as-range {} result accept".format(statement)
                                    }

                                #Define BGP Listen Range neighbor statement
                                if len(pod.underlay_p2p_network_summaries) > 1:
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] ]["bgp_listen_range_prefix"] = str(pod.underlay_p2p_network_summaries[ int(self.spine_number) -1 ])
                                else:
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] ]["bgp_listen_range_prefix"] = str(pod.underlay_p2p_network_summaries[ 0 ])
                                self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] ]["peer_filter"] = pod.filters["peer_filters"]["bgp_range_accept"]["name"] #Peer filter name
                            else:
                                for iface, details in self.downlink_interfaces.items():
                                    if "neighbor_ip_address" in details.keys():
                                        self.config["router_bgp"]["neighbors"][ str(details["neighbor_ip_address"]) ] = {
                                            "peer_group": pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"]
                                        }
                                        if "neighbor_asn" in details.keys():
                                            self.config["router_bgp"]["neighbors"][ str(details["neighbor_ip_address"]) ]["remote_as"] = details["neighbor_asn"]

                            # Enable IPv4 address family
                            self.config["router_bgp"]["address_family_ipv4"] = {
                                "peer_groups":{
                                    pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] :{
                                        "activate": True
                                    }
                                }
                            }

                            # If EVPN is enabled
                            if pod.bgp["evpn_enabled"] == True:
                                # Set up EVPN neighbors
                                #Get hosts from max spine/superspine number and pod.overlay_loopback_network_summary_spines/superspines
                                if pod.bgp["super_spines_asn"] is None or int(pod.bgp["super_spines_asn"]) == 0:
                                    # Set up EVPN peer groups and neighbors
                                    self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"] ] = {}
                                    for k, v in pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"].items():
                                        self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"] ][k] = v

                                    if pod.bgp["dynamic_peering"] == True:
                                        #Define BGP Listen Range neighbor statement
                                        self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"] ]["bgp_listen_range_prefix"] = str(pod.overlay_loopback_network_summary_leafs)
                                        self.config["router_bgp"]["peer_groups"][ pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"] ]["peer_filter"] = pod.filters["peer_filters"]["bgp_range_accept"]["name"] #Peer filter name
                                    else:
                                        #Add Remote ASN to peer-group
                                        for iface, details in self.downlink_interfaces.items():
                                            #Get suspected Loopback IP Address of neighbor
                                            neighbor_leaf_index = int(switches_in_dc[details["neighborHostname"]].leaf_number)
                                            if pod.overlay_loopback_network_summary_leafs == pod.overlay_loopback_network_summary_spines:
                                                neighbor_leaf_index += max_spines
                                            neighbor_loopback_ip = str( list( ipaddress.ip_network( pod.overlay_loopback_network_summary_leafs ).hosts() ) [(int(neighbor_leaf_index) - 1) ] )
                                            self.config["router_bgp"]["neighbors"][neighbor_loopback_ip] = {
                                                "peer_group": pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"]
                                            }
                                            if "neighbor_asn" in details.keys():
                                                self.config["router_bgp"]["neighbors"][ neighbor_loopback_ip ]["remote_as"] = details["neighbor_asn"]

                                #Enable EVPN address family
                                self.config["router_bgp"]["address_family_evpn"] = {
                                    "peer_groups":{
                                        pod.bgp["peer_groups"]["spine"]["EVPN_OVERLAY_PEERS"]["name"] :{
                                            "activate": True
                                        }
                                    }
                                } 
                            else:
                                for iface, details in self.downlink_interfaces.items():
                                    if "neighbor_ip_address" in details.keys():
                                        self.config["router_bgp"]["neighbors"][ str(details["neighbor_ip_address"]) ] = {
                                            "peer_group": pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"]
                                        }
                                        if "neighbor_asn" in details.keys():
                                            self.config["router_bgp"]["neighbors"][ str(details["neighbor_ip_address"]) ]["remote_as"] = details["neighbor_asn"]

                            # Enable IPv4 address family
                            self.config["router_bgp"]["address_family_ipv4"] = {
                                "peer_groups":{
                                    pod.bgp["peer_groups"]["spine"]["IPv4_UNDERLAY_PEERS"]["name"] :{
                                        "activate": True
                                    }
                                }
                            }

                            # Set up redistributed connected parameters
                            self.config["router_bgp"]["redistribute_routes"]["connected"] = {
                                "route_map": pod.filters["route_maps"]["connected_to_bgp"]["name"]
                            }
                        
                            #Set BGP Tags
                            self.set_bgp_tags()

                        def create_config_parameters(self, pod):
                            '''
                            Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template 
                            '''
                            self.set_spanning_tree(pod)
                            self.set_bgp(pod)
                            return self.config


                    class SuperSpineDetails(SwitchDetails):
                        def __init__(self):
                            super().__init__()
                            self.role = "Super-Spine"
                            self.super_spine_number = None

                        def check_tags(self):
                            tags = {
                                "dc" : {"label": "DC", "type": str},
                                "super_spine_number" : {"label": "Super-Spine-Number", "type": int}
                            }
                            for tag in tags.keys():
                                assert getattr(self, tag) is not None, "{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected".format(
                                    tags[tag]["label"], tags[tag]["label"], self.hostname
                                )
                                try:
                                    value_type = tags[tag]["type"](getattr(self, tag))
                                except ValueError:
                                    assert False, "'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}".format(
                                        tags[tag]["label"], self.hostname, getattr(self, tag), tags[tag]["type"]
                                        )

                        def get_interfaces(self):
                            '''
                            Gets and sets the physical ethernet interfaces for connections from switch
                            Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:
                            {
                                "neighborHostname": str,
                                "neighborInterface": str
                            }

                            '''
                            downlink_interfaces = {}
                            for i in my_device.getInterfaces():
                                peer_device, peer_interface = i.getPeerInfo()
                                if peer_device is not None:
                                    if switches_in_dc.get(peer_device.hostName):
                                        neighbor = switches_in_dc.get(peer_device.hostName)
                                        if neighbor.role == "Spine":
                                            downlink_interfaces[i.name] = {"neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                            self.downlink_interfaces = downlink_interfaces
                            return

                        def create_config_parameters(self, pod):
                            '''
                            Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template 
                            '''
                            ## self.set_spanning_tree(pod)
                            ## self.set_bgp(pod)
                            return self.config


                    def create_switch(role):
                        if role == "Leaf":
                            return LeafDetails()
                        elif role == "Spine":
                            return SpineDetails()
                        elif role == "Super-Spine":
                            return SuperSpineDetails()
                        else:
                            return

                    def get_switch_details(device_id):
                        labels_to_fields = {
                            "hostname": "hostname",
                            "model": "model",
                            "Role": "role",
                            "DC": "dc",
                            "DC-Pod": "dc_pod",
                            "Leaf-Number": "leaf_number",
                            "Leaf-Domain": "leaf_domain",
                            "Spine-Number": "spine_number",
                            "Super-Spine-Number": "super_spine_number"
                        }
                        switch = None
                        found_switch = False
                        #Create tagstub
                        tsclient = ctx.getApiClient(tsgr.TagSearchStub)

                        #Create TagValueSearchRequest
                        tvsr = tspb.TagValueSearchRequest(label="Role", workspace_id=workspace_id, topology_studio_request=True)
                        for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                            query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                            tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                            tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                            for match in tagmresp.matches:
                                if match.device.device_id == device_id:
                                    switch = create_switch(tag.value)
                                    found_switch = True
                                    break
                            if found_switch == True:
                                break

                        #Check to see role is set on switch
                        assert switch is not None, "Role is not set on {}.  Please apply a 'Role' tag to {} with a value of either 'Leaf', 'Spine', or 'Super-Spine' in the Tags section of Provisioning with the appropriate workspace selected".format(
                                    match.device.device_id, match.device.device_id
                                )

                        for label in labels_to_fields.keys():
                            if label == "hostname":
                                for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                                    if dev.hostName:
                                        setattr(switch, labels_to_fields[ label ], dev.hostName)
                                continue
                            if label == "model":
                                for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                                    if dev.modelName:
                                        setattr(switch, labels_to_fields[ label ], dev.modelName)
                                continue
                            tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                            for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                                try:
                                    query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                                    tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                                    tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                                except:
                                    continue
                                else:
                                    for match in tagmresp.matches:
                                        if match.device.device_id == device_id:
                                            setattr(switch, labels_to_fields[ tag.label ], tag.value)
                                            break

                        switch.id = device_id
                        #Chcek to see switch tags are set and with proper values
                        switch.check_tags()
                        return switch

                    def get_switches_in_dc(dc):
                        #list of switches we'll return
                        switches = {}

                        #Create tagstub
                        tsclient = ctx.getApiClient(tsgr.TagSearchStub)

                        #Get switches in dc
                        query= "{}:\"{}\"".format("DC", dc)
                        tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                        tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                        for match in tagmresp.matches:
                            switch = get_switch_details(match.device.device_id)
                            if switch is None:
                                continue
                            if switch.hostname not in switches:
                                switches[switch.hostname] = switch
                        return switches

                    def get_manually_allocated_leaf_asns(my_switch, switches_in_dc, studios_input_data):
                        manually_allocated_asns = {}
                        for switch, switch_object in switches_in_dc.items():
                            if switch_object.role.lower() == "leaf" and switch_object.dc_pod == my_switch.dc_pod:
                                switch_object.get_asn_from_input(studio_input_data)
                                if switch_object.config["router_bgp"].get("as") is not None:
                                    manually_allocated_asns[int(switch_object.leaf_domain)] = switch_object.config["router_bgp"]["as"]
                        return manually_allocated_asns

                    def assign_leaf_switch_asn(switch_object, my_switch, my_pod):
                        if switch_object.config["router_bgp"]["as"] is None and switch_object.role.lower() == "leaf" and switch_object.dc_pod == my_switch.dc_pod:
                            leaf_asns = string_to_list(my_pod.bgp["leafs_asn_range"])
                            if len(leaf_asns) > 1:
                                #Create list of available leaf bgp asns
                                leaf_domain_index_shift = 0
                                for leaf_domain, manually_allocated_asn in my_pod.manually_allocated_leaf_asns.items():
                                    if manually_allocated_asn in leaf_asns:
                                        leaf_asns.remove(manually_allocated_asn)
                                        if leaf_domain < int(switch_object.leaf_domain):
                                            leaf_domain_index_shift += 1
                                asn_index = int(switch_object.leaf_domain) - leaf_domain_index_shift -1
                                assert len(leaf_asns) > asn_index, "the Pod leaf ASN range must be increased for specified leaf domains"
                                switch_object.config["router_bgp"]["as"] = leaf_asns[ asn_index]
                            else:
                                switch_object.config["router_bgp"]["as"] = leaf_asns[0]
                        return switch_object

                    #Set config data model to empty
                    config = {}
                    #Get Pod Details for switch
                    my_pod = get_pod_details(studio_input_data)
                    #Get Switch Details
                    my_switch = get_switch_details(my_device_id)

                    if my_pod is not None and my_switch is not None:
                        #Get Switch Details For All Switches In This DC
                        switches_in_dc = get_switches_in_dc(my_switch.dc)

                        #Get interface details for switch
                        my_switch.get_interfaces()
                        my_switch.merge_multilane_interfaces()

                        #Get already allocated leaf asns in Pod - these will be removed from leaf asn range since they are not available for allocation - key will be leaf_domain, value will be asn
                        my_pod.manually_allocated_leaf_asns = get_manually_allocated_leaf_asns(my_switch, switches_in_dc, studio_input_data)

                        #Assign an asn to all leaf switch objects that don't already have one
                        for switch, switch_object in switches_in_dc.items():
                            if switch_object.role.lower() == "leaf":
                                switches_in_dc[switch] = assign_leaf_switch_asn(switch_object, my_switch, my_pod)

                        #Assign ASN to my_switch
                        my_switch.config["router_bgp"]["as"] = switches_in_dc[my_switch.hostname].config["router_bgp"]["as"]

                        #Switch is either a leaf or spine
                        if my_switch.role in ["Leaf", "Spine"]:
                            my_switch.create_config_parameters(my_pod)
                            config = my_switch.config
                        #Switch has no supported role
                        else:
                            config = {}
                    %>
                    % if config.get("service_routing_protocols_model") is not None and config.get("service_routing_protocols_model") == "multi-agent":
                    service routing protocols model multi-agent
                    !
                    % endif
                    ## eos - spanning-tree
                    % if config.get("spanning_tree") is not None:
                    %     if config["spanning_tree"].get("mode") is not None:
                    spanning-tree mode ${ config["spanning_tree"].get("mode") }
                    %     endif
                    %     if config["spanning_tree"].get("no_spanning_tree_vlan") is not None:
                    no spanning-tree vlan-id ${ config["spanning_tree"].get("no_spanning_tree_vlan") }
                    %     endif
                    !
                    % endif
                    ## eos - VLANs
                    %if config.get("vlans") is not None:
                    %     for vlan in natural_sort(config.get("vlans")):
                    vlan ${ vlan }
                    %          if config.get("vlans")[vlan].get("name") is not None:
                    name ${ config.get("vlans")[vlan].get("name") }
                    %          endif
                    %          if config.get("vlans")[vlan].get("state") is not None:
                    state ${ config.get("vlans")[vlan].get("state") }
                    %          endif
                    %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
                    %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
                    trunk group ${ trunk_group }
                    %               endfor
                    %          endif
                    !   
                    %    endfor %}
                    %endif
                    ## eos- Port-Channel Interfaces
                    % if config.get("port_channel_interfaces") is not None:
                    %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
                    interface ${ port_channel_interface }
                    %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
                    description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
                    %     endif
                    %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
                    shutdown
                    %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
                    no shutdown
                    %     endif
                    %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
                    mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
                    %     endif
                    %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
                    no switchport
                    %     else:
                    switchport
                    %     endif
                    %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
                    switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
                    %     endif %}
                    %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
                    switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
                    %     endif
                    %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
                    %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
                    switchport trunk group ${ trunk_group }
                    %       endfor
                    %     endif
                    !
                    %   endfor
                    % endif
                    ## eos - Ethernet Interfaces
                    %if config.get("ethernet_interfaces") is not None:
                    %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
                    interface ${ethernet_interface }
                    %     if config["ethernet_interfaces"][ethernet_interface]["description"] is not None:
                    description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
                    %     endif
                    %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
                    channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
                    %     else:
                    %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
                    mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
                    no switchport
                    %         else:
                    switchport
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
                    %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
                    switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
                    %             endif
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
                    %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
                    switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
                    %             endif
                    %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
                    switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
                    %             endif
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
                    switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
                    %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
                    switchport trunk group ${ trunk_group }
                    %             endfor
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
                    vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
                    %         endif
                    %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
                    ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
                    %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
                    %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
                    ip address ${ ip_address_secondary } secondary
                    %                 endfor
                    %             endif
                    %         endif
                    %     endif
                    !
                    %endfor
                    %endif
                    ## eos - Loopback Interfaces
                    %if config.get("loopback_interfaces") is not None:
                    %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
                    interface ${ loopback_interface }
                    %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
                    description ${ config["loopback_interfaces"][loopback_interface].get("description") }
                    %       endif
                    %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
                    shutdown
                    %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
                    no shutdown
                    %       endif
                    %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
                    vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
                    %       endif
                    %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
                    ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
                    %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
                    %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
                    ip address ${ ip_address_secondary } secondary
                    %               endfor
                    %           endif
                    %       endif
                    !
                    %   endfor
                    %endif
                    ## eos - VLAN Interfaces
                    % if config.get("vlan_interfaces") is not None:
                    %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
                    interface ${ vlan_interface }
                    %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
                    description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
                    shutdown
                    %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
                    no shutdown
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
                    mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
                    no autostate
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None:
                    vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
                    ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
                    %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
                    %             for ip_address_secondary in config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries"):
                    ip address ${ ip_address_secondary } secondary
                    %             endfor
                    %         endif
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") is not None:
                    ip virtual-router address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") }
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
                    ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
                    %     endif
                    %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
                    %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ip_helpers").keys():
                    <%        ip_helper_cli = "ip helper-address " + ip_helper %>
                    %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
                    <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
                    %         endif
                    %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
                    <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
                    %         endif %}
                    ${ ip_helper_cli }
                    %       endfor
                    %      endif
                    !
                    %   endfor
                    % endif
                    ## vxlan-interfaces
                    % if config.get("vxlan_tunnel_interface"):
                    interface Vxlan1
                    %     if config["vxlan_tunnel_interface"]["Vxlan1"].get("source_interface"):
                    vxlan source-interface ${ config["vxlan_tunnel_interface"]["Vxlan1"]["source_interface"] }
                    %     endif
                    %     if config["vxlan_tunnel_interface"]["Vxlan1"].get("virtual_router"):
                    vxlan virtual-router encapsulation mac-address ${ config["vxlan_tunnel_interface"]["Vxlan1"]["virtual_router"]["encapsulation_mac_address"] }
                    %     endif
                    %     if config["vxlan_tunnel_interface"]["Vxlan1"].get("vxlan_udp_port"):
                    vxlan udp-port ${ config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_udp_port"] }
                    %     endif
                    %     if config["vxlan_tunnel_interface"]["Vxlan1"].get("vxlan_vni_mappings"):
                    %       if config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"].get("vlans"):
                    %           for vlan in config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"]["vlans"].keys():
                    vxlan vlan ${ vlan } vni ${ config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"]["vlans"][vlan]["vni"] }
                    %           endfor
                    %       endif
                    %       if config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"].get("vrfs"):
                    %           for vrf in config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"]["vrfs"].keys():
                    vxlan vrf ${ vrf } vni ${ config["vxlan_tunnel_interface"]["Vxlan1"]["vxlan_vni_mappings"]["vrfs"][vrf]["vni"] }
                    %           endfor %}
                    %       endif
                    %     endif
                    !
                    % endif
                    ## eos - tcam profile
                    % if config.get("tcam_profile") is not None:
                    hardware tcam
                    %     if config["tcam_profile"].get("profiles") is not None:
                    %         for profile in config["tcam_profile"]["profiles"].keys():
                    profile ${ profile }
                    ${ config["tcam_profile"]["profiles"][profile] }
                    !
                    %         endfor
                    %     endif
                    %     if config["tcam_profile"].get("system") is not None:
                    system profile ${ config["tcam_profile"]["system"] }
                    %     endif
                    !
                    % endif
                    ## eos - ip virtual router mac
                    % if config.get("ip_virtual_router_mac_address") is not None:
                    ip virtual-router mac-address ${ config["ip_virtual_router_mac_address"] }
                    !
                    % endif
                    ## eos - IP Routing 
                    % if config.get("ip_routing") == True:
                    ip routing
                    !
                    % elif config.get("ip_routing") == False:
                    no ip routing
                    !
                    % endif
                    ## eos - VRFs
                    % if config.get("vrfs") is not None:
                    %   for vrf in config.get("vrfs"):
                    %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
                    ip routing vrf ${ vrf }
                    %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
                    no ip routing vrf ${ vrf }
                    %       endif
                    %   endfor
                    !
                    % endif
                    ## eos - prefix-lists
                    % if config.get("prefix_lists") is not None:
                    %    for prefix_list in config["prefix_lists"].keys():
                    ip prefix-list ${ prefix_list }
                    %       for sequence in config["prefix_lists"][prefix_list]["sequence_numbers"].keys():
                    %         if config["prefix_lists"][prefix_list]["sequence_numbers"][sequence].get("action") is not None:
                    seq ${ sequence } ${ config["prefix_lists"][prefix_list]["sequence_numbers"][sequence]["action"] }
                    %         endif
                    %       endfor
                    !
                    %    endfor
                    % endif
                    ## eos - mlag configuration
                    % if config.get("mlag_configuration") is not None and config["mlag_configuration"].get("enabled") == True:
                    mlag configuration
                    %     if config["mlag_configuration"].get("domain_id") is not None:
                    domain-id ${ config["mlag_configuration"]["domain_id"] }
                    %     endif
                    %     if config["mlag_configuration"].get("local_interface") is not None:
                    local-interface ${ config["mlag_configuration"]["local_interface"] }
                    %     endif
                    %     if config["mlag_configuration"].get("peer_address") is not None:
                    peer-address ${ config["mlag_configuration"]["peer_address"] }
                    %     endif
                    %     if config["mlag_configuration"].get("peer_address_heartbeat") is not None:
                    %       if config["mlag_configuration"]["peer_address_heartbeat"].get("peer_ip") is not None:
                    %           if config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") is not None and config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") != 'default':
                    peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] } vrf ${ config["mlag_configuration"]["peer_address_heartbeat"]["vrf"] }
                    ## using the default VRF #}
                    %           else:
                    peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] }
                    %           endif
                    %       endif
                    %     endif
                    %     if config["mlag_configuration"].get("peer_link") is not None:
                    peer-link ${ config["mlag_configuration"]["peer_link"] }
                    %     endif
                    %     if config["mlag_configuration"].get("dual_primary_detection_delay") is not None:
                    dual-primary detection delay ${ config["mlag_configuration"]["dual_primary_detection_delay"] } action errdisable all-interfaces
                    %     endif
                    %     if config["mlag_configuration"].get("reload_delay_mlag") is not None:
                    reload-delay mlag ${ config["mlag_configuration"]["reload_delay_mlag"] }
                    %     endif
                    %     if config["mlag_configuration"].get("reload_delay_non_mlag") is not None:
                    reload-delay non-mlag ${ config["mlag_configuration"]["reload_delay_non_mlag"] }
                    %     endif
                    !
                    % endif
                    ## eos - Route Maps
                    % if config.get("route_maps") is not None:
                    %   for route_map in config["route_maps"].keys():
                    %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
                    %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
                    route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
                    %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
                    description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
                    %               endif
                    %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
                    %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
                    match ${ match_rule }
                    %                   endfor
                    %               endif
                    %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
                    %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
                    set ${ set_rule }
                    %                   endfor
                    %               endif
                    !
                    %           endif
                    %       endfor
                    %   endfor
                    % endif
                    ## eos - peer-filters
                    % if config.get("peer_filters") is not None:
                    %   for peer_filter in config["peer_filters"].keys():
                    peer-filter ${ peer_filter }
                    %     for sequence in config["peer_filters"][peer_filter]["sequence_numbers"].keys():
                    %         if config["peer_filters"][peer_filter]["sequence_numbers"][sequence].get("match") is not None:
                    ${ sequence } match ${ config["peer_filters"][peer_filter]["sequence_numbers"][sequence]["match"] }
                    %         endif
                    %     endfor
                    !
                    %   endfor
                    % endif
                    ## eos - Router BGP
                    % if config.get("router_bgp") is not None:
                    % if config["router_bgp"].get("as") is not None:
                    router bgp ${ config["router_bgp"]["as"] }
                    %     if config["router_bgp"].get("router_id") is not None:
                    router-id ${ config["router_bgp"]["router_id"] }
                    %     endif
                    %     if config["router_bgp"].get("maximum_paths"):
                    <% max_paths_cli = "maximum-paths {} ".format(config["router_bgp"]["maximum_paths"]) %> 
                    %        if config["router_bgp"].get("ecmp"):
                    <% max_paths_cli += "ecmp {}".format(config["router_bgp"]["ecmp"]) %>
                            % endif
                    ${max_paths_cli}
                    %     endif
                    %     if config["router_bgp"].get("bgp_defaults") is not None:
                    %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
                    ${ bgp_default }
                    %       endfor
                    %     endif
                    %     if config["router_bgp"].get("peer_groups") is not None:
                    %       for peer_group in config["router_bgp"]["peer_groups"].keys():
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
                    bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
                    %         endif
                    %       endfor
                    %     for peer_group in config["router_bgp"]["peer_groups"].keys():
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
                    neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
                    neighbor ${ peer_group } shutdown
                    %         endif
                    neighbor ${ peer_group } peer group
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
                    neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
                    neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
                    neighbor ${ peer_group } next-hop-self
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
                    neighbor ${ peer_group } next-hop-unchanged
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
                    neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
                    neighbor ${ peer_group } route-reflector-client
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
                    neighbor ${ peer_group } bfd
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
                    neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
                    neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
                    neighbor ${ peer_group } send-community
                    %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
                    neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
                    neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
                    %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
                    neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
                    neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
                    neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
                    neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
                    %         endif
                    %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
                    neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
                    %         endif
                    %       endfor
                    %     endif
                    ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
                    ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
                    ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
                    ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
                    ## {%         endif %}
                    ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
                    ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
                    ## {%         endif %}
                    ## ##    {{ neighbor_interface_cli }}
                    ## {%     endfor %}
                    %     if config["router_bgp"].get("neighbors") is not None:
                    %       for neighbor in natural_sort(config["router_bgp"]["neighbors"].keys()):
                    %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
                    neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
                    neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]["remote_as"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
                    neighbor ${ neighbor } next-hop-self
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
                    neighbor ${ neighbor } shutdown
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
                    neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
                    neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
                    neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
                    neighbor ${ neighbor } bfd
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
                    neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
                    neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
                    neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
                    neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
                    %         endif
                    %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
                    neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
                    %         endif
                    %       endfor
                    %     endif
                    ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
                    ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
                    ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
                    ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
                    ## {%         endif %}
                    ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
                    ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
                    ## {%         endif %}
                    ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
                    ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
                    ## {%         endif %}
                    ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
                    ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
                    ## {%         endif %}
                    ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
                    ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
                    ## {%         endif %}
                    ##    {{ aggregate_address_cli }}
                    ## {%     endfor %}
                    %     if config["router_bgp"].get("redistribute_routes") is not None:
                    %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
                    <%         redistribute_route_cli = "redistribute " + redistribute_route %>
                    %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
                    <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
                    %         endif
                    ${ redistribute_route_cli }
                    %       endfor
                    %     endif
                    ## L2VPNs - (vxlan) vlan based
                    %     if config["router_bgp"].get("vlans") is not None:
                    %       for vlan in config["router_bgp"]["vlans"]:
                    !
                    vlan ${ vlan }
                    %         if config["router_bgp"]["vlans"][vlan].rd is not None:
                        rd ${ config["router_bgp"]["vlans"][vlan].rd }
                    %         endif
                    %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
                    %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                        route-target both ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
                    %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                        route-target import ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
                    %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                        route-target export ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
                    %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                        redistribute ${ redistribute_route }
                    %           endfor
                    %         endif
                    %       endfor
                    ## vxlan vlan aware bundles
                    %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
                    %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
                    !
                    vlan-aware-bundle ${ vlan_aware_bundle }
                    %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                        rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
                    %         endif
                    %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
                    %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                        route-target both ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
                    %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                        route-target import ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
                    %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                        route-target export ${ route_target }
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
                    %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                        redistribute ${ redistribute_route }
                    %           endfor %}
                    %         endif
                    %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                        vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
                    %         endif
                    %         endfor
                    %       endif
                    %     endif
                    ## address families activation
                    ## address family evpn activation ##
                    %     if config["router_bgp"].get("address_family_evpn") is not None:
                    !
                    address-family evpn
                    %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                        no host-flap detection
                    %         else:
                    %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                        host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
                    %             endif
                    %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                        host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
                    %             endif
                    %         endif
                    %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                        domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
                    %         endif
                    %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
                    %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
                    %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                        neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
                    %             endif
                    %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                        neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
                    %             endif
                    %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                        neighbor ${ peer_group } activate
                    %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                        no neighbor ${ peer_group } activate
                    %             endif
                    %           endfor
                    %         endif
                    %     endif
                    ## {# address family rt-membership activation #}
                    ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
                    ##    !
                    ##    address-family rt-membership
                    ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
                    ##       neighbor ${ peer_group } activate
                    ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
                    ##       no neighbor ${ peer_group } activate
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
                    ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
                    ##       neighbor ${ peer_group } default-route-target only
                    ## {%                 else %}
                    ##       neighbor ${ peer_group } default-route-target
                    ## {%                 endif %}
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
                    ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%     endif %}
                    ## address family ipv4 activation
                    %     if config["router_bgp"].get("address_family_ipv4") is not None:
                    !
                    address-family ipv4
                    %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
                    %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
                    %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                        network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
                    %             else:
                        network ${ network }
                    %             endif
                    %         endfor
                    %       endif
                    %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
                    %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
                    %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                        neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                        neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                        neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                        neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                        neighbor ${ peer_group } activate
                    %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                        no neighbor ${ peer_group } activate
                    %             endif
                    %           endfor
                    %       endif
                    %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
                    %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                        neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                        neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                        neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                        neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
                    <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
                    %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
                    <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
                    %                 endif
                    %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
                    <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
                    %                 endif
                        ${ neighbor_default_originate_cli }
                    %             endif
                    %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                        neighbor ${ neighbor } activate
                    %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                        no neighbor ${ neighbor } activate
                    %             endif
                    %           endfor
                    %       endif
                    %     endif
                    ## {# address family ipv4 multicast activation #}
                    ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
                    ##    !
                    ##    address-family ipv4 multicast
                    ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
                    ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
                    ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
                    ##       neighbor ${ peer_group } activate
                    ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
                    ##       no neighbor ${ peer_group } activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
                    ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
                    ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
                    ##       neighbor {{ neighbor }} activate
                    ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
                    ##       no neighbor {{ neighbor }} activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
                    ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
                    ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
                    ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
                    ## {%             endif %}
                    ##       {{ redistribute_route_cli }}
                    ## {%         endfor %}
                    ## {%     endif %}
                    ## {# address family ipv6 activation #}
                    ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
                    ##    !
                    ##    address-family ipv6
                    ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
                    ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
                    ## {%             else %}
                    ##       network {{ network }}
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
                    ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
                    ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
                    ##       neighbor ${ peer_group } activate
                    ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
                    ##       no neighbor ${ peer_group } activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
                    ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
                    ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
                    ## {%             endif %}
                    ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
                    ##       neighbor {{ neighbor }} activate
                    ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
                    ##       no neighbor {{ neighbor }} activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
                    ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
                    ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
                    ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
                    ## {%             endif %}
                    ##       {{ redistribute_route_cli }}
                    ## {%         endfor %}
                    ## {%     endif %}
                    ## {# address family vpn-ipv4 activation #}
                    ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
                    ##    !
                    ##    address-family vpn-ipv4
                    ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
                    ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
                    ## {%         endif %}
                    ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
                    ##       neighbor ${ peer_group } activate
                    ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
                    ##       no neighbor ${ peer_group } activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
                    ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
                    ##       neighbor {{ neighbor }} activate
                    ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
                    ##       no neighbor {{ neighbor }} activate
                    ## {%             endif %}
                    ## {%         endfor %}
                    ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
                    ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
                    ## {%         endif %}
                    ## {%     endif %}
                    ## L3VPNs - (vxlan) VRFs
                    %     if config["router_bgp"].get("vrfs") is not None:
                    %       for vrf in config["router_bgp"]["vrfs"].keys():
                    !
                    vrf ${ vrf }
                    %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                        rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
                    %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
                    %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                        route-target import ${ address_family } ${ route_target }
                    %                 endfor
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
                    %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
                    %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                        route-target export ${ address_family } ${ route_target }
                    %                 endfor
                    %             endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                        router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                        timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
                    %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
                    %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                        network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
                    %             else:
                        network ${ network }
                    %             endif
                    %           endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
                    %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                        neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                        neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                        neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                        neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                        neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
                    <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
                    %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
                    <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
                    %                 endif
                        ${ neighbor_ebgp_multihop_cli }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                        neighbor ${ neighbor } next-hop-self
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                        neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                        neighbor ${ neighbor } send-community
                    %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                        neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
                        neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
                    <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
                    %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
                    <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
                    %                 endif
                    %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
                    <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
                    %                 endif
                        ${ neighbor_default_originate_cli }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                        neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                        neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                        neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
                    %             endif
                    %           endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
                    %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
                    <%             redistribute_cli = "redistribute " + redistribute_route %>
                    %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
                    <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
                    %              endif
                        ${ redistribute_cli }
                    %           endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
                    %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
                    <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
                    %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
                    <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
                    <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
                    <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
                    <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
                    %             endif
                    %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
                    <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
                    %             endif
                        ${ aggregate_address_cli }
                    %           endfor
                    %         endif
                    %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
                    %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
                        !
                        address-family ${ address_family }
                    %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
                    %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                            neighbor ${ neighbor } activate
                    %                 endif
                    %             endfor
                    %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
                    <%                network_cli = "network " + network %>
                    %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
                    <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
                    %                 endif
                            ${ network_cli }
                    %             endfor
                    %           endfor
                    %         endif
                    %       endfor
                    %     endif
                    !
                    % endif
                    % endif