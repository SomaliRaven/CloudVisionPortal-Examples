- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: avd-campus-fabric
        workspace_id: ''
      display_name: AVD Campus Fabric
      description: Configure the fabric campus fabric and create VLANs at different campus buildings.
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |-
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          import time
          from collections import Counter, OrderedDict
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.services import TagServiceStub, \
              TagAssignmentServiceStub, \
              TagConfigServiceStub,\
              TagAssignmentConfigServiceStub
          from arista.tag.v2.services.gen_pb2 import TagRequest, \
              TagConfigSetRequest, \
              TagStreamRequest, \
              TagConfigStreamRequest, \
              TagAssignmentStreamRequest, \
              TagAssignmentConfigSetRequest, \
              TagAssignmentConfigStreamRequest
          from arista.tag.v2.tag_pb2 import ELEMENT_TYPE_DEVICE, \
              Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig



          campus_designs = {
                  "L2": "l2ls",
                  "L3": "l3ls",
                  "L2 VXLAN EVPN": "l2ls-vxlan-evpn",
                  "L3 VXLAN EVPN": "l3ls-vxlan-evpn",
                  "L2 VXLAN": "l2ls-vxlan",
                  "L3 VXLAN": "l3ls-vxlan"
              }

          node_type_defaults = {
              "l3ls": {
                  "spline": {
                      "default_evpn_role": None,
                      "mlag_support": False,
                      "vtep": False,
                      "connected_endpoints": False,
                      "network_services_l2": False,
                      "network_services_l3": True,
                      "underlay_router": True,
                      "uplink_type": "p2p"
                  },
                  "leaf":{
                      "default_evpn_role": None,
                      "mlag_support": True,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": True,
                      "underlay_router": True,
                      "uplink_type": "p2p"
                  },
                  "memberleaf": {
                      "default_evpn_role": None,
                      "mlag_support": False,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": False,
                      "underlay_router": False,
                      "uplink_type": "port-channel"
                  }
              },
              "l2ls": {
                  "spline": {
                      "default_evpn_role": None,
                      "mlag_support": True,
                      "vtep": False,
                      "connected_endpoints": False,
                      "network_services_l2": True,
                      "network_services_l3": True,
                      "underlay_router": True,
                      "uplink_type": "p2p"
                  },
                  "leaf":{
                      "default_evpn_role": None,
                      "mlag_support": True,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": False,
                      "underlay_router": False,
                      "uplink_type": "port-channel"
                  },
                  "memberleaf": {
                      "default_evpn_role": None,
                      "mlag_support": False,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": False,
                      "underlay_router": False,
                      "uplink_type": "port-channel"
                  }
              }
          }

          fabric_variables = {
              "bgp_peer_groups": {
                  "IPv4_UNDERLAY_PEERS": {
                      "name": "IPv4-UNDERLAY-PEERS",
                      "password": None
                  },
                  "MLAG_IPv4_UNDERLAY_PEER": {
                      "name": "MLAG-IPv4-UNDERLAY-PEER",
                      "password": None,
                  },
                  "EVPN_OVERLAY_PEERS": {
                      "name": "EVPN-OVERLAY-PEERS",
                      "password": None
                  }
              },
              "bfd_multihop": {
                  "interval": 300,
                  "min_rx": 300,
                  "multiplier": 3
              },
              "evpn_ebgp_multihop": 3,
              "evpn_hostflap_detection": {
                  "enabled": False,
                  "threshold": 5,
                  "window": 180
              },
              "interface_descriptions":{
                  "underlay_l3_ethernet_interfaces": "P2P_LINK_TO_{link['peer'].upper()}_{link['peer_interface']}",
                  "underlay_l2_ethernet_interfaces": "TO_{link['peer'].upper()}_{link['peer_interface']}",
                  "underlay_port_channel_interfaces": "{link['peer'].upper()}_Po{link.get('peer_channel_group_id')}",
                  "router_id_interface": "EVPN_Overlay_Peering",
                  "vtep_source_interface": "VTEP_VXLAN_Tunnel_Source",
                  "mlag_ethernet_interfaces": "MLAG_{mlag_peer}_{mlag_peer_interface}",
                  "mlag_port_channel_interface": "MLAG_PEER_{switch_facts['mlag_peer']}_Po{switch_facts['mlag_port_channel_id']}"
              },
              "p2p_interface_settings": []
          }

          platform_settings = {
              "jericho-fixed": {
                  "regexes": [r'DCS-7280\w(R|R2)\D*-.+', r'DCS-7048T'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": "vxlan-routing",
                  "info": "Configured in standard settings"
              },
              "jericho-chassis": {
                  "regexes": [r'DCS-75\d\d'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": "vxlan-routing",
                  "info": "Configured in standard settings"
              },
              "jericho2-fixed": {
                  "regexes": [r'DCS-7280\w(R3)\D*-.+'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              },
              "jericho2-chassis": {
                  "regexes": [r'DCS-78\d\d'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              },
              "trident3x1-fixed": {
                  "regexes": [r'CCS-720DP-24', r'CCS-720DT-24'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings",
                  "asu": {
                      "support": False,
                      "starting_eos": "0"
                  },
                  "ip_locking": {
                      "support": True,
                      "starting_eos": "4.23.0F"
                  }
              },
              "trident3x2-fixed": {
                  "regexes": [r'CCS-720DP-48', r'CCS-720DT-48', r'DCS-7050(S|T)X-\d\d'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings",
                  "asu": {
                      "support": True,
                      "starting_eos": "0"
                  },
                  "ip_locking": {
                      "support": True,
                      "starting_eos": "4.23.0F"
                  }
              },
              "trident3x3-fixed": {
                  "regexes": [r'CCS-720XP-\d\d', r'CCS-720DF-\d\d'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings",
                  "asu": {
                      "support": True,
                      "starting_eos": "0"
                  },
                  "ip_locking": {
                      "support": True,
                      "starting_eos": "4.23.0F"
                  }
              },
              "trident3x5|7-fixed": {
                  "regexes": [r'DCS-7050\wX3'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings",
                  "asu": {
                      "support": True,
                      "starting_eos": "0"
                  },
                  "ip_locking": {
                      "support": True,
                      "starting_eos": "4.23.0F"
                  }
              },
              "veos": {
                  "regexes": [r'(v|c)EOS(-)*(Lab)*'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "ip_locking": {
                      "support": True,
                      "starting_eos": "4.23.0F"
                  }
              },
              "default": {
                  "regexes": [r'.+'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              }
          }
          veos_regex = r'(v|c)EOS(-)*(Lab)*'

          ptp_profiles = [
              {
                  "profile": "aes67-r16-2016",
                  "announce": {
                      "interval": 0,
                      "timeout": 3,
                  },
                  "delay_req": -3,
                  "sync_message": {
                      "interval": -3
                  },
                  "transport": "ipv4"
              },
              {
                  "profile": "smpte2059-2",
                  "announce": {
                      "interval": -2,
                      "timeout": 3,
                  },
                  "delay_req": -4,
                  "sync_message": {
                      "interval": -4
                  },
                  "transport": "ipv4"
              },
              {
                  "profile": "aes67",
                  "announce": {
                      "interval": 2,
                      "timeout": 3,
                  },
                  "delay_req": 0,
                  "sync_message": {
                      "interval": 0
                  },
                  "transport": "ipv4"
              }
          ]


          def get_default_node_id(hostname, default_hostname_id_rules):
              """
              default_ids:
              - matchHostnames: < regex >
                  regexGroups:
                  - group: < regex_match_group - required - 0 is the first group >
                      # Type number will convert the group to integer
                      # Type letter will lowercase a single letter and take the ascii_code - 97. So a == 0
                      # An error will be raised if multiple letters are matched in the group.
                      type: number | letter - default number >
                      offset: < offset_applied_before_multiplying - default 0 >
                      multiplier: < multiplier_applied_on_value_of_group - default 1 >
                      optional: <bool - default False if not found the value 0 will be used and offset will still apply>
              """
              DEFAULT_IDS = default_hostname_id_rules
              node_id = 0
              for default_id in DEFAULT_IDS:
                  regex_match = re.match(rf"^{default_id['matchHostnames']}$", hostname)
                  if not regex_match:
                      continue
                  match_groups = regex_match.groups()
                  # Using id_group to make it easier to keep track below
                  for id_group in default_id["regexGroups"]:
                      match_group_value = match_groups[id_group["group"]]
                      if match_group_value is None:
                          # Missing group, implicit value=0 so just add offset.
                          node_id += id_group.get("offset", 0)
                          continue

                      if id_group.get("type") == "letter":
                          if not len(match_group_value) == 1:
                              raise Exception(
                                  f"Value of group {id_group['group']}: '{match_group_value}' must be a "
                                  f"single letter string for hostname {hostname} and regex "
                                  f"{default_id['matchHostnames']}"
                              )
                          value = ord(match_group_value.lower()) - 97
                      else:
                          try:
                              value = int(match_group_value)
                          except Exception as e:
                              raise Exception(
                                  f"Value of group {id_group['group']}: '{match_group_value}' could not "
                                  f"be converted to integer for hostname {hostname} and regex "
                                  f"{default_id['matchHostnames']}"
                              ) from e

                      value += id_group.get("offset", 0)
                      value *= id_group.get("multiplier", 1)
                      node_id += value

                  break

              return node_id

          def get_default_tags(hostname, default_hostname_tag_rules):
              """
              default_hostname_tag_rules:
              - matchHostnames: < regex >
                  regexGroups:
                  - group: < regex_match_group - required - 0 is the first group >
                      # Type number will convert the group to integer
                      # Type letter will lowercase a single letter and take the ascii_code - 97. So a == 0
                      # An error will be raised if multiple letters are matched in the group.
                      label: number | letter - default number >
                      value: < offset_applied_before_multiplying - default 0 >
              """
              device_tags = []
              for tag_rule in default_hostname_tag_rules:
                  regex_match = re.match(rf"^{tag_rule['matchHostnames']}$", hostname)
                  if not regex_match:
                      continue
                  match_groups = regex_match.groups()
                  # Using tag_group to make it easier to keep track below
                  for tag_group in tag_rule["regexGroups"]:
                      match_group_value = match_groups[tag_group["group"]]
                      if match_group_value is None:
                          continue
                      label = None
                      value = None
                      if tag_group.get("label", "").strip() != "":
                          label = tag_group["label"]
                      if tag_group.get("value", "").strip() != "":
                          value = tag_group["value"]
                          # Process value
                          string_groups = re.findall('\$(\d+)', value)
                          for string_group in string_groups:
                              value = value.replace(f"${string_group}", match_groups[int(string_group)])

                      # Do something with the tag
                      if label and value:
                          device_tags.append({"label": label, "value": value})

              return device_tags

          def compare_eos_versions(version1, version2):
              version1 = re.sub(r'[a-zA-Z]', "", version1)
              version2 = re.sub(r'[a-zA-Z]', "", version2)
              versions1 = [int(v) for v in version1.split(".")]
              versions2 = [int(v) for v in version2.split(".")]
              for i in range(max(len(versions1),len(versions2))):
                  v1 = versions1[i] if i < len(versions1) else 0
                  v2 = versions2[i] if i < len(versions2) else 0
                  if v1 > v2:
                      return 1
                  elif v1 <v2:
                      return -1
              return 0


          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None


          def validateIPNetwork(ip_network, network_name=None):
              '''
              Returns True for a valid ipv4 network
              Returns False for a valid ipv6 network
              Return None for a nonvalid ip network
              '''
              try:
                  return True if type(ipaddress.ip_network(ip_network)) is ipaddress.IPv4Network else False
              except ValueError as e:
                  error_message = f""
                  if network_name is not None:
                      error_message += f"Error with {network_name}: "
                  error_message += f"{e}"
                  assert False, error_message


          def extend_ip_ranges(ip_ranges):
              '''
              Args:
                  ip_ranges: list of strings that resemble ip address ranges (i.e. 192.168.0.4-192.168.0.12)
              '''
              output = []
              for ip_range in ip_ranges:
                  ip_elements = [
                      ipaddress.ip_address(element.strip()) for element in ip_range.strip().split("-")
                  ]
                  if ip_elements[0] <= ip_elements[1]:
                      ip_addresses = range(int(ip_elements[0]), int(ip_elements[1]) + 1)
                  else:
                      ip_addresses = range(int(ip_elements[0]), int(ip_elements[1]) - 1, -1)

                  output.extend([str(ipaddress.ip_address(ip)) for ip in ip_addresses])
              return output


          def convert_dicts(dictionary, primary_key="name", secondary_key=None):
              """
              The `arista.avd.convert_dicts` filter will convert a dictionary containing nested dictionaries to a list of
              dictionaries. It inserts the outer dictionary keys into each list item using the primary_key `name` (key name is
              configurable) and if there is a non-dictionary value,it inserts this value to
              secondary key (key name is configurable), if secondary key is provided.
              This filter is intended for:
              - Seemless data model migration from dictionaries to lists.
              - Improve Ansible's processing performance when dealing with large dictionaries by converting them to lists of dictionaries.
              Note: If there is a non-dictionary value with no secondary key provided, it will pass through untouched
              To use this filter:
              ```jinja
              {# convert list of dictionary with default `name:` as the primary key and None secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.name }}
              {% endfor %}
              {# convert list of dictionary with `id:` set as the primary key and `types:` set as the secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts('id','types') %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.id }}
              item secondary key is {{ example_item.types }}
              {% endfor %}
              ```
              Parameters
              ----------
              dictionary : any
                  Nested Dictionary to convert - returned untouched if not a nested dictionary and list
              primary_key : str, optional
                  Name of primary key used when inserting outer dictionary keys into items.
              secondary_key : str, optional
                  Name of secondary key used when inserting dictionary values which are list into items.
              Returns
              -------
              any
                  Returns list of dictionaries or input variable untouched if not a nested dictionary/list.
              """
              if not isinstance(dictionary, (dict, list)) or os.environ.get("AVD_DISABLE_CONVERT_DICTS"):
                  # Not a dictionary/list, return the original
                  return dictionary
              elif isinstance(dictionary, list):
                  output = []
                  for element in dictionary:
                      if not isinstance(element, dict):
                          item = {}
                          item.update({primary_key: element})
                          output.append(item)
                      elif primary_key not in element and secondary_key is not None:
                          # if element of nested dictionary is a dictionary but primary key is missing, insert primary and secondary keys.
                          for key in element:
                              output.append(
                                  {
                                      primary_key: key,
                                      secondary_key: element[key],
                                  }
                              )
                      else:
                          output.append(element)
                  return output
              else:
                  output = []
                  for key in dictionary:
                      if secondary_key is not None:
                          # Add secondary key for the values if secondary key is provided
                          item = {}
                          item.update({primary_key: key})
                          item.update({secondary_key: dictionary[key]})
                          output.append(item)
                      else:
                          if not isinstance(dictionary[key], dict):
                              # Not a nested dictionary
                              output.append({primary_key: key})
                          else:
                              # Nested dictionary
                              item = dictionary[key].copy()
                              item.update({primary_key: key})
                              output.append(item)
                  return output

          from itertools import count, groupby
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError(f"value must be of type list, got {type(list_to_compress)}")
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return ",".join("-".join(map(str, (g[0], g[-1])[: len(g)])) for g in G)


          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",") if segment.strip() != ""]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          if i not in numbers:
                              numbers.append(i)
                  else:
                      if int(segment) not in numbers:
                          numbers.append(int(segment))
              return numbers


          def convert(text):
              return int(text) if text.isdigit() else text.lower()


          def natural_sort(iterable, sort_key=None):
              if iterable is None:
                  return []

              def alphanum_key(key):
                  if sort_key is not None and isinstance(key, dict):
                      return [convert(c) for c in re.split("([0-9]+)", str(key.get(sort_key, key)))]
                  else:
                      return [convert(c) for c in re.split("([0-9]+)", str(key))]

              return sorted(iterable, key=alphanum_key)


          def range_expand(range_to_expand):
              if not (isinstance(range_to_expand, list) or isinstance(range_to_expand, str)):
                  raise TypeError(f"value must be of type list or str, got {type(range_to_expand)}")

              result = []

              # If we got a list, unpack it and run this function recursively
              if isinstance(range_to_expand, list):
                  for r in range_to_expand:
                      result.extend(range_expand(r))

              # Must be a str now
              else:
                  prefix = ""

                  # Unpack list in string
                  for one_range in range_to_expand.split(","):
                      if one_range is None:
                          continue

                      # Find prefix (if any)
                      regex = r"^(.*?)(((\d+)-)?(\d+)\/)?(((\d+)-)?(\d+)\/)?(((\d+)-)?(\d+))(\.((\d+)-)?(\d+))?"
                      # Number of groups in this regex.
                      regex_groups = 17
                      # Groups one-by-one:
                      # Group 1  (.*?)                                                                           matches prefix ex. Ethernet, Eth, Po, Port-Channel
                      # Group 2       (((\d+)-)?(\d+)\/)?                                                        matches module(s) and slash ex. 12/, 1-3/
                      # Group 3        ((\d+)-)?                                                                 matches first module and dash ex. 1-
                      # Group 4         (\d+)                                                                    matches first module ex. 1
                      # Group 5                 (\d+)                                                            matches last module ex. 12, 3
                      # Group 6                          (((\d+)-)?(\d+)\/)?                                     matches parent interface(s) and slash ex. 47/, 1-48/
                      # Group 7                           ((\d+)-)?                                              matches parent interface(s) and dash ex. 47-
                      # Group 8                            (\d+)                                                 matches first parent interface ex. 1
                      # Group 9                                    (\d+)                                         matches last parent interface ex. 47, 48
                      # Group 10                                            (((\d+)-)?(\d+))                     matches (breakout) interface(s) ex. 1, 1-4, 1-48
                      # Group 11                                             ((\d+)-)?                           matches first interfaces and dash ex. 1-, 1-
                      # Group 12                                              (\d+)                              matches first interface
                      # Group 13                                                      (\d+)                      matches last interface ex. 1, 4, 48
                      # Group 14                                                            (\.((\d+)-)?(\d+))?  matches dot and sub-interface(s) ex. .141, .12-15
                      # Group 15                                                               ((\d+)-)?         matches first sub-interface and dash ex. 12-
                      # Group 16                                                                (\d+)            matches first sub-interface ex. 12
                      # Group 17                                                                        (\d+)    matches last sub-interface ex. 141, 15
                      # Remember that the groups() object is 0-based and the group numbers above are 1-based
                      search_result = re.search(regex, one_range)
                      if search_result:
                          if len(search_result.groups()) == regex_groups:
                              groups = search_result.groups()
                              first_module = last_module = None
                              first_parent_interface = last_parent_interface = None
                              first_interface = last_interface = None
                              first_subinterface = last_subinterface = None
                              # Set prefix if found (otherwise use last set prefix)
                              if groups[0]:
                                  prefix = groups[0]
                              if groups[4]:
                                  last_module = int(groups[4])
                              if groups[3]:
                                  first_module = int(groups[3])
                              else:
                                  first_module = last_module
                              if groups[8]:
                                  last_parent_interface = int(groups[8])
                              if groups[7]:
                                  first_parent_interface = int(groups[7])
                              else:
                                  first_parent_interface = last_parent_interface
                              if groups[12]:
                                  last_interface = int(groups[12])
                              if groups[11]:
                                  first_interface = int(groups[11])
                              else:
                                  first_interface = last_interface
                              if groups[16]:
                                  last_subinterface = int(groups[16])
                              if groups[15]:
                                  first_subinterface = int(groups[15])
                              else:
                                  first_subinterface = last_subinterface

                              def expand_subinterfaces(interface_string):
                                  result = []
                                  if last_subinterface:
                                      for subinterface in range(first_subinterface, last_subinterface + 1):
                                          result.append(f"{interface_string}.{subinterface}")
                                  else:
                                      result.append(interface_string)
                                  return result

                              def expand_interfaces(interface_string):
                                  result = []
                                  for interface in range(first_interface, last_interface + 1):
                                      for res in expand_subinterfaces(f"{interface_string}{interface}"):
                                          result.append(res)
                                  return result

                              def expand_parent_interfaces(interface_string):
                                  result = []
                                  if last_parent_interface:
                                      for parent_interface in range(first_parent_interface, last_parent_interface + 1):
                                          for res in expand_interfaces(f"{interface_string}{parent_interface}/"):
                                              result.append(res)
                                  else:
                                      for res in expand_interfaces(f"{interface_string}"):
                                          result.append(res)
                                  return result

                              def expand_module(interface_string):
                                  result = []
                                  if last_module:
                                      for module in range(first_module, last_module + 1):
                                          for res in expand_parent_interfaces(f"{interface_string}{module}/"):
                                              result.append(res)
                                  else:
                                      for res in expand_parent_interfaces(f"{interface_string}"):
                                          result.append(res)
                                  return result

                              result.extend(expand_module(prefix))

                          else:
                              raise IndexError(f"Invalid range, got {one_range} and found {search_result.groups()}")

              return result


          def default(*values):
              """
              Accepts any number of arguments. Return the first value which is not None
              Last resort is to return None.
              Parameters
              ----------
              *values : any
                  One or more values to test
              Returns
              -------
              any
                  First value which is not None
              """

              for value in values:
                  if value is not None:
                      return value
              return None


          def get(dictionary, key, default=None, required=False, org_key=None, separator="."):
              """
              Get a value from a dictionary or nested dictionaries.
              Key supports dot-notation like "foo.bar" to do deeper lookups.
              Returns the supplied default value or None if the key is not found and required is False.
              Parameters
              ----------
              dictionary : dict
                  Dictionary to get key from
              key : str
                  Dictionary Key - supporting dot-notation for nested dictionaries
              default : any
                  Default value returned if the key is not found
              required : bool
                  Fail if the key is not found
              org_key : str
                  Internal variable used for raising exception with the full key name even when called recursively
              separator: str
                  String to use as the separator parameter in the split function. Useful in cases when the key
                  can contain variables with "." inside (e.g. hostnames)
              Returns
              -------
              any
                  Value or default value
              Raises
              ------
              AristaAvdMissingVariableError
                  If the key is not found and required == True
              """

              if org_key is None:
                  org_key = key
              keys = str(key).split(separator)
              value = dictionary.get(keys[0])
              if value is None:
                  if required is True:
                      raise TypeError(org_key)
                  return default
              else:
                  if len(keys) > 1:
                      return get(value, separator.join(keys[1:]), default=default, required=required, org_key=org_key, separator=separator)
                  else:
                      return value


          def get_all(data, path: str, required: bool = False, org_path=None):
              """
              Get all values from data matching a data path.
              Path supports dot-notation like "foo.bar" to do deeper lookups. Lists will be unpacked recursively.
              Returns an empty list if the path is not found and required is False.
              Parameters
              ----------
              data : any
                  Data to walk through
              path : str
                  Data Path - supporting dot-notation for nested dictionaries/lists
              required : bool
                  Fail if the path is not found
              org_path : str
                  Internal variable used for raising exception with the full path even when called recursively
              Returns
              -------
              list [ any ]
                  List of values matching data path or empty list if no matches are found.
              Raises
              ------
              AristaAvdMissingVariableError
                  If the path is not found and required == True
              """

              if org_path is None:
                  org_path = path

              path_elements = str(path).split(".")
              if isinstance(data, list):
                  output = []
                  for data_item in data:
                      output.extend(get_all(data_item, path, required=required, org_path=org_path))

                  return output

              elif isinstance(data, dict):
                  value = data.get(path_elements[0])

                  if value is None:
                      if required:
                          raise TypeError(org_path)

                      return []

                  if len(path_elements) > 1:
                      return get_all(value, ".".join(path_elements[1:]), required=required, org_path=org_path)

                  else:
                      return [value]

              return []


          def get_item(list_of_dicts: list, key, value, default=None, required=False, case_sensitive=False, var_name=None):
              """
              Get one dictionary from a list of dictionaries by matching the given key and value
              Returns the supplied default value or None if there is no match and "required" is False.
              Will return the first matching item if there are multiple matching items.
              Parameters
              ----------
              list_of_dicts : list(dict)
                  List of Dictionaries to get list item from
              key : any
                  Dictionary Key to match on
              value : any
                  Value that must match
              default : any
                  Default value returned if the key and value is not found
              required : bool
                  Fail if there is no match
              case_sensitive : bool
                  If the search value is a string, the comparison will ignore case by default
              var_name : str
                  String used for raising exception with the full variable name
              Returns
              -------
              any
                  Dict or default value
              Raises
              ------
              AristaAvdMissingVariableError
                  If the key and value is not found and "required" == True
              """

              if var_name is None:
                  var_name = key

              if (not isinstance(list_of_dicts, list)) or list_of_dicts == [] or value is None or key is None:
                  if required is True:
                      raise KeyError(var_name)
                  return default

              for list_item in list_of_dicts:
                  if not isinstance(list_item, dict):
                      # List item is not a dict as required. Skip this item
                      continue
                  if list_item.get(key) == value:
                      # Match. Return this item
                      return list_item

              # No Match
              if required is True:
                  raise KeyError(var_name)
              return default


          def strip_null_from_data(data, strip_values_tuple=(None,)):
              """
              strip_null_from_data Generic function to strip null entries regardless type of variable.
              Parameters
              ----------
              data : Any
                  Data to look for null content to strip out
              Returns
              -------
              Any
                  Cleaned data with no null.
              """
              if isinstance(data, dict):
                  return strip_empties_from_dict(data, strip_values_tuple)
              elif isinstance(data, list):
                  return strip_empties_from_list(data, strip_values_tuple)
              return data


          def strip_empties_from_list(
              data,
              strip_values_tuple=(
                  None,
                  "",
                  [],
                  {},
              ),
          ):
              """
              strip_empties_from_list Remove entries with null value from a list
              Parameters
              ----------
              data : Any
                  data to filter
              strip_values_tuple : tuple, optional
                  Value to remove from data, by default (None, "", [], {},)
              Returns
              -------
              Any
                  Cleaned list with no strip_values_tuple
              """
              new_data = []
              for v in data:
                  if isinstance(v, dict):
                      v = strip_empties_from_dict(v, strip_values_tuple)
                  elif isinstance(v, list):
                      v = strip_empties_from_list(v, strip_values_tuple)
                  if v not in strip_values_tuple:
                      new_data.append(v)
              return new_data


          def strip_empties_from_dict(
              data,
              strip_values_tuple=(
                  None,
                  "",
                  [],
                  {},
              ),
          ):
              """
              strip_empties_from_dict Remove entries with null value from a dict
              Parameters
              ----------
              data : Any
                  data to filter
              strip_values_tuple : tuple, optional
                  Value to remove from data, by default (None, "", [], {},)
              Returns
              -------
              Any
                  Cleaned dict with no strip_values_tuple
              """
              new_data = {}
              for k, v in data.items():
                  if isinstance(v, dict):
                      v = strip_empties_from_dict(v, strip_values_tuple)
                  elif isinstance(v, list):
                      v = strip_empties_from_list(v, strip_values_tuple)
                  if v not in strip_values_tuple:
                      new_data[k] = v
              return new_data


          def get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=True):
              '''
              Returns all tags applied to a device that match the label of the input tag_assignment_key

              Args:
                  tag_assignment_key: TagAssignmentKey object with the label field set
              '''
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              # Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              # Create TagValueSearchRequest
              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
                  tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags

          def __get_devices_matching_tag_query(query):
              # Now try to search with this query to get the matching devices
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              search_req = tspb.TagMatchRequestV2(query=query, workspace_id=ctx.studio.workspaceId)
              search_res = tsclient.GetTagMatchesV2(search_req)
              return [match.device.device_id for match in search_res.matches] or query

          def get_tag_value(device_id=None, label=None, workspace_id=None, topology_studio_request=True):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=topology_studio_request, get_one=True)
              if len(tag_values) > 0:
                  return tag_values[0].value


          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [ tag_value.value for tag_value in tag_values ]


          def get_tag_for_device_by_label(device_id, workspace_id, tag_label):
              result = {}
              defaultValues = []
              workspaceValues = []

              tagClient = ctx.getApiClient(TagAssignmentServiceStub)
              get_all_req = TagAssignmentStreamRequest()
              tag_filter = TagAssignment()
              tag_filter.key.element_type = ELEMENT_TYPE_DEVICE
              tag_filter.key.device_id.value = device_id
              tag_filter.key.label.value = tag_label
              tag_filter.key.workspace_id.value = ""

              get_all_req.partial_eq_filter.append(tag_filter)
              tag_filter.key.workspace_id.value = workspace_id
              get_all_req.partial_eq_filter.append(tag_filter)
              for resp in tagClient.GetAll(get_all_req):
                  if resp.value.key.workspace_id.value:
                      workspaceValues.append(resp.value.key.value.value)
                  else:
                      defaultValues.append(resp.value.key.value.value)

              if len(workspaceValues):
                  result[tag_label] = workspaceValues
              elif len(defaultValues):
                  result[tag_label] = defaultValues

              return result



          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          # returns dictionary of device to label value based on workspace tag assignments
          def populate_single_value_dict(workspace_id, label):
              sv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      sv_dict[match.device.device_id] = tag.value
              return sv_dict


          # returns dictionary of device to label values based on workspace tag assignments
          def populate_multi_value_dict(workspace_id, label):
              mv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      mv_dict.setdefault(match.device.device_id, []).append(tag.value)
              return mv_dict


          def get_mlag_peer_by_tags(switch_facts):
              potential_roles = {"spline": "Spline", "leaf": "Leaf", "memberleaf": "Member-Leaf"}
              mlag_peer_switch_facts = None
              device_id = switch_facts["serial_number"]
              role = potential_roles.get(switch_facts["type"])
              campus = switch_facts["campus"]
              building = switch_facts["building"]
              if role is None:
                  return
              query = f'NOT device:{device_id} AND Role:{role} AND NOT Role:Member-Leaf AND Campus:"{campus}" AND Building:"{building}"'
              if switch_facts["type"] == "leaf":
                  query += f' Campus-Pod:"{switch_facts["group"]}"'

              potential_mlag_peer_sns = __get_devices_matching_tag_query(query)
              if type(potential_mlag_peer_sns) == list:
                  if len(potential_mlag_peer_sns) > 1:
                      ctx.warning(f"Detected multiple MLAG peers for {switch_facts['hostname']}: {potential_mlag_peer_sns}")
                  if len(potential_mlag_peer_sns) > 0:
                      mlag_peer_switch_facts = my_switch_facts_neighbors.get(potential_mlag_peer_sns[0])

              return mlag_peer_switch_facts


          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_peer_subnet_mask, mlag_role):
              validateIPNetwork(mlag_peer_ipv4_pool, network_name=f"MLAG Peering Pool for {switch_facts['type']}s in {switch_facts['campus']} -> {switch_facts['building']}")
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_peer_subnet_mask, "MLAG Subnet mask length must be longer than the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_peer_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_peer_subnet_mask))[int(switch_facts["mlag_primary_id"]) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return


          def get_router_id(switch_facts):
              validateIPNetwork(switch_facts["loopback_ipv4_pool"], network_name=f"Router ID Pool for {switch_facts['type']}s in {switch_facts['campus']} -> {switch_facts['building']}")
              router_id_subnet = switch_facts["loopback_ipv4_pool"]
              switch_id = switch_facts["id"]
              offset = switch_facts["loopback_ipv4_offset"]
              return list(ipaddress.ip_network(router_id_subnet).hosts())[(switch_id - 1) + offset]


          def get_vtep_loopback(switch_facts, offset=None):
              if switch_facts["type"] == "spline" or offset is None:
                  offset = 0
              validateIPNetwork(switch_facts["vtep_loopback_ipv4_pool"], network_name=f"VTEP Source Address Pool for {switch_facts['type']}s in {switch_facts['campus']} -> {switch_facts['building']}")
              vtep_loopback_subnet = switch_facts["vtep_loopback_ipv4_pool"]
              if switch_facts.get("mlag_primary_id"):
                  switch_id = switch_facts["mlag_primary_id"] - 1 + offset
              else:
                  switch_id = switch_facts["id"] - 1 + offset
              return list(ipaddress.ip_network(vtep_loopback_subnet).hosts())[switch_id]


          def get_inband_management_ip(switch_facts):
              validateIPNetwork(switch_facts["inband_management_subnet"], network_name=f"Inband Management Pool in {switch_facts['campus']} -> {switch_facts['building']}")
              # Use same virtual ip, primary mlag switch ip, and secondary mlag switch ip on all gateways
              if switch_facts["campus_type"] == "l2ls":
                  if switch_facts["type"] == "spline":
                      if switch_facts.get("mlag_role", "") == "secondary":
                          # Return inband management subnet network address + 2
                          list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[2]
                      else:
                          # Return inband management subnet network address + 1
                          return list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[1]
                  else:
                      if switch_facts.get("inband_management_ip_range", "").strip() != "":
                          # get switches in same pod
                          leaf_switches_in_pod = natural_sort([tmp_switch_facts for tmp_switch_facts in my_switch_facts_neighbors.values() if tmp_switch_facts['group'] == switch_facts['group'] and tmp_switch_facts['type'] == 'leaf'], sort_key="id")
                          memberleaf_switches_in_pod = natural_sort([tmp_switch_facts for tmp_switch_facts in my_switch_facts_neighbors.values() if tmp_switch_facts['group'] == switch_facts['group'] and tmp_switch_facts['type'] == 'memberleaf'], sort_key="id")
                          switches_in_pod = leaf_switches_in_pod + memberleaf_switches_in_pod
                          ip_ranges = switch_facts["inband_management_ip_range"].split(",")
                          ip_address_pool = extend_ip_ranges(ip_ranges)
                          for i, tmp_switch_facts in enumerate(switches_in_pod):
                              if tmp_switch_facts['serial_number'] == switch_facts['serial_number']:
                                  index = i
                                  break

                          return ip_address_pool[index]
              return


          def get_p2p_uplinks_ip(switch_facts, uplink_switch_facts, uplink_switch_index):
              if switch_facts.get('type') not in ["leaf", "spline"] or \
                      switch_facts['uplink_ipv4_pool'] is None or \
                      switch_facts['uplink_ipv4_subnet_mask'] is None:
                  return
              uplink_ipv4_pool = switch_facts['uplink_ipv4_pool'].split(",")
              uplink_subnet_mask = switch_facts['uplink_ipv4_subnet_mask']
              uplink_offset = switch_facts['uplink_offset'] if switch_facts.get('uplink_offset') else 0
              switch_id = switch_facts['id']
              uplink_switch_id = uplink_switch_facts['id']

              previous_switches_seen = switch_facts['uplink_switches_ids'][:uplink_switch_index]
              # ctx.info(f"Previous Switches Seen: {previous_switches_seen}")
              number_of_times_uplink_switch_has_been_seen = previous_switches_seen.count(uplink_switch_facts['serial_number'])
              # ctx.info(f"Number of times previously seen {uplink_switch_facts['serial_number']}: {number_of_times_uplink_switch_has_been_seen}")

              max_uplink_switches = 2  # switch_facts['max_uplink_switches']
              max_parallel_uplinks = 2  # switch_facts['max_parallel_uplinks']

              if len(uplink_ipv4_pool) > 1:
                  uplink_ipv4_pool = uplink_ipv4_pool[uplink_switch_id - 1]
                  uplink_switch_id = 1
                  max_uplink_switches = 1
              else:
                  uplink_ipv4_pool = uplink_ipv4_pool[0]

              validateIPNetwork(uplink_ipv4_pool, network_name=f"Uplink IP Pool for {switch_facts['type']}s in {switch_facts['campus']} -> {switch_facts['building']}")
              # Valid subnet checks
              child_subnets = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask))
              # max_leafs_possible = (len(child_subnets) - uplink_offset) / \
              #         (max_uplink_switches * max_parallel_uplinks)
              # assert len(child_subnets) - uplink_offset > max_leafs_possible,\
              #         f"Not enough subnets in uplink pool {uplink_ipv4_pool} to allocate addresses for more than " \
              #         f"{int(max_leafs_possible)} leafs with {max_parallel_uplinks} parallel uplinks"

              child_subnet = child_subnets[((switch_id - 1) * max_uplink_switches * max_parallel_uplinks)  # This should provide starting index for potential uplink /31s for this switch
                                          + ((uplink_switch_id - 1) * max_parallel_uplinks + number_of_times_uplink_switch_has_been_seen)   # This should provide uplink switch index within above /31s
                                          + uplink_offset]  # This accounts for any offset from other uplink switch layers
              return list(child_subnet.hosts())[0]


          def get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts, uplink_switch_index):
              if switch_facts.get('type') not in ["leaf", "spline"] or \
                      switch_facts['uplink_ipv4_pool'] is None or \
                      switch_facts['uplink_ipv4_subnet_mask'] is None:
                  return
              uplink_ipv4_pool = switch_facts['uplink_ipv4_pool'].split(",")
              uplink_subnet_mask = switch_facts['uplink_ipv4_subnet_mask']
              uplink_offset = switch_facts['uplink_offset'] if switch_facts.get('uplink_offset') else 0
              switch_id = switch_facts['id']
              uplink_switch_id = uplink_switch_facts['id']

              previous_switches_seen = switch_facts['uplink_switches_ids'][:uplink_switch_index]
              # ctx.info(f"Previous Switches Seen: {previous_switches_seen}")
              number_of_times_uplink_switch_has_been_seen = previous_switches_seen.count(uplink_switch_facts['serial_number'])
              # ctx.info(f"Number of times previously seen {uplink_switch_facts['serial_number']}: {number_of_times_uplink_switch_has_been_seen}")

              max_uplink_switches = 2  # switch_facts['max_uplink_switches']
              max_parallel_uplinks = 2  # switch_facts['max_parallel_uplinks']

              if len(uplink_ipv4_pool) > 1:
                  uplink_ipv4_pool = uplink_ipv4_pool[uplink_switch_id - 1]
                  uplink_switch_id = 1
                  max_uplink_switches = 1
              else:
                  uplink_ipv4_pool = uplink_ipv4_pool[0]

              validateIPNetwork(uplink_ipv4_pool, network_name=f"Uplink IP Pool for {switch_facts['type']}s in {switch_facts['campus']} -> {switch_facts['building']}")
              # Valid subnet checks
              child_subnets = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask))
              # max_leafs_possible = (len(child_subnets) - uplink_offset) / \
              #         (max_uplink_switches * max_parallel_uplinks)
              # assert len(child_subnets) - uplink_offset > max_leafs_possible,\
              #         f"Not enough subnets in uplink pool {uplink_ipv4_pool} to allocate addresses for more than " \
              #         f"{int(max_leafs_possible)} leafs with {max_parallel_uplinks} parallel uplinks"

              child_subnet = child_subnets[((switch_id - 1) * max_uplink_switches * max_parallel_uplinks)  # This should provide starting index for potential uplink /31s for this switch
                                          + ((uplink_switch_id - 1) * max_parallel_uplinks + number_of_times_uplink_switch_has_been_seen)   # This should provide uplink switch index within above /31s
                                          + uplink_offset]  # This accounts for any offset from other uplink switch layers
              return list(child_subnet.hosts())[1]



          def set_switch_facts_properties(device_id, campus_resolver, default_hostname_id_rules, default_interfaces_group, default_hostname_tag_rules):
              # Initialize switch_facts
              switch_facts = {}
              switch_facts = {"serial_number": device_id}

              # Get facts from tags
              switch_facts["hostname"] = [ dev.hostName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]

              switch_facts["platform"] = [ dev.modelName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]

              eos_version = get_tag_for_device_by_label(device_id, workspace_id, "eos").get("eos", [])
              if len(eos_version) > 0:
                  switch_facts["eos_version"] = eos_version[0]
              else:
                  switch_facts["eos_version"] = "0"

              switch_facts["campus"] = campus_dict.get(device_id)

              switch_facts["building"] = building_dict.get(device_id)

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              campus_details = None
              if campus_resolved:
                  campus_details = campus_resolved.get('campusDetails', None)
              if campus_details is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return

              building_resolved = campus_details["building"].resolve(device=device_id)
              building_details = None
              if building_resolved:
                  building_details = building_resolved.get('buildingFacts', None)
              if building_details is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return

              # Get device tags from defaults
              # device_tags = get_default_tags(switch_facts['hostname'], default_hostname_tag_rules)
              # ctx.info(f"Device Tags: {device_tags}")

              # Set node id
              # Set node id based on NodeId mini-tagger values
              node_id = node_id_dict.get(device_id, 0)
              if node_id == 0:
                  # Attempt to get node_id from defaults
                  try:
                      node_id = get_default_node_id(switch_facts["hostname"], default_hostname_id_rules)
                  except Exception as e:
                      node_id = 0
                      ctx.error(f"Error retrieving node id from hostname for {switch_facts['hostname']}: {e}")
                      return

              if node_id == 0:
                  ctx.warning(f"No NodeId tag set for {switch_facts['hostname']}")
                  return

              switch_facts['id'] = int(node_id)

              # Set switch node type
              switch_facts["type"] = None
              potential_roles = {"Spline": "spline", "Leaf": "leaf", "Member-Leaf": "memberleaf"}
              roles_applied_to_switch = role_dict.get(device_id)
              # If no role is applied to switch, switch should not be in fabric build
              if roles_applied_to_switch is None:
                  ctx.warning(f"No Role tag set for {switch_facts['hostname']}")
                  return

              # Check to see that a device isn't assigned multiple roles within the campus fabric
              roles_intersect = [role for role in roles_applied_to_switch if role in list(potential_roles.keys())]
              assert len(roles_intersect) <= 1, f"Only 1 campus role should be applied to the switch. " \
                                                f"Detected the following roles applied to {switch_facts['hostname']}: {roles_intersect}"

              # Set node type
              if roles_applied_to_switch is not None:
                  for role in potential_roles.keys():
                      if role in roles_applied_to_switch:
                          switch_facts["type"] = potential_roles[role]
                          break

              if switch_facts["type"] is None:
                  ctx.warning(f"No Role tag set for {switch_facts['hostname']}")
                  return

              # Set campus type
              switch_facts["campus_type"] = campus_designs[building_details["campusType"]]

              # Get custom node properties
              custom_node_properties = {
                  "connected_endpoints": None,
                  "default_evpn_role": None,
                  "mlag_support": None,
                  "vtep": None,
                  "network_services_l2": None,
                  "network_services_l3": None
              }
              if switch_facts["type"] == "spline":
                  spline_defaults = building_details['nodeTypeProperties']['defaultSplineProperties']
                   # Set custom EVPN role
                  if spline_defaults.get('splineEvpnRoleDefault', '').strip() != "":
                      custom_node_properties['default_evpn_role'] = True if spline_defaults['splineEvpnRoleDefault'] == "Yes" else False
                  # Set custom MLAG support role
                  if spline_defaults.get('splineMlagSupportDefault', '').strip() != "":
                      custom_node_properties['mlag_support'] = True if spline_defaults['splineMlagSupportDefault'] == "Yes" else False
                  # Set custom Vtep role
                  if spline_defaults.get('splineVtepDefault', '').strip() != "":
                      custom_node_properties['vtep'] = True if spline_defaults['splineVtepDefault'] == "Yes" else False
                  # Set custom Connnected Endpoints role
                  if spline_defaults.get('splineConnectedEndpointsDefault', '').strip() != "":
                      custom_node_properties['connected_endpoints'] = True if spline_defaults['splineConnectedEndpointsDefault'] == "Yes" else False
                  # Set custom L2 Network Services role
                  if spline_defaults.get('splineL2NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l2'] = True if spline_defaults['splineL2NetworkServicesDefault'] == "Yes" else False
                  # Set custom L3 Network Services role
                  if spline_defaults.get('splineL3NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l3'] = True if spline_defaults['splineL3NetworkServicesDefault'] == "Yes" else False

              elif switch_facts["type"] == "leaf":
                  leaf_defaults = building_details['nodeTypeProperties']['defaultLeafProperties']
                   # Set custom EVPN role
                  if leaf_defaults.get('leafEvpnRoleDefault', '').strip() != "":
                      custom_node_properties['default_evpn_role'] = True if leaf_defaults['leafEvpnRoleDefault'] == "Yes" else False
                  # Set custom MLAG support role
                  if leaf_defaults.get('leafMlagSupportDefault', '').strip() != "":
                      custom_node_properties['mlag_support'] = True if leaf_defaults['leafMlagSupportDefault'] == "Yes" else False
                  # Set custom Vtep role
                  if leaf_defaults.get('leafVtepDefault', '').strip() != "":
                      custom_node_properties['vtep'] = True if leaf_defaults['leafVtepDefault'] == "Yes" else False
                  # Set custom Connnected Endpoints role
                  if leaf_defaults.get('leafConnectedEndpointsDefault', '').strip() != "":
                      custom_node_properties['connected_endpoints'] = True if leaf_defaults['leafConnectedEndpointsDefault'] == "Yes" else False
                  # Set custom L2 Network Services role
                  if leaf_defaults.get('leafL2NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l2'] = True if leaf_defaults['leafL2NetworkServicesDefault'] == "Yes" else False
                  # Set custom L3 Network Services role
                  if leaf_defaults.get('leafL3NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l3'] = True if leaf_defaults['leafL3NetworkServicesDefault'] == "Yes" else False

              # Set node properties
              switch_facts["connected_endpoints"] = default(custom_node_properties.get("connected_endpoints"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["connected_endpoints"])
              switch_facts["default_evpn_role"] = default(custom_node_properties.get("default_evpn_role"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["default_evpn_role"])
              switch_facts["mlag_support"] = default(custom_node_properties.get("mlag_support"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["mlag_support"])
              switch_facts["network_services_l2"] = default(custom_node_properties.get("network_services_l2"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["network_services_l2"])
              switch_facts["network_services_l3"] = default(custom_node_properties.get("network_services_l3"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["network_services_l3"])
              switch_facts["underlay_router"] = default(custom_node_properties.get("underlay_router"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["underlay_router"])
              switch_facts["uplink_type"] = default(custom_node_properties.get("uplink_type"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["uplink_type"])
              switch_facts["vtep"] = default(custom_node_properties.get('vtep'), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["vtep"])
              # switch_facts["ip_addressing"] =
              # switch_facts["interface_descriptions"] =

              # Set group
              if switch_facts["type"] == "spline":
                  switch_facts["group"] = "{}_{}_Splines".format(switch_facts["campus"], switch_facts["building"])
              else:
                  switch_facts['group'] = campus_pod_dict.get(device_id)
                  if switch_facts['group'] is None:
                      ctx.warning(f"{switch_facts['hostname']} does not have a Campus-Pod tag applied.")
                      return
                  if building_details["campusPods"].resolve(device=device_id).get('campusPodFacts', None) is None:
                      ctx.warning(f"No input resolver found for {switch_facts['group']}.")
                      return

              # Process topology interfaces
              switch_facts["interfaces"] = get_device_interfaces(switch_facts)

              # Set platform settings
              if switch_facts.get('platform_settings') is None:
                  for platform, settings in platform_settings.items():
                      # Skip default as this will be applied at the end
                      # to any switch that doesn't match any other platform
                      if platform == "default":
                          continue
                      # check to see if any default platform regex is matched
                      for regex in settings['regexes']:
                          if re.search(regex, switch_facts['platform'], re.IGNORECASE):
                              switch_facts['platform_settings'] = settings

              # If no platform setting is matched, set to default
              if switch_facts.get('platform_settings') is None:
                  switch_facts['platform_settings'] = platform_settings['default']

              return switch_facts


          def set_switch_facts_properties_for_query(query, campus_resolver, default_hostname_id_rules, default_interfaces_group, default_hostname_tag_rules):
              # Dictionary of switches that will be returned
              all_switch_facts = {}

              #Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              #Get switches in same Campus
              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
              for match in tagmresp.matches:
                  switch_facts_from_query = set_switch_facts_properties(match.device.device_id, campus_resolver, default_hostname_id_rules, default_interfaces_group, default_hostname_tag_rules)
                  if switch_facts_from_query is None:
                      continue
                  if match.device.device_id not in all_switch_facts:
                      all_switch_facts[match.device.device_id] = switch_facts_from_query
              return all_switch_facts


          def set_switch_facts(switch_facts, campus_resolver):
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return
              campus_details = campus_resolved["campusDetails"]
              building_resolved = campus_details["building"].resolve(device=device_id)
              if building_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return
              building_details = building_resolved["buildingFacts"]
              campus_pod_details = building_details["campusPods"].resolve(device=device_id)
              if campus_pod_details:
                  campus_pod_details = campus_pod_details["campusPodFacts"]

              # Get fabric details
              if switch_facts["underlay_router"] == True:
                  switch_facts["underlay_routing_protocol"] = building_details["buildingRoutingProtocols"]["buildingUnderlayRoutingProtocol"].lower()
                  if building_details["buildingRoutingProtocols"].get("buildingOverlayRoutingProtocol"):
                      switch_facts["overlay_routing_protocol"] = building_details["buildingRoutingProtocols"]["buildingOverlayRoutingProtocol"].lower()
                  else:
                      switch_facts["overlay_routing_protocol"] = ""

              # Get node defaults from user inputs
              if switch_facts["type"] == "spline":
                  node_defaults = building_details["splineDefaults"]
              else:
                  node_defaults = building_details["campusPodDefaults"]

              # Logs
              # if switch_facts["hostname"] == my_switch_facts["hostname"]:
              #     ctx.info(f"{switch_facts['hostname']}")
              #     ctx.info(f"Building Details: {building_details}")
              #     ctx.info(f"Node Defaults: {node_defaults}")

              # Get spanning tree details
              if switch_facts["network_services_l2"]:
                  switch_facts["spanning_tree_mode"] = node_defaults["spanningTreeDetails"].get("spanningTreeMode", "").lower()
                  if switch_facts["type"] == "spline":
                      if switch_facts["campus_type"] == "l2ls":
                          switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority") if node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority") is not None else 4096
                      else:
                          switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority")
                  elif switch_facts["type"] == "leaf":
                      switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("leafSpanningTreePriority")
                  elif switch_facts["type"] == "memberleaf":
                      switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("memberLeafSpanningTreePriority")

                  if switch_facts["spanning_tree_mode"] == "mstp":
                      if len(building_details["advancedFabricConfigurations"].get("mstInstances", [])) > 0:
                          switch_facts["mst_instances"] = {}
                          for instance in building_details["advancedFabricConfigurations"]["mstInstances"]:
                              # vlans
                              if instance.get("mstInstanceVlans", "").strip() != "":
                                  vlans = list_compress(string_to_list(instance["mstInstanceVlans"]))
                                  switch_facts["mst_instances"][instance["mstInstanceId"]] = {"vlans": vlans}
                                  # priority
                                  if switch_facts["type"] == "spline":
                                      spanning_tree_priority = instance.get("mstInstanceSplineStpPriority")
                                  elif switch_facts["type"] == "leaf":
                                      spanning_tree_priority = instance.get("mstInstanceLeafStpPriority")
                                  else:  # switch_facts["type"] == "memberleaf"
                                      spanning_tree_priority = instance.get("mstInstanceMemberLeafStpPriority")

                                  switch_facts["mst_instances"][instance["mstInstanceId"]]["spanning_tree_priority"] = spanning_tree_priority if spanning_tree_priority is not None else switch_facts["spanning_tree_priority"]

              # Get uplink interfaces
              if switch_facts["type"] == "leaf":
                  switch_facts["uplink_interface_speed"] = node_defaults["uplinkInterfaceDetails"].get("leafUplinkInterfacesSpeed")
                  switch_facts["uplink_interface_cli"] = node_defaults["uplinkInterfaceDetails"].get("leafUplinksEosCli", [])
              elif switch_facts["type"] == "memberleaf":
                  switch_facts["uplink_interface_speed"] = node_defaults["uplinkInterfaceDetails"].get("memberLeafUplinkInterfacesSpeed")
                  switch_facts["uplink_interface_cli"] = node_defaults["uplinkInterfaceDetails"].get("memberLeafUplinksEosCli", [])
              else:
                  switch_facts["uplink_interface_speed"] = None
                  switch_facts["uplink_interface_cli"] = []

              # virtual router mac
              if switch_facts["network_services_l2"] and switch_facts["network_services_l3"]:
                  switch_facts["virtual_router_mac_address"] = node_defaults["mlagDetails"]["virtualRouterMacAddress"]

              # Get router related facts
              if switch_facts["underlay_router"] == True and node_defaults.get("routerIdPool") is not None:
                  switch_facts["loopback_ipv4_pool"] = node_defaults["routerIdPool"]

                  if switch_facts["type"] == "spline":
                      switch_facts["loopback_ipv4_offset"] = 0
                  elif switch_facts["type"] == "leaf":
                      if building_details["splineDefaults"]["routerIdPool"] == building_details["campusPodDefaults"]["routerIdPool"]:
                          # Offset is 2
                          switch_facts["loopback_ipv4_offset"] = 2
                      else:
                          switch_facts["loopback_ipv4_offset"] = 0

                  # switch_facts["loopback_ipv4_description"]  =

                  # Set Router ID
                  switch_facts["router_id"] = str(get_router_id(switch_facts))

                  # Set uplink ipv4 pool
                  switch_facts["uplink_ipv4_pool"] = node_defaults.get("uplinkIpv4Pool")
                  switch_facts["uplink_ipv4_subnet_mask"] = 31

                  # Set BGP parameters
                  if switch_facts["underlay_routing_protocol"] == "bgp" or switch_facts["overlay_routing_protocol"] == "bgp":
                      # Set asn
                      asns = string_to_list(str(node_defaults["bgpDetails"]["bgpAsns"]))
                      if len(asns) > 1:
                          if switch_facts.get("mlag_primary_id"):
                              switch_facts["bgp_as"] = asns[switch_facts["mlag_primary_id"] - 1]
                          else:
                              switch_facts["bgp_as"] = asns[switch_facts["id"] - 1]
                      else:
                          switch_facts["bgp_as"] = asns[0]

                      # Set bgp defaults
                      switch_facts["bgp_defaults"] = node_defaults["bgpDetails"]["bgpDefaults"]

                      # Set bgp max paths
                      # switch_facts["bgp_maximum_paths"] = 4

                      # Set bgp ecmp
                      # switch_facts["bgp_ecmp"] = 4

                      # # Set evpn role and evpn neighbors
                      if switch_facts["overlay_routing_protocol"] == "bgp" and switch_facts["underlay_router"] is True:
                          # Set evpn role
                          switch_facts["evpn_role"] = switch_facts.get("default_evpn_role")

                          # Set evpn neighbors
                          switch_facts["evpn_route_servers"] = switch_facts["uplink_switches"]
                          switch_facts["evpn_route_server_ids"] = switch_facts["uplink_switches_ids"]
                      else:
                          # Set evpn role
                          switch_facts["evpn_role"] = None

                          # Set evpn neighbors
                          switch_facts["evpn_route_servers"] = []
                          switch_facts["evpn_route_server_ids"] = []

                  # Set OSPF parameters
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      switch_facts["underlay_ospf_process_id"] = building_details["advancedFabricConfigurations"]["ospfDetails"]["processId"]
                      switch_facts["underlay_ospf_area"] = building_details["advancedFabricConfigurations"]["ospfDetails"]["area"]
                      switch_facts["underlay_ospf_max_lsa"] = building_details["advancedFabricConfigurations"]["ospfDetails"]["maxLsa"]
                      switch_facts["underlay_ospf_bfd_enable"] = building_details["advancedFabricConfigurations"]["ospfDetails"]["bfd"]
                      switch_facts["ospf_defaults"] = node_defaults["ospfDetails"]["ospfDefaults"]

              # Get mlag settings
              if switch_facts["mlag_support"] == True:
                  mlag_peer_switch_facts = get_mlag_peer_by_tags(switch_facts)
                  if mlag_peer_switch_facts is not None:
                      switch_facts["mlag"] = True
                  else:
                      ctx.warning(f"Could not find an MLAG peer for {switch_facts['hostname']}")
                      switch_facts["mlag"] = False

                  if switch_facts["mlag"] == True and mlag_peer_switch_facts is not None:
                      switch_facts["mlag_peer"] = mlag_peer_switch_facts["hostname"]

                      switch_facts["mlag_peer_serial_number"] = mlag_peer_switch_facts["serial_number"]

                      switch_facts["mlag_group"] = switch_facts["group"]

                      if switch_facts["underlay_router"] == True:
                          switch_facts["mlag_l3"] = True
                      else:
                          switch_facts["mlag_l3"] = False

                      switch_facts["mlag_peer_vlan"] =  node_defaults["mlagDetails"]["mlagPeerVlan"]
                      switch_facts["mlag_peer_ipv4_pool"] = node_defaults["mlagDetails"]["mlagPeerIPv4Pool"]
                      switch_facts["mlag_peer_subnet_mask"] = 31
                      if switch_facts.get("underlay_router"):
                          # Set mlag_peer_l3_vlan if there is value set in studio input
                          if node_defaults['mlagDetails']['mlagPeerL3Vlan'] is not None \
                                  and node_defaults['mlagDetails']['mlagPeerL3IPv4Pool'].strip() != "":
                              switch_facts['mlag_peer_l3_vlan'] = node_defaults['mlagDetails']['mlagPeerL3Vlan']
                              switch_facts['mlag_peer_l3_ipv4_pool'] = node_defaults['mlagDetails']['mlagPeerL3IPv4Pool']
                              switch_facts['mlag_peer_l3_subnet_mask'] = 31
                          else:
                              switch_facts['mlag_peer_l3_vlan'] = switch_facts['mlag_peer_vlan']
                              switch_facts['mlag_peer_l3_ipv4_pool'] = switch_facts["mlag_peer_ipv4_pool"]
                              switch_facts['mlag_peer_l3_subnet_mask']= switch_facts["mlag_peer_subnet_mask"]

                      switch_facts["mlag_lacp_mode"] = "active"
                      switch_facts["reload_delay_mlag"] = switch_facts['platform_settings']['reload_delay']['mlag']
                      switch_facts["reload_delay_non_mlag"] = switch_facts['platform_settings']['reload_delay']['non_mlag']
                      # Check to see if this is proper design
                      if switch_facts["campus_type"] == "l2ls":
                          if switch_facts["type"] in ["leaf", "memberleaf"]:  # switch_facts['platform_settings'].get("asu", False) == True:
                              switch_facts["reload_delay_mlag"] = 0
                              switch_facts["reload_delay_non_mlag"] = 0

                      # switch_facts["mlag_ibgp_origin_incomplete"] = True

                      if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                          switch_facts["mlag_primary_id"] = int(switch_facts["id"])

                          switch_facts["mlag_role"] = "primary"

                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                    switch_facts["mlag_peer_subnet_mask"], "primary"))

                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                         switch_facts["mlag_peer_subnet_mask"], "secondary"))

                          if switch_facts.get("underlay_router"):
                              switch_facts["mlag_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                           switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                              switch_facts["mlag_peer_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                                switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                      else:
                          switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])

                          switch_facts["mlag_role"] = "secondary"

                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_peer_subnet_mask"], "secondary"))

                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                         switch_facts["mlag_peer_subnet_mask"], "primary"))


                          if switch_facts.get("underlay_router"):


                              switch_facts["mlag_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                           switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                              switch_facts["mlag_peer_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                                switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                      # Set mlag interfaces
                      # Set from topology studio
                      switch_facts["mlag_interfaces"], switch_facts["mlag_peer_switch_interfaces"] = set_mlag_interfaces_from_topology(switch_facts)

                      # Set from node defaults (only available on splines)
                      if len(node_defaults["mlagDetails"].get("mlagPeerInterfaces", [])) > 0:
                          mlag_interfaces = []
                          for iface_entry in node_defaults["mlagDetails"]["mlagPeerInterfaces"]:
                              mlag_interfaces += range_expand(iface_entry)
                          switch_facts["mlag_interfaces"] = natural_sort(mlag_interfaces)
                          switch_facts["mlag_peer_switch_interfaces"] = switch_facts["mlag_interfaces"]

                      # Set from campus pod inputs
                      if switch_facts["type"] == "leaf" and campus_pod_details["hideShowToggles"].get("displayPodFabricInterfaceInputs", False) is True:
                          campus_pod_mlag_interfaces = campus_pod_details["campusPodMlagPeerInterfaces"]
                          if len(campus_pod_mlag_interfaces) > 0:
                              mlag_interfaces = []
                              for iface_entry in campus_pod_mlag_interfaces:
                                  mlag_interfaces += range_expand(iface_entry)
                              switch_facts["mlag_interfaces"] = natural_sort(mlag_interfaces)
                              switch_facts["mlag_peer_switch_interfaces"] = switch_facts["mlag_interfaces"]


                      if len(switch_facts.get("mlag_interfaces", [])) > 0:
                          switch_facts["mlag_interfaces_speed"] = node_defaults["mlagDetails"]["mlagPeerInterfacesSpeed"]
                          switch_facts["mlag_interfaces_cli"] = node_defaults["mlagDetails"].get("mlagPeerInterfacesEosCli")
                          switch_facts["mlag_peer_link_cli"] = node_defaults["mlagDetails"].get("mlagPeerLinkEosCli")

              else:
                  switch_facts["mlag"] = False

              if switch_facts["underlay_router"] == True:
                  if switch_facts["vtep"]:  # and building_details["buildingRoutingProtocols"]["buildingOverlayRoutingProtocol"] != "":
                      switch_facts["vtep_loopback_ipv4_pool"] = node_defaults["vtepLoopbackIPv4Pool"]
                      switch_facts["vtep_loopback"] = "Loopback1"
                      if building_details["nodeTypeProperties"]["defaultSplineProperties"].get("splineVtepDefault"):
                          vtep_offset = 1
                      else:
                          vtep_offset = 0
                      switch_facts["vtep_ip"] =  str(get_vtep_loopback(switch_facts, offset=vtep_offset))
                  # else:
                  #     # Turn off the vtep setting since there are no VTEPs in this network
                  #     switch_facts["vtep"] = False

              # Get multicast
              switch_facts["underlay_multicast"] = building_details["advancedFabricConfigurations"]["multicast"].get("underlayMulticast")
              if switch_facts["underlay_multicast"]:
                  switch_facts["rps"] = []
                  switch_facts["ipv6_rps"] = []
                  for rp in building_details["advancedFabricConfigurations"]["multicast"].get("rps", []):
                      if validIPAddress(rp['ipAddress']) is True:
                          switch_facts["rps"].append({"ip_address": rp['ipAddress'], "group_address": rp['groupAddress']})
                      elif validIPAddress(rp['ipAddress']) is False:
                          ctx.error(f"This studio currently does not support IPv6 Rendezvous Points")
                          switch_facts["ipv6_rps"].append({"ip_address": rp['ipAddress'], "group_address": rp['groupAddress']})

              # Get PTP
              # Format node defaults
              if switch_facts["type"] == "leaf":
                  node_defaults["ptpDetails"]["priority1"] = node_defaults["ptpDetails"].get("leafPriority1")
              elif switch_facts["type"] == "memberleaf":
                  node_defaults["ptpDetails"]["priority1"] = node_defaults["ptpDetails"].get("memberLeafPriority1")
              else:
                  node_defaults["ptpDetails"]["priority1"] = node_defaults["ptpDetails"].get("priority1")

              # get ptp values at building level
              ptp_enabled = building_details["advancedFabricConfigurations"]["ptp"].get("enabled", False)  # get(self._hostvars, "ptp.enabled")
              default_ptp_domain = building_details["advancedFabricConfigurations"]["ptp"].get("domain", 127)  # get(self._hostvars, "ptp.domain", default=127)
              default_ptp_profile = building_details["advancedFabricConfigurations"]["ptp"].get("profile", "aes67-r16-2016")  # get(self._hostvars, "ptp.profile", default="aes67-r16-2016")


              # Check to see if the IDF has been selected for ptp config
              if ptp_enabled and switch_facts["type"] in ["leaf", "memberleaf"]:
                  if not device_matches_resolver_query(building_details["advancedFabricConfigurations"]["ptp"]["idfs"], switch_facts['serial_number']):
                      ptp_enabled = False

              # get ptp values at node type level
              default_priority1 = node_defaults["ptpDetails"]["priority1"]
              default_priority2 = switch_facts["id"] % 256

              # get ptp values at idf level
              if campus_pod_details and campus_pod_details.get("ptp"):
                  default_priority1 = campus_pod_details["ptp"]["priority1"]
                  default_priority2 = campus_pod_details["ptp"]["priority2"]

              # Get node-type ptp settings, node-group ptp settings, and node-level ptp settings
              ptp = {"enabled": ptp_enabled}
              # Get other settings
              if ptp["enabled"] is True:
                  auto_clock_identity = node_defaults["ptpDetails"].get("autoClockIdentity")
                  priority1 = default_priority1
                  priority2 = default_priority2
                  if auto_clock_identity:
                      clock_identity_prefix = node_defaults["ptpDetails"]["ptpClockIdentityPrefix"]
                      default_clock_indentity = f"{clock_identity_prefix}:{priority1:02x}:00:{priority2:02x}"
                  else:
                      default_clock_indentity = None
                  ptp["device_config"] = {}
                  ptp["device_config"]["mode"] = "boundary"
                  ptp["device_config"]["forward_unicast"] = False
                  ptp["device_config"]["clock_identity"] = default_clock_indentity
                  ptp["device_config"]["source"] = {"ip": None}
                  ptp["device_config"]["priority1"] = priority1
                  ptp["device_config"]["priority2"] =  priority2
                  ptp["device_config"]["ttl"] = 1
                  ptp["device_config"]["domain"] = default_ptp_domain
                  ptp["device_config"]["message_type"] = {
                      "general": {
                          "dscp": None,
                      },
                      "event": {
                          "dscp": None,
                      }
                  }
                  ptp["device_config"]["monitor"] = {
                      "enabled": True,
                      "threshold": {
                          "offset_from_master": 250,
                          "mean_path_delay": 1500,
                          "drop": {
                              "offset_from_master": None,
                              "mean_path_delay": None,
                          }
                      },
                      "missing_message": {
                          "intervals": {
                              "announce": None,
                              "follow_up": None,
                              "sync": None
                          },
                          "sequence_ids": {
                              "enabled": True,
                              "announce": 3,
                              "delay_resp": 3,
                              "follow_up": 3,
                              "sync": 3
                          }
                      }
                  }
                  ptp["profile"] = default_ptp_profile
                  switch_facts["ptp"] = strip_null_from_data(ptp, (None, {}))

              # if switch_facts["serial_number"] == my_switch_facts["serial_number"]:
              #     ctx.info(f"{switch_facts['ptp']}")

              # Get inband management details
              if building_details["advancedFabricConfigurations"].get("inbandManagementDetails"):
                  # Set boot vlan for aggregation switches
                  if switch_facts["type"] == "spline":
                      switch_facts["boot_vlan"] = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("inbandManagementVlan")
                  elif switch_facts["type"] == "leaf" and switch_facts["campus_type"] == "l2ls":
                      switch_facts["boot_vlan"] = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("inbandManagementVlan")

                  # Set inband management details for L2 switches
                  # inband management vlan
                  switch_facts["inband_management_vlan"] = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("inbandManagementVlan")

                  # inband management subnet
                  switch_facts["inband_management_subnet"] = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("inbandManagementSubnet")

                  # get pod inband management pool
                  if campus_pod_details:
                      switch_facts["inband_management_ip_range"] = campus_pod_details["inbandManagementDetails"]["podInbandManagementIpv4Range"]
                  else:
                      switch_facts["inband_management_ip_range"] = None

              # Set inband management details
              if switch_facts.get("inband_management_subnet") and switch_facts.get("inband_management_vlan"):
                  # inband management role and parents
                  if switch_facts["type"] != "spline":
                      switch_facts["inband_management_role"] = "child"

                  # inbound management parent devices
                  switch_facts["inband_management_parents"] = switch_facts["uplink_switches_ids"]

                  # inband_management_ip
                  if ib_mgmt_ip := get_inband_management_ip(switch_facts):
                      ib_mgmt_subnet = ipaddress.ip_network(switch_facts["inband_management_subnet"]).prefixlen
                      ib_mgmt_ip = f"{ib_mgmt_ip}/{ib_mgmt_subnet}"

                  switch_facts["inband_management_ip"] = ib_mgmt_ip

                  # inband management gateway
                  switch_facts["inband_management_gateway"] = str(list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[0])

                  # inband management interface
                  switch_facts["inband_management_interface"] = "Vlan{}".format(switch_facts["inband_management_vlan"])

                  inband_mgmt_vrf = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("inbandManagementVrf", "default")
                  switch_facts["inband_management_vrf"] = inband_mgmt_vrf if inband_mgmt_vrf.strip() != "" else "default"

                  switch_facts["inband_management_ip_helpers"] = building_details["advancedFabricConfigurations"]["inbandManagementDetails"].get("ipHelperAddresses", [])

                  # set boot vlan for campus ZTP feature
                  switch_facts["boot_vlan"] = switch_facts.get("inband_management_vlan")

              # IP locking
              if ip_locking_details := building_details["advancedFabricConfigurations"].get("ipLocking"):
                  switch_facts["ip_locking"] = {
                      "ipv4": False,
                      "ipv6": False,
                  }
                  if ip_locking_details["ipv4LockingEnabled"]:
                      switch_facts["ip_locking"]["ipv4"] = True
                  if ip_locking_details["ipv6LockingEnabled"]:
                      switch_facts["ip_locking"]["ipv6"] = True
                  if switch_facts["ip_locking"]["ipv4"] is True or switch_facts["ip_locking"]["ipv6"]:
                      # Get DHCP Servers
                      switch_facts["ip_locking"]["dhcp_servers"] = ip_locking_details["dhcpServers"]
                      # Define source interface
                      switch_facts["ip_locking"]["local_interface"] = get(ip_locking_details, "localInterface", default=switch_facts.get("inband_management_interface"))

              if re.match(veos_regex, switch_facts["platform"]):
                  switch_facts["p2p_uplinks_mtu"] = 1500
              else:
                  switch_facts["p2p_uplinks_mtu"] = 9214

              # for regex in jericho_platform_regexes:
              #     if re.search(regex, switch_facts["platform"]):
              #         switch_facts["reload_delay_mlag"] = 780
              #         switch_facts["reload_delay_non_mlag"] = 1020
              #         break

              return switch_facts


          def get_device_interfaces(switch_facts):
              device_id = switch_facts['serial_number']
              interfaces = []

              for interface in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = interface.getPeerInfo()
                  if peer_device is not None and "Ethernet" in interface.name:
                      interfaces.append({
                          "interface_name": interface.name,
                          "peer_interface_name": peer_interface.name,
                          "peer_hostname": peer_device.hostName,
                          "peer_serial_number": peer_device.id
                      })

              return natural_sort(interfaces, sort_key='interface_name')

          def set_mlag_interfaces_from_topology(switch_facts):
              device_id = switch_facts['serial_number']

              # initialize mlag interfaces
              mlag_interfaces = []
              mlag_peer_interfaces = []

              for interface in natural_sort(switch_facts["interfaces"], sort_key="interface_name"):
                  if neighbor := my_switch_facts_neighbors.get(interface["peer_serial_number"]):
                      # Leaf case
                      if switch_facts['type'] == "leaf" and neighbor['type'] == "leaf":
                          mlag_interfaces.append(interface["interface_name"])
                          mlag_peer_interfaces.append(interface["peer_interface_name"])

                      # Spline case
                      elif switch_facts['type'] == "spline" and neighbor['type'] == "spline":
                          mlag_interfaces.append(interface["interface_name"])
                          mlag_peer_interfaces.append(interface["peer_interface_name"])

              return mlag_interfaces, mlag_peer_interfaces

          def get_uplink_info_from_inputs(switch_facts, campus_resolver):
              '''
              Returns switch_facts' uplink_interfaces, uplink_switches, and uplink switches' downlink_interfaces
              '''
              device_id = switch_facts["serial_number"]
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return
              campus_details = campus_resolved["campusDetails"]
              building_resolved = campus_details["building"].resolve(device=device_id)
              if building_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return
              building_details = building_resolved["buildingFacts"]
              campus_pod_details = building_details["campusPods"].resolve(device=device_id)
              if campus_pod_details:
                  campus_pod_details = campus_pod_details["campusPodFacts"]

              # Initialize return variables
              uplink_interfaces = []
              uplink_switches_switch_facts = []
              uplink_switches = []
              uplink_switches_ids = []
              uplink_switch_interfaces = []

              # Get input values
              if campus_pod_details and campus_pod_details["hideShowToggles"]["displayPodFabricInterfaceInputs"] is True:
                  uplink_interface_dicts = []
                  if switch_facts["type"] == "leaf" and len(campus_pod_details.get("leafUplinkInterfaces", [])) > 0:
                      uplink_interface_dicts = campus_pod_details["leafUplinkInterfaces"]
                  elif switch_facts["type"] == "memberleaf" and len(campus_pod_details.get("memberLeafUplinkInterfaces", [])) > 0:
                      uplink_interface_dicts = campus_pod_details["memberLeafUplinkInterfaces"]

                  # Check if there are user inputs for switch uplinks
                  user_input_uplink_info = False
                  for uplink_interface_dict in uplink_interface_dicts:
                      if uplink_interface_dict["hostname"] == switch_facts["hostname"] \
                              and uplink_interface_dict["uplinkInterface"].strip() != "" \
                              and uplink_interface_dict["uplinkSwitchHostname"].strip() != "" \
                              and uplink_interface_dict["uplinkSwitchInterface"].strip() != "":
                          user_input_uplink_info = True
                          break
                  if user_input_uplink_info is True:
                      # Create list of dictionaries first for sorting purposes
                      uplink_interface_info = []
                      for uplink_interface_dict in uplink_interface_dicts:
                          if uplink_interface_dict["hostname"] == switch_facts["hostname"]:
                              uplink_interface_info.append({
                                  "interface_name": uplink_interface_dict["uplinkInterface"],
                                  "peer_interface_name": uplink_interface_dict["uplinkSwitchInterface"],
                                  "peer_hostname": uplink_interface_dict["uplinkSwitchHostname"]
                              })
                      # set uplink info based on user input
                      uplink_interfaces, uplink_switches, uplink_switches_ids, uplink_switch_interfaces = [], [], [], []
                      for uplink_interface_dict in natural_sort(uplink_interface_info, sort_key="interface_name"):
                          uplink_interfaces.append(uplink_interface_dict["interface_name"])
                          uplink_switches.append(uplink_interface_dict["peer_hostname"])
                          uplink_switch_interfaces.append(uplink_interface_dict["peer_interface_name"])

                      # Get uplink_switch_ids if not already set (This is time consuming way to get switch_facts)
                      for hostname in uplink_switches:
                          for tmp_switch_sn, tmp_switch_facts in my_switch_facts_neighbors.items():
                              if tmp_switch_facts["hostname"] == hostname:
                                  uplink_switches_ids.append(tmp_switch_sn)

              return uplink_interfaces, uplink_switches, uplink_switches_ids, uplink_switch_interfaces


          def get_uplink_info_from_topology(switch_facts):
              # Initialize return variables
              uplink_interfaces = []
              uplink_switches_switch_facts = []
              uplink_switches = []
              uplink_switches_ids = []
              uplink_switch_interfaces = []

              device_id = switch_facts['serial_number']

              for interface in natural_sort(switch_facts["interfaces"], sort_key="interface_name"):
                  if neighbor := my_switch_facts_neighbors.get(interface["peer_serial_number"]):
                      # Leaf case
                      if switch_facts['type'] == "leaf":
                          if neighbor['type'] == "spline":
                              uplink_interfaces.append(interface['interface_name'])
                              uplink_switches_switch_facts.append(neighbor)
                              uplink_switches.append(neighbor['hostname'])
                              uplink_switches_ids.append(neighbor['serial_number'])
                              uplink_switch_interfaces.append(interface["peer_interface_name"])

                      # Member Leaf case
                      elif switch_facts['type'] == "memberleaf":
                          if neighbor['type'] == "leaf" or neighbor['type'] == "memberleaf":
                              uplink_interfaces.append(interface['interface_name'])
                              uplink_switches_switch_facts.append(neighbor)
                              uplink_switches.append(neighbor['hostname'])
                              uplink_switches_ids.append(neighbor['serial_number'])
                              uplink_switch_interfaces.append(interface["peer_interface_name"])

              return uplink_interfaces, uplink_switches, uplink_switches_ids, uplink_switch_interfaces


          def set_switch_uplink_info(switch_facts, campus_resolver):
              # Get interface info from topology studio
              switch_facts["uplink_interfaces"], switch_facts["uplink_switches"], switch_facts["uplink_switches_ids"], switch_facts["uplink_switch_interfaces"]  = get_uplink_info_from_topology(switch_facts)

              # Override interface info from topology studio with inputs
              uplink_interfaces, uplink_switches, uplink_switches_ids, uplink_switch_interfaces  = get_uplink_info_from_inputs(switch_facts, campus_resolver)

              if len(uplink_interfaces) > 0:
                  switch_facts["uplink_interfaces"] = uplink_interfaces
                  switch_facts["uplink_switches"] = uplink_switches
                  switch_facts["uplink_switches_ids"] = uplink_switches_ids
                  switch_facts["uplink_switch_interfaces"] = uplink_switch_interfaces

              return switch_facts


          def set_switch_downlink_info(switch_facts):
              '''
              Using switch_facts uplink info which is previously set by set_switch_uplink_info(switch_facts. campus_resolver), set the
              downlink info for switch_facts using the uplink info from other switches in my_switch_facts_neighbors
              '''
              switch_facts["downlink_switches_ids"] = []
              if switch_facts["type"] == "spline":
                  for tmp_switch_sn, tmp_switch_facts in my_switch_facts_neighbors.items():
                      if tmp_switch_facts["type"] == "leaf" and switch_facts["serial_number"] in tmp_switch_facts["uplink_switches_ids"] \
                              and tmp_switch_sn not in switch_facts["downlink_switches_ids"]:
                          switch_facts["downlink_switches_ids"].append(tmp_switch_sn)
              elif switch_facts["type"] == "leaf":
                  for tmp_switch_sn, tmp_switch_facts in my_switch_facts_neighbors.items():
                      if tmp_switch_facts["type"] == "memberleaf" and tmp_switch_facts["group"] == switch_facts["group"] \
                              and switch_facts["serial_number"] in tmp_switch_facts["uplink_switches_ids"] and tmp_switch_sn not in switch_facts["downlink_switches_ids"]:
                          switch_facts["downlink_switches_ids"].append(tmp_switch_sn)

              return switch_facts


          def set_topology_facts(switch_facts):
              topology_facts = {
                  "links": {}
              }
              if switch_facts["uplink_type"] == "p2p":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = my_switch_facts_neighbors[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      link_facts["peer_bgp_as"] = uplink_switch_facts.get("bgp_as")
                      link_facts["type"] = "underlay_p2p"
                      link_facts["speed"] = uplink_switch_facts.get("uplink_interface_speed")
                      link_facts["ip_address"] = str(get_p2p_uplinks_ip(switch_facts, uplink_switch_facts, i))
                      link_facts["peer_ip_address"] = str(get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts, i))
                      link_facts["eos_cli"] = switch_facts.get("uplink_interface_cli", [])
                      # multicast/pim
                      if switch_facts.get("underlay_multicast"):
                          link_facts["underlay_multicast"] = True
                      else:
                          link_facts["underlay_multicast"] = False
                      # ptp
                      if switch_facts.get("ptp") is not None and switch_facts["ptp"].get("enabled") is True:
                          link_facts["ptp"] = {"enable": True}

                      topology_facts["links"][uplink_interface] = link_facts

              elif switch_facts["uplink_type"] == "port-channel":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = my_switch_facts_neighbors[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      # Campus Service has a field here for allowed_vlans
                      if switch_facts["allow_all_vlans"] is False:
                          # Remove vlans if uplink switch doesn't have them
                          uplink_vlans = list(set(switch_facts["vlans"]) & set(uplink_switch_facts.get("vlans", [])))
                          if switch_facts.get("inband_management_vlan"):
                              uplink_vlans.append(switch_facts["inband_management_vlan"])
                          link_facts["vlans"] = uplink_vlans
                      link_facts["type"] = "underlay_l2"
                      link_facts["speed"] = switch_facts.get("uplink_interface_speed")
                      if uplink_switch_facts.get("mlag") is not None and uplink_switch_facts.get("mlag") is True:
                          link_facts["channel_description"] = uplink_switch_facts["mlag_group"]

                      if switch_facts.get("mlag") is not None and switch_facts.get("mlag") is True:
                          link_facts["peer_channel_description"] = switch_facts["mlag_group"]

                      if switch_facts.get("mlag_role") is not None and switch_facts["mlag_role"] == "secondary":
                          mlag_peer_switch_facts =  my_switch_facts_neighbors[switch_facts["mlag_peer_serial_number"]]
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_switch_interfaces"][0]))
                      else:
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_switch_interfaces"][0]))

                      if switch_facts.get("ptp") is not None and switch_facts["ptp"].get("enabled") is True:
                          link_facts["ptp"] = {"enable": True}

                      topology_facts["links"][uplink_interface] = link_facts

              switch_facts["topology"] = topology_facts
              return switch_facts


          def get_network_services_leaf_switch(switch_facts, campus_resolver):
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return switch_facts
              campus_details = campus_resolved["campusDetails"]
              building_resolved = campus_details["building"].resolve(device=device_id)
              if building_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return switch_facts
              building_details = building_resolved["buildingFacts"]

              # Set services
              if switch_facts["network_services_l2"] is True or switch_facts["network_services_l3"] is True:
                  # allow all vlans
                  switch_facts["allow_all_vlans"] = building_details["services"].get("allowAllVLANs", False)
                  leaf = {
                      "vlans": [],
                      "tenants": {}
                  }
                  add_vrfs = {}  # Used to determine which services are applied to this switch
                  add_svis = []  # For logging
                  add_l2vlans = []  # Not necessary
                  # Add VRF if node is found in any of vrf fields
                  for vrf in campus_details["services"]["vrfs"]:
                      # Add all vrfs if add_all_vrfs flag is set to True
                      if building_details["services"].get("applyAllVrfs", False) is True:
                          add_vrfs[vrf['vrfName']] = {
                              "svis": []
                          }
                          continue

                      # if l3 interface is to be configured on switch
                      if len(vrf.get('l3Interfaces').resolve(device=switch_facts['serial_number'])['interfaces']) > 0:
                          if device_matches_resolver_query(vrf['l3Interfaces'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              continue

                      # Add VRF if there is a BGP neighbor for this node in vrf
                      for bgp_peer in vrf.get("externalBgpPeers", []):
                          # if bgp peer is to be configured on switch
                          if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      if add_vrfs.get(vrf['vrfName']):
                          continue

                      # Add VRF if there is a static route for this node in vrf
                      for sr in vrf.get('staticRoutes', []):
                          # if static route is to be configured on switch
                          if device_matches_resolver_query(sr['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      # Last check in loop is unnecessary
                      # if add_vrfs.get(vrf['vrfName']):
                      #     continue

                  # Add VLAN if assigned to switch; Add VRF the VLAN is in if not already added;
                  for vlan in building_details["services"]["vlans"]:
                      # Check if vlan is applied to switch
                      if device_matches_resolver_query(vlan['campusPod'], device_id):
                          add_svis.append(vlan['vlanId'])
                          leaf['vlans'].append(int(vlan['vlanId']))
                          if vlan['sviDetails'].get('vrf', '') == '':
                              vrf_name = 'default'
                          else:
                              vrf_name = vlan['sviDetails']['vrf']

                          # Add vrf to add_vrfs
                          if not add_vrfs.get(vrf_name):
                              add_vrfs[vrf_name] = {
                                  "svis": []
                              }

                          # Add vlan to vrf's add_svis
                          add_vrfs[vrf_name]["svis"].append(int(vlan['vlanId']))

                  # Filter only services applied to this switch
                  if len(add_vrfs) > 0 or len(add_l2vlans) > 0:
                      leaf['tenants'].update({ "services": {"vrfs": add_vrfs, "l2vlans": add_l2vlans} })

                  switch_facts["tenants"]= leaf.get('tenants', {})
                  switch_facts["vlans"] = leaf.get('vlans', [])

                  # if switch_facts["serial_number"] == my_switch_facts["serial_number"]:
                  #     ctx.info(f"VRFs to be configured on switch: {list(add_vrfs.keys())}")
                  #     ctx.info(f"VLANs to be configured on switch: {add_svis}")

              return switch_facts


          def get_network_services_spline_switch(switch_facts, campus_resolver):
              '''
              Get VLANs applied to spline switch via downstream neighbors
              '''
              if switch_facts["type"] != "spline":
                  return switch_facts

              device_id = switch_facts["serial_number"]
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return switch_facts
              campus_details = campus_resolved["campusDetails"]
              building_resolved = campus_details["building"].resolve(device=device_id)
              if building_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return switch_facts
              building_details = building_resolved["buildingFacts"]

              spline = {
                  "vlans": [],
                  "tenants": {}
              }

              add_vrfs = {}  # Used to determine which services are applied to this switch
              # Add VRF if node is found in any of vrf fields
              for vrf in campus_details["services"]["vrfs"]:
                  if switch_facts["network_services_l3"]:
                      # Add all vrfs if add_all_vrfs flag is set to True
                      if building_details["services"].get("applyAllVrfs", False) is True:
                          add_vrfs[vrf['vrfName']] = {
                              "svis": []
                          }
                          continue

                      # if l3 interface is to be configured on switch
                      if len(vrf.get('l3Interfaces').resolve(device=switch_facts['serial_number'])['interfaces']) > 0:
                          add_vrfs[vrf['vrfName']] = {
                              "svis": []
                          }
                          continue

                      # Add VRF if there is a BGP neighbor for this node in vrf
                      for bgp_peer in vrf.get("externalBgpPeers", []):
                          # if bgp peer is to be configured on switch
                          if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      if add_vrfs.get(vrf['vrfName']):
                          continue

                      # Add VRF if there is a static route for this node in vrf
                      for sr in vrf.get('staticRoutes', []):
                          # if static route is to be configured on switch
                          if device_matches_resolver_query(sr['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      # Last check in loop is unnecessary
                      # if add_vrfs.get(vrf['vrfName']):
                      #     continue

              # Filter only services applied to this switch
              if len(add_vrfs) > 0:
                  spline['tenants'].update({ "services": {"vrfs": add_vrfs, "l2vlans": []} })

              if switch_facts["campus_type"] == "l2ls":
                  campus_pods_checked = []
                  for switch_id in switch_facts.get("downlink_switches_ids", []):
                      tmp_switch_facts = my_switch_facts_neighbors.get(switch_id)
                      if tmp_switch_facts is None or tmp_switch_facts["group"] in campus_pods_checked:
                          continue
                      for vlan in tmp_switch_facts.get('vlans', []):
                          if vlan not in spline['vlans']:
                              spline['vlans'].append(vlan)

                      # Only names/ids matter, user inputs within dictionaries dont matter
                      # Get tenant info from downstream tenants
                      for tenant in tmp_switch_facts.get('tenants', {}):
                          if tenant not in spline['tenants']:
                              spline['tenants'][tenant] = tmp_switch_facts["tenants"][tenant]
                          else:
                              # check if vrfs exist for tenant
                              for vrf in tmp_switch_facts["tenants"][tenant].get("vrfs", {}):
                                  if vrf not in spline['tenants'][tenant]["vrfs"]:
                                      spline['tenants'][tenant]["vrfs"][vrf] = tmp_switch_facts["tenants"][tenant]["vrfs"][vrf]
                                  else:
                                      # check if svis exist
                                      for svi in tmp_switch_facts["tenants"][tenant]["vrfs"][vrf].get("svis", {}):
                                          if svi not in  spline['tenants'][tenant]["vrfs"][vrf]["svis"]:
                                              spline['tenants'][tenant]["vrfs"][vrf]["svis"].append(svi)

                      campus_pods_checked.append(tmp_switch_facts["group"])

              switch_facts["tenants"]= spline.get("tenants")
              switch_facts["vlans"] = spline.get("vlans")
              return switch_facts


          def set_base_config(config, switch_facts):
              # IP locking
              # Check to see whether it should be configured or not based on role
              # Check to see whether it should be configured or not based on user input
              # Check to see if ip locking is supported on platform
              # Check to see if ip locking is supported on eos version
              if switch_facts["network_services_l2"] and not switch_facts["network_services_l3"] \
                      and (switch_facts["ip_locking"]["ipv4"] or switch_facts["ip_locking"]["ipv6"]) \
                      and switch_facts["platform_settings"].get("ip_locking", {}).get("support", False) is True \
                      and compare_eos_versions(switch_facts["eos_version"], switch_facts["platform_settings"]["ip_locking"]["starting_eos"]) >= 0:

                  config["address_locking"] = {
                      "dhcp_servers": [],
                      "local_interface": switch_facts["ip_locking"].get("local_interface")
                  }
                  # Add DHCP Servers
                  for dhcp_server_info in switch_facts["ip_locking"].get("dhcp_servers", []):
                      config["address_locking"]["dhcp_servers"].append(dhcp_server_info["ipAddress"])

                  # Note below is only supported on certain hardware (not supported on vEOS)
                  if switch_facts["ip_locking"]["ipv6"]:
                      config["address_locking"]["locked_address"] = {
                          "ipv6": {
                              "enforcement": {
                                  "disabled": True
                              }
                          }
                      }

              # Set spanning tree
              if switch_facts.get("spanning_tree_mode"):
                  config["spanning_tree"]["mode"] = switch_facts["spanning_tree_mode"]
                  if switch_facts.get("spanning_tree_priority"):
                      if config["spanning_tree"]["mode"] == "mstp":
                          # Base spanning tree settings
                          config["spanning_tree"]["mst_instances"] = {
                              0: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                          config['spanning_tree']['mst'] = {
                              'configuration': {
                                  "instances": {}
                              }
                          }
                          # MST instance collection user inputs
                          for instance in convert_dicts(switch_facts.get("mst_instances", {}), primary_key='id'):
                              # instance priority
                              config["spanning_tree"]["mst_instances"][instance["id"]] = {"priority": instance["spanning_tree_priority"]}
                              # instance vlans
                              if instance.get("vlans") is not None:
                                  config["spanning_tree"]["mst"]["configuration"]["instances"][instance["id"]] = {"vlans": instance["vlans"]}


                      elif config["spanning_tree"]["mode"] == "rapid-pvst":
                          config["spanning_tree"]["rapid_pvst_instances"] = {
                              1: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                      elif config["spanning_tree"]["mode"] == "rstp":
                          config["spanning_tree"]["rstp_priority"] = switch_facts["spanning_tree_priority"]

              # Set tcam profile
              # for regex in jericho_platform_regexes:
              #     if re.search(regex, switch_facts["platform"]):
              #         config["tcam_profile"] = {
              #             "system": "vxlan-routing"
              #         }
              #         break
              # Set routing
              config["service_routing_protocols_model"] = "multi-agent"

              # Set ptp
              if switch_facts.get("ptp") and switch_facts["ptp"].get("enabled") is True:
                  config["ptp"] = switch_facts["ptp"]["device_config"]

              # Set multicast
              if switch_facts["underlay_router"] == True:
                  config["ip_routing"] = True
                  if switch_facts.get("underlay_multicast"):
                      config["router_multicast"] = {
                          "ipv4": {
                              "routing": True
                          }
                      }
                      if len(switch_facts["rps"]) > 0 or len(switch_facts["ipv6_rps"]) > 0:
                          config["router_pim_sparse_mode"] = {}
                      # IPv4 RPs
                      if len(switch_facts["rps"]) > 0:
                          config["router_pim_sparse_mode"]["ipv4"] = {"rp_addresses": {}}
                      for rp in switch_facts["rps"]:
                          if rp["ip_address"] not in config["router_pim_sparse_mode"]["ipv4"]["rp_addresses"]:
                              config["router_pim_sparse_mode"]["ipv4"]["rp_addresses"][rp["ip_address"]] = {"groups": {}}

                          if rp["ip_address"] in config["router_pim_sparse_mode"]["ipv4"]["rp_addresses"] \
                                  and rp.get("group_address", "").strip() != "" \
                                  and rp["group_address"] not in config["router_pim_sparse_mode"]["ipv4"]["rp_addresses"][rp["ip_address"]]["groups"]:
                              config["router_pim_sparse_mode"]["ipv4"]["rp_addresses"][rp["ip_address"]]["groups"].update({rp["group_address"]: None})

                      # IPv6 RPs
                      if len(switch_facts["ipv6_rps"]) > 0:
                          config["router_pim_sparse_mode"]["ipv6"] = {"rp_addresses": {}}
                      for rp in switch_facts["ipv6_rps"]:
                          if rp["ip_address"] not in config["router_pim_sparse_mode"]["ipv6"]["rp_addresses"]:
                              config["router_pim_sparse_mode"]["ipv6"]["rp_addresses"][rp["ip_address"]] = {"groups": {}}

                          if rp["ip_address"] in config["router_pim_sparse_mode"]["ipv6"]["rp_addresses"] \
                                  and rp.get("group_address", "").strip() != "" \
                                  and rp["group_address"] not in config["router_pim_sparse_mode"]["ipv6"]["rp_addresses"][rp["ip_address"]]["groups"]:
                              config["router_pim_sparse_mode"]["ipv6"]["rp_addresses"][rp["ip_address"]]["groups"].update({rp["group_address"]: None})

              # Set router-bgp
              if switch_facts["underlay_router"] == True \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  config["router_bgp"]["as"] = switch_facts["bgp_as"]
                  config["router_bgp"]["router_id"] = switch_facts["router_id"]
                  config["router_bgp"]["bgp_defaults"] = switch_facts["bgp_defaults"]
                  if switch_facts.get("bgp_maximum_paths"):
                      config["router_bgp"]["maximum_paths"] = switch_facts["bgp_maximum_paths"]
                  if switch_facts.get("bgp_ecmp"):
                      config["router_bgp"]["ecmp"] = switch_facts["bgp_ecmp"]
              return config


          def set_mlag_config(config, switch_facts):
              if switch_facts.get('mlag'):
                  # Set spanning tree relevant config
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['spanning_tree']['no_spanning_tree_vlan'] = ",".join(
                          [str(switch_facts['mlag_peer_l3_vlan']), str(switch_facts['mlag_peer_vlan'])]
                      )
                  else:
                      config['spanning_tree']['no_spanning_tree_vlan'] = switch_facts['mlag_peer_vlan']

                  # Set mlag vlan
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['vlans'][switch_facts['mlag_peer_l3_vlan']] = {
                          "tenant": "system",
                          "name": "LEAF_PEER_L3",
                          "trunk_groups": ['LEAF_PEER_L3']
                      }
                  config['vlans'][switch_facts['mlag_peer_vlan']] = {
                      "tenant": "system",
                      "name": "MLAG_PEER",
                      "trunk_groups": ['MLAG']
                  }

                  # Set mlag svis
                  # set mlag l3 svi
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"] = {
                          "description": "MLAG_PEER_L3_PEERING",
                          "shutdown": False,
                          "ip_address": f"{switch_facts['mlag_l3_ip']}/{switch_facts['mlag_peer_l3_subnet_mask']}",
                          "no_autostate": True,
                          "mtu": switch_facts['p2p_uplinks_mtu']
                      }

                  # set mlag svi
                  config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_vlan']}"] = {
                      "description": "MLAG_PEER",
                      "shutdown": False,
                      "ip_address": f"{switch_facts['mlag_ip']}/{switch_facts['mlag_peer_subnet_mask']}",
                      "no_autostate": True,
                      "mtu": switch_facts['p2p_uplinks_mtu']
                  }

                  if switch_facts['mlag_l3'] is True:
                      if switch_facts['underlay_routing_protocol'] == "ospf":
                          config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"]['ospf_network_point_to_point'] = True
                          config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"]['ospf_area'] = switch_facts['underlay_ospf_area']

                      if switch_facts["underlay_multicast"]:
                          config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"]["pim"] = {"ipv4": {"sparse_mode": True}}


                  # Set port-channel interfaces
                  switch_facts["mlag_port_channel_id"] = "".join(re.findall(r'\d', switch_facts["mlag_interfaces"][0]))
                  config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"] = {
                      "description": eval(f"f\"{fabric_variables['interface_descriptions']['mlag_port_channel_interface']}\""),
                      "type": "switched",
                      "shutdown": False,
                      "mode": "trunk",
                      "trunk_groups": ['MLAG'],
                      "eos_cli": switch_facts["mlag_peer_link_cli"]
                  }
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"]['trunk_groups']\
                          .append("LEAF_PEER_L3")

                  # Set ethernet interfaces
                  for i, iface in enumerate(switch_facts['mlag_interfaces']):
                      mlag_peer = switch_facts['mlag_peer']
                      mlag_peer_interface = switch_facts['mlag_peer_switch_interfaces'][i]
                      config['ethernet_interfaces'][iface] = {
                          "peer": mlag_peer,
                          "peer_interface": mlag_peer_interface,
                          "peer_type": "mlag",
                          "description": eval(f"f\"{fabric_variables['interface_descriptions']['mlag_ethernet_interfaces']}\""),
                          "type": "switched",
                          "shutdown": False,
                          "channel_group": {
                              "id": switch_facts['mlag_port_channel_id'],
                              "mode": switch_facts['mlag_lacp_mode']
                          },
                          "speed": switch_facts["mlag_interfaces_speed"],
                          "eos_cli": switch_facts["mlag_interfaces_cli"]
                      }

                  # Set mlag config
                  config['mlag_configuration'] = {
                      "enabled": True,
                      "domain_id": switch_facts['mlag_group'],
                      "local_interface": f"Vlan{switch_facts['mlag_peer_vlan']}",
                      "peer_address": switch_facts['mlag_peer_ip'],
                      "peer_link": f"Port-Channel{switch_facts['mlag_port_channel_id']}",
                  }
                  if switch_facts.get('reload_delay_mlag') is not None:
                      config['mlag_configuration']["reload_delay_mlag"] = switch_facts["reload_delay_mlag"]
                  if switch_facts.get('reload_delay_non_mlag') is not None:
                      config['mlag_configuration']["reload_delay_non_mlag"] = switch_facts["reload_delay_non_mlag"]

                  # Set route maps
                  # Origin Incomplete for MLAG iBGP learned routes
                  # if switch_facts['mlag_l3'] is True and \
                  #         switch_facts['mlag_ibgp_origin_incomplete'] is True and \
                  #         switch_facts['underlay_routing_protocol'] == "bgp":
                  #     config['route_maps']["RM-MLAG-PEER-IN"] = {
                  #         "sequence_numbers": {
                  #             10: {
                  #                 "type": "permit",
                  #                 "set": ["origin incomplete"],
                  #                 "description": "Make routes learned over MLAG Peer-link less "
                  #                             "preferred on spines to ensure optimal routing"
                  #             }
                  #         }
                  #     }

                  # Set bgp config
                  if switch_facts['mlag_l3'] is True and switch_facts['underlay_routing_protocol'] == "bgp":
                      (config['router_bgp']['peer_groups']
                      [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]) = {
                          "type": "ipv4",
                          "remote_as": switch_facts['bgp_as'],
                          "next_hop_self": True,
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['password'] is not None:
                          (config['router_bgp']['peer_groups']
                          [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]['password']) = \
                              fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['password']
                      # if switch_facts['mlag_ibgp_origin_incomplete'] is True:
                      #     (config['router_bgp']['peer_groups']
                      #     [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]['route_map_in']) = \
                      #         "RM-MLAG-PEER-IN"
                      (config['router_bgp']['address_family_ipv4']['peer_groups']
                      [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]) = {
                          "activate": True
                      }
                      config['router_bgp']['neighbor_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name'],
                          "remote_as": switch_facts['bgp_as'],
                          "description": switch_facts['mlag_peer']
                      }
                      config['router_bgp']['neighbors'][switch_facts['mlag_peer_l3_ip']] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name'],
                          "description": switch_facts['mlag_peer']
                      }

              return config


          def set_underlay_config(config, switch_facts):
              # logic
              underlay_data = {}
              underlay_data["links"] = switch_facts["topology"]["links"]
              # Determine whether or not boot ztp can be configured on this switch
              issue_boot_ztp_warning = False
              boot_ztp_eligible = False
              if compare_eos_versions(switch_facts["eos_version"], "4.27.1F") >= 0:
                  boot_ztp_eligible = True
              # Add boot ztp vlan to downstream interfaces
              if switch_facts.get("boot_vlan") is not None and switch_facts["network_services_l2"] is True:
                  for interface in switch_facts.get("downlink_interfaces", []):
                      underlay_data["links"][interface] = {
                          "boot_vlan": switch_facts["boot_vlan"],
                          "type": "underlay_l2"
                      }

              # First add interface details from devices whose uplink interface neighbors are this switch
              for sn in switch_facts["downlink_switches_ids"]:
                  neighbor_switch_facts = my_switch_facts_neighbors[sn]
                  for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                      if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                          link = {}
                          link["peer_id"] = neighbor_switch_facts["serial_number"]
                          link["peer"] = neighbor_switch_facts["hostname"]
                          link["peer_interface"] = neighbor_link
                          link["peer_type"] = neighbor_switch_facts["type"]
                          link["peer_bgp_as"] = neighbor_switch_facts.get("bgp_as")
                          link["type"] = neighbor_link_info["type"]
                          link["speed"] = neighbor_link_info["speed"]
                          link["ip_address"] = neighbor_link_info.get("peer_ip_address")
                          link["peer_ip_address"] = neighbor_link_info.get("ip_address")
                          link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                          link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                          link["channel_description"] = neighbor_link_info.get("peer_channel_description")
                          # multicast/pim
                          link["underlay_multicast"] = neighbor_link_info.get("underlay_multicast")
                          # ptp
                          link["ptp"] = neighbor_link_info.get("ptp")
                          # eos cli
                          link["eos_cli"] = neighbor_switch_facts.get("uplink_interface_cli", [])
                          # inband ztp
                          if neighbor_link_info.get("vlans"):
                              link["vlans"] = neighbor_link_info["vlans"]
                          if neighbor_switch_facts.get("boot_vlan") is not None:
                              link["boot_vlan"] = neighbor_switch_facts["boot_vlan"]

                          interface = neighbor_link_info["peer_interface"]
                          underlay_data["links"][interface] = link

              # Set Ethernet interfaces
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_p2p":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "P2P_LINK_TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "speed": link.get("speed"),
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "type": "routed",
                          "shutdown": False,
                          "ip_address": "{}/{}".format(link["ip_address"], switch_facts["uplink_ipv4_subnet_mask"])
                      }
                      # ospf
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["ethernet_interfaces"][iface]["ospf_network_point_to_point"] = True
                          config["ethernet_interfaces"][iface]["ospf_area"] = switch_facts["underlay_ospf_area"]
                      # multicast/pim
                      if link.get("underlay_multicast"):
                          config["ethernet_interfaces"][iface]["pim"] = {
                              "ipv4": {"sparse_mode": True}
                          }
                      # ptp
                      if link.get("ptp") and link["ptp"].get("enable") is True:
                          ptp_config = {}
                          # Apply PTP profile config
                          ptp_profile = get_item(ptp_profiles, "profile", switch_facts["ptp"]["profile"], default={})
                          ptp_config.update(ptp_profile)

                          ptp_config["enable"] = True
                          ptp_config.pop("profile", None)
                          config["ethernet_interfaces"][iface]["ptp"] = ptp_config

                  elif link["type"] == "underlay_l2":
                      config["ethernet_interfaces"][iface] = {
                          "type": "switched",
                          "shutdown": False,
                          "speed": link.get("speed")
                      }
                      if link.get("peer"):
                          config["ethernet_interfaces"][iface]["peer"] = link["peer"]
                      if link.get("peer_interface"):
                          config["ethernet_interfaces"][iface]["peer_interface"] = link["peer_interface"]
                      if link.get("peer_type"):
                          config["ethernet_interfaces"][iface]["peer_type"] = link["peer_type"]
                      if link.get("peer_type") and link.get("peer_interface"):
                          config["ethernet_interfaces"][iface]["description"] = "TO_{}_{}".format(link["peer"].upper(), link["peer_interface"])
                      if link.get("boot_vlan") and boot_ztp_eligible is True:
                          config["ethernet_interfaces"][iface]["boot_vlan"] = link["boot_vlan"]
                      else:
                          issue_boot_ztp_warning = True

                      if link.get("channel_group_id"):
                          config["ethernet_interfaces"][iface]["channel_group"] = {
                              "id": link["channel_group_id"],
                              "mode": "active"
                          }

                  # Add EOS CLI
                  config["ethernet_interfaces"][iface]["eos_cli"] = link.get("eos_cli", [])

              if issue_boot_ztp_warning is True:
                  ctx.warning(f"Could not configure a boot vlan on downstream interfaces for {switch_facts['hostname']} because its EOS version is {switch_facts['eos_version']}.  The switch's EOS version must be >= 4.27.1F.")

              # Set Port-Channel interfaces
              port_channel_list = [] # go through this
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_l2" and \
                          link.get("channel_group_id") and \
                          link.get("channel_group_id") not in port_channel_list:
                      port_channel_list.append(link["channel_group_id"])
                      port_channel = {
                          "description": "{}_Po{}".format(link["peer"].upper(), link.get("peer_channel_group_id")),
                          "type": "switched",
                          "shutdown": False,
                          "mode": "trunk",
                          "mlag": link["channel_group_id"]
                      }
                      if link.get('vlans'):
                          port_channel['vlans'] = list_compress(link['vlans'])

                      if link.get("ptp") and link["ptp"].get("enable") is True:
                          ptp_config = {}
                          # Apply PTP profile config
                          ptp_profile = get_item(ptp_profiles, "profile", switch_facts["ptp"]["profile"], default={})
                          ptp_config.update(ptp_profile)

                          ptp_config["enable"] = True
                          ptp_config.pop("profile", None)
                          port_channel["ptp"] = ptp_config

                      config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])] = port_channel

              # L2 and L3
              if switch_facts["network_services_l2"] == True and \
                  switch_facts["network_services_l3"] == True:
                  # set viritual router mac address
                  config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"]

              # Routing
              if switch_facts["underlay_router"] == True:
                  # Set loopback interfaces
                  if switch_facts.get("router_id"):
                      config["loopback_interfaces"]["Loopback0"] = {
                          "description": "ROUTER_ID",
                          "shutdown": False,
                          "ip_address": "{}/32".format(switch_facts["router_id"]),
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          # config["loopback_interfaces"]["Loopback0"]["ospf_network_point_to_point"] = True
                          config["loopback_interfaces"]["Loopback0"]["ospf_area"] = switch_facts["underlay_ospf_area"]
                  if switch_facts["vtep"] == True:
                      config["loopback_interfaces"][switch_facts["vtep_loopback"]] = {
                         "description": "VTEP_VXLAN_Tunnel_Source",
                         "shutdown": False,
                         "ip_address": "{}/32".format(switch_facts["vtep_ip"])
                      }
                      if switch_facts.get("vtep_vvtep_ip") and switch_facts.get("evpn_services_l2_only") is not None and \
                          switch_facts.get("evpn_services_l2_only") == False:
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]] = [switch_facts["vtep_vvtep_ip"] ]
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]]["ospf_area"] = switch_facts["underlay_ospf_area"]

                  # Set bgp if necessary
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "type": "ipv4",
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"] is not None:
                          config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] \
                              ["password"] = fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"]
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "activate": True,
                      }
                      config["router_bgp"]["redistribute_routes"]["connected"] = {
                          # "route_map": "RM-CONN-2-BGP"
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_bgp"]["neighbors"][link["peer_ip_address"]] = {
                                  "peer_group": fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"],
                                  "remote_as": link["peer_bgp_as"],
                                  "description": "{}_{}".format(link["peer"], link["peer_interface"])
                              }
                      # Create prefix lists
                      # config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"] = {
                      #     "sequence_numbers": {
                      #         10: {
                      #             "action": "permit {} eq 32".format(switch_facts["loopback_ipv4_pool"])
                      #         }
                      #     }
                      # }
                      # if switch_facts.get("vtep_ip") is not None:
                      #     config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][20] = {
                      #         "action": "permit {} eq 32".format(switch_facts["vtep_loopback_ipv4_pool"])
                      #     }
                      # if switch_facts.get("vtep_vvtep_ip") is not None \
                      #    and switch_facts.get("evpn_services_l2_only") is not None \
                      #    and switch_facts.get("evpn_services_l2_only") == False:
                      #     config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][30] = {
                      #         "action": "permit {}".format(switch_facts["vtep_vvtep_ip"])
                      #     }
                      # Create route-maps
                      # config["route_maps"]["RM-CONN-2-BGP"] = {
                      #     "sequence_numbers": {
                      #         10: {
                      #             "type": "permit",
                      #             "match": ["ip address prefix-list PL-LOOPBACKS-EVPN-OVERLAY"]
                      #         }
                      #     }
                      # }
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      config["router_ospf"]["process_ids"] = {
                          switch_facts["underlay_ospf_process_id"]: {
                              "passive_interface_default": True,
                              "router_id": switch_facts["router_id"],
                              "no_passive_interfaces": [],
                              "max_lsa": switch_facts["underlay_ospf_max_lsa"],
                              "ospf_defaults": switch_facts["ospf_defaults"]
                          }
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append(iface)
                      if switch_facts.get("mlag_l3") is not None and switch_facts.get("mlag_l3") == True:
                          config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append("Vlan{}".format(switch_facts["mlag_peer_l3_vlan"]))
                      if switch_facts["underlay_ospf_bfd_enable"] == True:
                          config["bfd_enable"] = True

              return config


          def set_overlay_config(config, switch_facts):
              if not switch_facts.get("underlay_router"):
                  return config
              if switch_facts["overlay_routing_protocol"] != "bgp":
                  return config

              overlay_data = {}
              # Set evpn route servers
              overlay_data["evpn_route_servers"] = {}
              for rs_id in switch_facts["evpn_route_server_ids"]:
                  rs_switch_facts = my_switch_facts_neighbors[rs_id]
                  if rs_switch_facts["evpn_role"] == "server":
                      server = {
                          "bgp_as": rs_switch_facts["bgp_as"],
                          "ip_address": rs_switch_facts["router_id"]
                      }
                      overlay_data["evpn_route_servers"][rs_switch_facts["hostname"]] = server

              # Set evpn route clients
              overlay_data["evpn_route_clients"] = {}
              if switch_facts["evpn_role"] == "server":
                  for campus_switch_facts in my_switch_facts_neighbors.values():
                      if campus_switch_facts["evpn_role"] is not None and campus_switch_facts["evpn_role"] == "client":
                          if switch_facts['serial_number'] in campus_switch_facts["evpn_route_server_ids"]:
                              client = {
                                  "bgp_as": campus_switch_facts["bgp_as"],
                                  "ip_address": campus_switch_facts["router_id"]
                              }
                              overlay_data["evpn_route_clients"][campus_switch_facts["hostname"]] = client

              # Set ebgp
              config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "type": "evpn",
                  "update_source": "Loopback0",
                  "bfd": True,
                  "ebgp_multihop": str(fabric_variables["evpn_ebgp_multihop"]),
                  "send_community": "all",
                  "maximum_routes": 0,
              }
              if switch_facts["evpn_role"] == "server":
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["next_hop_unchanged"] = True
              if fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"] is not None:
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["password"] = fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"]
              config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": False
              }
              config["router_bgp"]["address_family_evpn"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": True
              }
              if switch_facts.get("vtep_ip") and fabric_variables["evpn_hostflap_detection"]["enabled"] == True:
                  config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"] = {
                      "window": fabric_variables["evpn_hostflap_detection"]["window"],
                      "threshold": fabric_variables["evpn_hostflap_detection"]["threshold"],
                      "enabled": fabric_variables["evpn_hostflap_detection"]["enabled"]
                  }
              # Overlay network peering
              for rs, info in overlay_data["evpn_route_servers"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": rs,
                      "remote_as": info["bgp_as"]
                  }
              for cs, info in overlay_data["evpn_route_clients"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": cs,
                      "remote_as": info["bgp_as"]
                  }
              return config


          def set_vxlan_config(config, switch_facts):
              if switch_facts.get("vtep") == True:
                  config["vxlan_interface"] = {
                      "Vxlan1": {
                          "description": "{}_VTEP".format(switch_facts["hostname"]),
                          "vxlan": {
                              "source_interface": switch_facts["vtep_loopback"],
                              "udp_port": 4789
                          }
                      }
                  }
                  if switch_facts.get("mlag"):
                      config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] = "mlag-system-id"
              return config


          def set_inband_management_config(config, switch_facts):
              if switch_facts.get("inband_management_role", "") == "child":
                  # child-vlans
                  config["vlans"][switch_facts["inband_management_vlan"]] = {
                      "tenant": "system",
                      "name": "L2LEAF_INBAND_MGMT"
                  }
                  # child-management-interfaces
                  config["management_interfaces"] = {
                      switch_facts["inband_management_interface"]: {
                          "description": "L2LEAF_INBAND_MGMT",
                          "shutdown": False,
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "ip_address": switch_facts["inband_management_ip"],
                          "gateway": switch_facts["inband_management_gateway"],
                          "type": "inband"
                      }
                  }
                  # child-static-routes
                  config["static_routes"].append(
                      {
                          "destination_address_prefix": "0.0.0.0/0",
                          "gateway": switch_facts["inband_management_gateway"]
                      }
                  )

              else:
                  # parent-logic
                  inband_management_data = {
                      "vlans": [],
                      "subnets": [],
                      "ip_helpers_details": []
                  }
                  for tmp_switch_facts in my_switch_facts_neighbors.values():
                      if switch_facts["serial_number"] in tmp_switch_facts.get("inband_management_parents", []):
                          inband_management_data["role"] = "parent"
                          if tmp_switch_facts["inband_management_subnet"] not in inband_management_data["subnets"]:
                              inband_management_data["vlans"].append(tmp_switch_facts["inband_management_vlan"])
                              inband_management_data["subnets"].append(tmp_switch_facts["inband_management_subnet"])
                              inband_management_data["ip_helpers_details"].append(tmp_switch_facts.get("inband_management_ip_helpers"))

                  if inband_management_data.get("role", "") == "parent":
                      # parent-vrfs
                      if switch_facts["inband_management_vrf"] != "default" and switch_facts["inband_management_vrf"] not in config["vrfs"]:
                          config["vrfs"][switch_facts["inband_management_vrf"]] = {
                              "tenant": "system",
                              "ip_routing": True
                          }
                      # parent-vlans
                      for vlan in inband_management_data.get("vlans", []):
                          config["vlans"][vlan] = {
                              "tenant": "system",
                              "name": "L2LEAF_INBAND_MGMT"
                          }
                      # parent-vlan-interfaces
                      for i, subnet in enumerate(inband_management_data.get("subnets", [])):
                          vlan_interface = {
                              "description": "L2LEAF_INBAND_MGMT",
                              "shutdown": False,
                              "vrf": switch_facts["inband_management_vrf"],
                              "mtu": switch_facts["p2p_uplinks_mtu"],
                              "ip_virtual_router_addresses": [list(ipaddress.ip_network(subnet).hosts())[0]],
                              "ip_attached_host_route_export": {
                                  "distance": 19
                              },
                              "ip_helpers": {}
                          }
                          for ip_helper in inband_management_data["ip_helpers_details"][i]:
                              vlan_interface['ip_helpers'][ip_helper["dhcpServer"]] = {
                                  "source_interface": ip_helper.get("dhcpSourceInterface")
                              }

                          if switch_facts.get("mlag") is not None and switch_facts["mlag"] is True and switch_facts["mlag_role"] == "secondary":
                              ip_address = list(ipaddress.ip_network(subnet).hosts())[2]
                          else:
                              ip_address = list(ipaddress.ip_network(subnet).hosts())[1]

                          subnet_mask = subnet.split("/")[-1]
                          vlan_interface["ip_address"] = f"{ip_address}/{subnet_mask}"

                          config["vlan_interfaces"]["Vlan{}".format(inband_management_data["vlans"][i])] = vlan_interface
                      # Set virtual router mac address unless it will be set in network services
                      if switch_facts["network_services_l2"] is True and switch_facts["network_services_l3"] is True:
                          config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"].lower()

                      if switch_facts["underlay_router"] is True and switch_facts["underlay_routing_protocol"] == "bgp":
                          # parent-router-bgp
                          config["router_bgp"]["redistribute_routes"]["attached-host"] = {}

                          # parent-prefix-lists
                          # config["prefix_lists"]["PL-L2LEAF-INBAND-MGMT"] = {
                          #     "sequence_numbers": {}
                          # }
                          # for i, subnet in enumerate(inband_management_data.get("subnets", [])):
                          #     config["prefix_lists"]["PL-L2LEAF-INBAND-MGMT"]["sequence_numbers"][(i+1)*10] = {
                          #         "action": f"permit {subnet}"
                          #     }

                          # parent-route-maps
                          # sequence 10 is set in underlay so avoid setting it here
                          # config["route_maps"]["RM-CONN-2-BGP"]["sequence_numbers"][20] = {
                          #     "type": "permit",
                          #     "match": ["ip address prefix-list PL-L2LEAF-INBAND-MGMT"]
                          # }

              return config


          def get_tenants(switch_facts, campus_resolver):
              '''
              Convert studio services data model to avd network services data model

              Args:

              Returns:
                  all_services: a dictionary that conforms to avd's network services data model
              '''
              # device_id
              device_id = switch_facts["serial_number"]
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return None
              campus_details = campus_resolved["campusDetails"]
              building_resolved = campus_details["building"].resolve(device=device_id)
              if building_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Building input.  Make sure a 'Building' tag is applied.")
                  return None

              building_details = building_resolved["buildingFacts"]

              all_vrfs = campus_details["services"]["vrfs"]  # a list of studios vrf input dictionaries
              all_vlans = building_details["services"]["vlans"]  # a list of studios vlan input dictionaries

              tenant_name = "services"
              tenant = {
                  tenant_name: {
                      "vrfs": {
                          # initialize default vrf
                          "default": {
                              "svis": {}
                          }
                      }
                  }
              }
              if "default" not in [vrf["vrfName"] for vrf in all_vrfs]:
                  all_vrfs = all_vrfs + [{"vrfName": "default", "mlagL3PeeringDetails": {}, "staticRoutes": [], "vrfOspfConfiguration": {}}]
              for vrf in all_vrfs:
                  vrf_name = vrf["vrfName"]
                  tenant[tenant_name]["vrfs"][vrf_name] = {"svis": {}}
                  if switch_facts["network_services_l2"] and switch_facts["network_services_l3"]:
                      # mlag l3 peering
                      if vrf.get("mlagL3PeeringDetails") and vrf["mlagL3PeeringDetails"].get("vrfMlagPeerL3Vlan") and switch_facts.get('mlag_role') is not None:
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_ibgp_peering_vlan"] = vrf["mlagL3PeeringDetails"]["vrfMlagPeerL3Vlan"]

                          if vrf["mlagL3PeeringDetails"].get("vrfMlagPeerL3IPv4Pool", "") != "":
                              mlag_ibgp_peering_ipv4_pool = vrf["mlagL3PeeringDetails"]["vrfMlagPeerL3IPv4Pool"]
                              if switch_facts["mlag_role"] == "primary":
                                  mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                              switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                                  mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                                  switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                              else:
                                  mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                              switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                                  mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                                  switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                          else:
                              mlag_l3_ip = switch_facts["mlag_l3_ip"]
                              mlag_peer_l3_ip = switch_facts["mlag_peer_l3_ip"]

                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_l3_ip"] = mlag_l3_ip
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_peer_l3_ip"] = mlag_peer_l3_ip
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_peer_l3_subnet_mask"] = switch_facts["mlag_peer_l3_subnet_mask"]

                  if switch_facts["network_services_l3"]:
                      # static routes
                      if len(vrf.get("staticRoutes", [])) > 0:
                          tenant[tenant_name]["vrfs"][vrf_name]["static_routes"] = []
                          for sr in vrf.get("staticRoutes", []):
                              if device_matches_resolver_query(sr["devices"], device_id):
                                  static_route = {
                                      "destination_address_prefix": sr["routeDetails"]["destinationAddressPrefix"],
                                      "name": sr["description"].replace(" ", "_"),
                                      "nodes": [device_id]
                                  }
                                  # gateway
                                  if sr["routeDetails"].get("gateway", "") == "":
                                      static_route["gateway"] = None
                                  else:
                                      static_route["gateway"] = sr["routeDetails"]["gateway"]
                                  # interface
                                  if sr["routeDetails"].get("interface", "") == "":
                                      static_route["interface"] = None
                                  else:
                                      static_route["interface"] = sr["routeDetails"]["interface"]
                                  # distance
                                  if sr["routeDetails"].get("distance", "") == "":
                                      static_route["distance"] = None
                                  else:
                                      static_route["distance"] = sr["routeDetails"]["distance"]
                                  # distance
                                  if sr["routeDetails"].get("tag", "") == "":
                                      static_route["tag"] = None
                                  else:
                                      static_route["tag"] = sr["routeDetails"]["tag"]
                                  # metric
                                  if sr["routeDetails"].get("metric", "") == "":
                                      static_route["metric"] = None
                                  else:
                                      static_route["metric"] = sr["routeDetails"]["metric"]

                                  tenant[tenant_name]["vrfs"][vrf_name]["static_routes"].append(static_route)

                      # redistribute static routes

                      # multicast
                      if vrf.get("multicast") and vrf["multicast"].get("enable", False) is True:
                          tenant[tenant_name]["vrfs"][vrf_name]["multicast"] = {"enabled": True}
                      else:
                          tenant[tenant_name]["vrfs"][vrf_name]["multicast"] = {"enabled": False}

                      # rps in vrf
                      if vrf.get("multicast") and vrf["multicast"].get("enable", False) is True:
                          rps = []
                          ipv6_rps = []
                          for rp in vrf["multicast"].get("rps", []):
                              if validIPAddress(rp['ipAddress']) is True:
                                  rps.append({"ip_address": rp['ipAddress'], "group_address": rp['groupAddress']})
                              elif validIPAddress(rp['ipAddress']) is False:
                                  ctx.error(f"This studio currently does not support IPv6 Rendezvous Points")
                                  ipv6_rps.append({"ip_address": rp['ipAddress'], "group_address": rp['groupAddress']})
                          # Add rps
                          tenant[tenant_name]["vrfs"][vrf_name]["multicast"]["rps"] = rps

                      # l3 interfaces
                      if vrf.get("l3Interfaces") and device_matches_resolver_query(vrf["l3Interfaces"], device_id):
                          # Create l3_interfaces list in tenant vrf if it doesn't already exist
                          if not tenant[tenant_name]["vrfs"][vrf_name].get("l3_interfaces"):
                              tenant[tenant_name]["vrfs"][vrf_name]["l3_interfaces"] = []
                          # Populate l3_interfaces list in tenant vrf with user input l3 interfaces
                          for l3_interface in vrf['l3Interfaces'].resolve(device=device_id).get("interfaces", []):
                              interface = {}
                              interface["interfaces"] = [l3_interface["name"]]
                              interface["nodes"] = [switch_facts["serial_number"]]
                              interface["ip_addresses"] = [l3_interface["ipAddress"]]
                              interface["enabled"] = l3_interface["enabled"]
                              if l3_interface.get("description", "") != "":
                                  interface["description"] = l3_interface["description"]
                              if l3_interface.get("mtu"):
                                  interface["mtu"] = l3_interface["mtu"]
                              if len(l3_interface.get("eosCli", [])) > 0:
                                  interface["raw_eos_cli"] = l3_interface["eosCli"]
                                  # interface["raw_eos_cli"] = "\n".join(l3_interface["eosCli"])  # will use this method when extended text input type is available
                              # Check ospf
                              if switch_facts["underlay_routing_protocol"] == "ospf" and l3_interface.get("ospf"):
                                  ospf = {
                                      "enabled": l3_interface["ospf"]["enabled"],
                                      "point_to_point": l3_interface["ospf"]["pointToPoint"],
                                      "passive": l3_interface["ospf"]["passive"],
                                      "area": l3_interface["ospf"].get("area", "0"),
                                      "cost": l3_interface["ospf"].get("cost"),
                                  }
                                  # ospf authentication
                                  if l3_interface["ospf"].get("authentication", "") != "":
                                      ospf["authentication"] = l3_interface["ospf"]["authentication"]
                                  # ospf simple auth key
                                  if l3_interface["ospf"].get("simpleAuthKey", "") != "":
                                      ospf["simpleAuthKey"] = l3_interface["ospf"]["simpleAuthKey"]
                                  # ospf message digest keys
                                  if len(l3_interface["ospf"].get("messageDigestKeys", [])) > 0:
                                      ospf["message_digest_keys"] = []
                                      for mdk in l3_interface["ospf"]["messageDigestKeys"]:
                                          ospf["message_digest_keys"].append({
                                              "id": mdk.get("id"),
                                              "hash_algorithm": mdk.get("hashAlgorithm"),
                                              "key": mdk.get("key"),
                                          })
                                  interface["ospf"] = ospf

                              # multicast
                              if l3_interface.get("multicast") is not None and l3_interface["multicast"].get("pim", "") == "Yes":
                                  interface["multicast"] = True
                              else:
                                  interface["multicast"] = False

                              # ptp
                              if l3_interface.get("ptp") is not None and l3_interface["ptp"].get("enable", "") == "Yes":
                                  interface["ptp"] = {"enable": True}

                              # add interface
                              tenant[tenant_name]["vrfs"][vrf_name]["l3_interfaces"].append(interface)

                      # external bgp peers
                      if switch_facts["underlay_routing_protocol"] == "bgp" and len(vrf.get('externalBgpPeers', {})) > 0:
                          tenant[tenant_name]["vrfs"][vrf_name]['bgp_peers'] = {}
                          for bgp_peer in vrf.get('externalBgpPeers', {}):
                              # check if bgp peer is to be configured on switch
                              if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                                  peer = {}
                                  peer['remote_as'] = bgp_peer['remoteAs']
                                  if bgp_peer.get('description') and bgp_peer['description'].strip() != "":
                                      peer['description'] = bgp_peer['description']
                                  if bgp_peer.get('password', '').strip() != "":
                                      peer['password'] = bgp_peer['password']
                                  if bgp_peer.get('sendCommunity', '').strip() != "":
                                      peer['send_community'] = bgp_peer['sendCommunity']
                                  if bgp_peer.get('nextHopSelf', '').strip() != "":
                                      peer['next_hop_self'] = bgp_peer['nextHopSelf']
                                  if bgp_peer['maxRoutes'].get('maximumRoutes'):
                                      peer['maximum_routes'] = bgp_peer['maxRoutes'].get('maximumRoutes')
                                  if bgp_peer['maxRoutes'].get('warningLimit'):
                                      peer['warning_limit_routes'] = bgp_peer['maxRoutes'].get('warningLimit')
                                  if bgp_peer['defaultOriginate'].get('ebgpPeerDefaultOriginateEnable'):
                                      peer['default_originate'] = {
                                          "always": bgp_peer['defaultOriginate'].get('always')
                                      }
                                  if bgp_peer.get('updateSource', '').strip() != "":
                                      peer['update_source'] = bgp_peer['updateSource']
                                  if bgp_peer.get('ebgpMultihop'):
                                      peer['ebgp_multihop'] = bgp_peer['ebgpMultihop']

                                  peer['nodes'] = [switch_facts['serial_number']]

                                  if bgp_peer['nextHop'].get('ipv4NextHop', '').strip() != "":
                                      peer['set_ipv4_next_hop'] = bgp_peer['nextHop']['ipv4NextHop']
                                  if bgp_peer['nextHop'].get('ipv6NextHop', '').strip() != "":
                                      peer['set_ipv6_next_hop'] = bgp_peer['nextHop']['ipv6NextHop']
                                  if bgp_peer['routeMap'].get('routeMapOut', '').strip() != "":
                                      peer['route_map_out'] = bgp_peer['routeMap']['routeMapOut']
                                  if bgp_peer['routeMap'].get('routeMapIn', '').strip() != "":
                                      peer['route_map_in'] = bgp_peer['routeMap']['routeMapIn']
                                  if bgp_peer.get('weight'):
                                      peer['weight'] = bgp_peer['weight']
                                  if bgp_peer.get('localAs'):
                                      peer['local_as'] = bgp_peer['localAs']

                                  tenant[tenant_name]["vrfs"][vrf_name]['bgp_peers'][bgp_peer['neighborIpAddress']] = peer

                      # ospf configuration
                      if (vrf["vrfOspfConfiguration"].get("vrfOspfEnabled") and switch_facts["underlay_routing_protocol"] == "ospf") \
                              or (switch_facts["underlay_routing_protocol"] == "ospf" and vrf_name == "default"):
                          ospf = {"enabled": True}
                          # process_id
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfProcessId") is not None:
                              ospf["process_id"] = vrf["vrfOspfConfiguration"]["vrfOspfProcessId"]
                          else:
                              ospf["process_id"] = switch_facts["underlay_ospf_process_id"]
                          # max lsa
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfMaxLsa") is not None:
                              ospf["max_lsa"] = vrf["vrfOspfConfiguration"]["vrfOspfMaxLsa"]
                          else:
                              ospf["max_lsa"] = switch_facts["underlay_ospf_max_lsa"]
                          # bfd
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfBfd", "") != "":
                              ospf["bfd"] = True if vrf["vrfOspfConfiguration"]["vrfOspfBfd"] == "Yes" else False
                          else:
                              ospf["bfd"] = switch_facts["underlay_ospf_bfd_enable"]
                          # add ospf details to vrf
                          tenant[tenant_name]["vrfs"][vrf_name]["ospf"] = ospf

              for vlan in all_vlans:
                  vlan_id = int(vlan["vlanId"])
                  svi = {}
                  if vlan["sviDetails"].get("vrf", "") == "":
                      vrf_name =  "default"
                  else:
                      vrf_name = vlan["sviDetails"]["vrf"]
                  if switch_facts["network_services_l2"] is True:
                      svi = {
                          "name": vlan.get("name", None),
                          "description": None,
                          "enabled": vlan['sviDetails'].get("sviEnabled"),
                          "ip_virtual_router_addresses": [],
                          "ipv6_virtual_router_addresses": [],
                          "ip_helpers": {},
                          "ipv6_helpers": {},
                          "nodes": {},
                          "mtu": vlan.get("mtu"),
                      }
                      if switch_facts["campus_type"] == "l2ls":
                          # virtual ipv4
                          virtual_ip = vlan["sviDetails"].get("sviIpVirtualRouterAddress", "").strip()
                          if virtual_ip != "":
                              svi["ip_virtual_router_addresses"].append(virtual_ip)
                          # virtual ipv6
                          virtual_ipv6 = vlan["sviDetails"]["ipv6Addressing"].get("ipv6VirtualRouterAddress", "").strip()
                          if virtual_ipv6 != "":
                              svi["ipv6_virtual_router_addresses"].append(virtual_ipv6)
                          # Set primary/secondary node ip address
                          if switch_facts["type"] == "spline":
                              try:
                                  ip_address = None
                                  ipv6_address = None
                                  if switch_facts["mlag_role"] == "secondary":
                                      # Get/Set secondary ip
                                      if vlan["sviDetails"].get("secondarySwitchSviIpAddress", "").strip() != "":
                                          ip_address = vlan["sviDetails"]["secondarySwitchSviIpAddress"]

                                      # Get/Set secondary ipv6
                                      if vlan["sviDetails"]["ipv6Addressing"].get("secondarySwitchSviIpv6Address", "").strip() != "":
                                          ipv6_address = vlan["sviDetails"]["ipv6Addressing"]["secondarySwitchSviIpv6Address"]
                                  else:
                                      # Get/Set primary ip
                                      if vlan["sviDetails"].get("primarySwitchSviIpAddress", "").strip() != "":
                                          ip_address = vlan["sviDetails"]["primarySwitchSviIpAddress"]

                                      # Get/Set primary ipv6
                                      if vlan["sviDetails"]["ipv6Addressing"].get("primarySwitchSviIpv6Address", "").strip() != "":
                                          ipv6_address = vlan["sviDetails"]["ipv6Addressing"]["primarySwitchSviIpv6Address"]

                                  if ip_address or ipv6_address:
                                      node_ips = {}
                                      if ip_address:
                                          node_ips["ip_address"] = ip_address
                                      if ipv6_address:
                                          node_ips["ipv6_address"] = ipv6_address
                                      # Add ips to SVI
                                      svi["nodes"][switch_facts["serial_number"]] = node_ips
                              except IndexError as e:
                                  assert False, f"VLAN {vlan_id}'s virtual IP address does not have a subnet mask.  If the virtual IP address is not entered in CIDR notation, there must be input values for the primary and secondary switch IP addresses."

                      else:
                          # virtual ip
                          virtual_ip = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('sviIpVirtualRouterAddress', "").strip()
                          if virtual_ip != "":
                              svi["ip_virtual_router_addresses"].append(virtual_ip)

                          # Set primary/secondary node ip address
                          if switch_facts["type"] == "leaf":
                              try:
                                  if switch_facts.get("mlag_role", "") == "secondary":
                                      # Get/Set secondary ip
                                      ip_address = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('secondarySwitchSviIpAddress', "")
                                      if ip_address == "" and virtual_ip != "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[2]}/{ip_network.prefixlen}"
                                  else:
                                      # Get/Set primary ip
                                      ip_address = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('primarySwitchSviIpAddress', "")
                                      if ip_address == "" and virtual_ip != "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[1]}/{ip_network.prefixlen}"
                                  svi["nodes"][switch_facts["serial_number"]] = {"ip_address": ip_address}
                              except IndexError as e:
                                  assert False, f"VLAN {vlan_id}'s virtual IP address does not have a subnet mask.  If the virtual IP address is not entered in CIDR notation, there must be input values for the primary and secondary switch IP addresses."

                      # ip helper configuration
                      for ip_helper in vlan.get("dhcpHelpers", []):
                          # Check ip_address for ipv4 or ipv6
                          if ip_helper.get("dhcpServer") is not None and validateIPNetwork(ip_helper["dhcpServer"]):
                              svi['ip_helpers'][ip_helper.get("dhcpServer")] = {
                                  "source_interface": ip_helper["dhcpSourceInterface"]
                              }
                          elif ip_helper.get("dhcpServer") is not None and validateIPNetwork(ip_helper["dhcpServer"]) is False:
                              svi['ipv6_helpers'][ip_helper.get("dhcpServer")] = {
                                  "local_interface": ip_helper["dhcpSourceInterface"]
                              }
                      # ospf configuration
                      if switch_facts.get("underlay_routing_protocol", "") == "ospf" and vlan.get("sviOspfConfiguration"):
                          svi["ospf"] = {
                              "enabled": vlan["sviOspfConfiguration"]["enabled"],
                              "point_to_point": vlan["sviOspfConfiguration"]["pointToPoint"],
                              "passive": vlan["sviOspfConfiguration"]["passive"],
                              "area": vlan["sviOspfConfiguration"].get("area", "0"),
                              "cost": vlan["sviOspfConfiguration"].get("cost"),
                          }
                          # ospf authentication
                          if vlan["sviOspfConfiguration"].get("authentication", "") != "":
                              svi["ospf"]["authentication"] = vlan["sviOspfConfiguration"]["authentication"]
                          # ospf simple auth key
                          if vlan["sviOspfConfiguration"].get("simpleAuthKey", "") != "":
                              svi["ospf"]["simpleAuthKey"] = vlan["sviOspfConfiguration"]["simpleAuthKey"]
                          # ospf message digest keys
                          if len(vlan["sviOspfConfiguration"].get("messageDigestKeys", [])) > 0:
                              svi["ospf"]["message_digest_keys"] = []
                              for mdk in vlan["sviOspfConfiguration"]["messageDigestKeys"]:
                                  svi["ospf"]["message_digest_keys"].append({
                                      "id": mdk.get("id"),
                                      "hash_algorithm": mdk.get("hashAlgorithm"),
                                      "key": mdk.get("key"),
                                  }
                                  )

                      # multicast
                      if switch_facts["underlay_multicast"] and vlan["multicast"].get("pim"):
                          svi["underlay_multicast"] = True
                      else:
                          svi["underlay_multicast"] = False

                      # eos cli
                      if len(vlan.get("eosCli", [])) > 0:
                          svi["raw_eos_cli"] = vlan["eosCli"]
                          # svi["raw_eos_cli"] = "\n".join(vlan["eosCli"])  # will use this method when extended text input type is available

                      # vlan mst instance
                      if switch_facts.get("spanning_tree_mode") == "mstp":
                          svi["mst_instance_id"] = vlan["vlanSpanningTreeDetails"].get("vlanMstInstance")

                      # vlan stp priority
                      elif switch_facts.get("spanning_tree_mode") == "rapid-pvst":
                          if switch_facts["type"] == "spline":
                              spanning_tree_priority = vlan["vlanSpanningTreeDetails"].get("vlanStpPrioritySpline")
                          elif switch_facts["type"] == "leaf":
                              spanning_tree_priority = vlan["vlanSpanningTreeDetails"].get("vlanStpPriorityLeaf")
                          else:  # switch_facts["type"] == "memberleaf":
                              spanning_tree_priority = vlan["vlanSpanningTreeDetails"].get("vlanStpPriorityMemberLeaf")

                          svi["spanning_tree_priority"] = spanning_tree_priority if spanning_tree_priority is not None else switch_facts["spanning_tree_priority"]

                  tenant[tenant_name]["vrfs"][vrf_name]["svis"][vlan_id] = svi

              switch_facts["all_tenants"] = tenant
              return switch_facts


          def set_network_services_config(config, switch_facts):
              # logic (Probably will be easier to break away from AVD logic)
              if switch_facts["network_services_l2"] is True or switch_facts["network_services_l3"] is True:
                  network_services_data = {}
                  tmp_tenants = []
                  # tenants
                  for tenant in convert_dicts(switch_facts["all_tenants"]):
                      if tenant["name"] in switch_facts.get('tenants', []):
                          switch_tenant = switch_facts["all_tenants"][tenant["name"]]
                          # vrfs
                          tmp_vrfs = []
                          for vrf in convert_dicts(tenant["vrfs"]):
                              if vrf["name"] in switch_facts["tenants"][tenant["name"]].get("vrfs", {}):
                                  switch_vrf = switch_tenant["vrfs"][vrf["name"]]
                                  # svis & bgp_peers
                                  tmp_svis = []
                                  for svi in convert_dicts(vrf["svis"], primary_key='id'):
                                      if svi["id"] in switch_facts["tenants"][tenant["name"]]["vrfs"][vrf["name"]].get("svis", []):
                                          tmp_svis.append(svi)
                                  vrf.update({'svis': tmp_svis, 'bgp_peers': vrf.get("bgp_peers", {})})
                                  tmp_vrfs.append(vrf)
                          # l2vlans
                          tmp_l2vlans = []
                          # for l2vlan in tenant.l2vlans | arista.avd.convert_dicts('id') | arista.avd.natural_sort('id')
                          #     if l2vlan.id in switch_tenant.l2vlans | arista.avd.default([])
                          #         tmp_l2vlans.append(l2vlan)

                          tenant.update({'vrfs': tmp_vrfs, 'l2vlans': tmp_l2vlans})
                          tmp_tenants.append(tenant)
                  network_services_data["tenants"] = tmp_tenants

                  # Log network services data
                  # ctx.info(f"Network Services Data: {network_services_data}")

              # l2
              if switch_facts["network_services_l2"]:
                  # vlans
                  # tenant vlans #}
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # Tenant VLANs w/SVIs #}
                          for svi in vrf["svis"]:
                              if svi.get("id"):
                                  vlan = {"tenant": tenant["name"]}
                                  # name
                                  if svi.get("name", "") != "":
                                      vlan["name"] = svi["name"]
                                  config["vlans"][svi["id"]] = vlan
                                  # spanning_tree_priority
                                  if svi.get("spanning_tree_priority"):
                                      config["spanning_tree"]["rapid_pvst_instances"][svi["id"]]= {"priority": svi["spanning_tree_priority"]}


                          # VLAN for iBGP peering in overlay VRFs #}
                          if switch_facts.get("mlag_l3", False) is True:
                              configure_mlag_ibgp_peering = vrf.get("enable_mlag_ibgp_peering_vrfs", True)
                              if configure_mlag_ibgp_peering and vrf.get("mlag_ibgp_peering_vlan"):
                                  vlan = {
                                      "tenant": tenant["name"],
                                      "name": f"MLAG_iBGP_{vrf['name']}",
                                      "trunk_groups": ["LEAF_PEER_L3"]
                                  }
                                  config["vlans"][vrf["mlag_ibgp_peering_vlan"]] = vlan
                      # Tenant L2 VLANs
                      for l2vlan in tenant["l2vlans"]:
                          if l2vlan.get('id'):
                              vlan = {
                                  "tenant": tenant["name"],
                              }
                              if l2vlan.get("name", "") != "":
                                  vlan["name"] = l2vlan["name"]
                              config["vlans"][l2vlan["id"]] = vlan

                  # ip-igmp-snooping

              # l2 & l3
              if switch_facts["network_services_l2"] is True and switch_facts["network_services_l3"] is True:
                  # ip-virtual-router-mac-address
                  if switch_facts.get("virtual_router_mac_address", "") != "":
                      config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"].lower()

                  # vlan-interface
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # tenant vlan interfaces
                          for svi in vrf["svis"]:
                              # detect if a svi_profile exists
                              if svi.get("profile"):
                                  # If exists, create a shortpath to access profile data
                                  svi_profile = svi_profiles[svi.get('profile')]
                              else:
                                  svi_profile = {}

                              svi_name = svi.get("name") # | default(svi.get("name"), svi_profile.name)

                              svi_description = default(svi.get("description"), svi_name)

                              svi_enabled = svi.get("enabled")  # | default(svi_profile.enabled)

                              svi_ip_virtual_router_addresses = svi.get("ip_virtual_router_addresses", [])

                              svi_ipv6_virtual_router_addresses = svi.get("ipv6_virtual_router_addresses", [])

                              svi_ip_address_virtual = svi.get("ip_address_virtual")  # default(svi.get("ip_address_virtual"), svi_profile.ip_address_virtual)

                              svi_ip_address_virtual_secondaries = svi.get("ip_address_virtual_secondaries")  # default(svi.get("ip_address_virtual_secondaries"), svi_profile.ip_address_virtual_secondaries)

                              svi_mtu = svi.get("mtu")  # default(svi.get("mtu"), svi_profile.get("mtu"))

                              svi_ip_helpers = svi.get("ip_helpers")  # default(svi.get("ip_helpers"), vrf.get("ip_helpers"), svi_profile.get("ip_helpers"))

                              svi_ipv6_helpers = svi.get("ipv6_helpers")

                              svi_raw_eos_cli = svi.get("raw_eos_cli")  # default(svi.get("raw_eos_cli"), svi_profile.get("raw_eos_cli"))

                              vlan = {}
                              vlan["tenant"] = tenant["name"]
                              if svi_description.strip() != "":
                                  vlan["description"] = svi_description

                              if svi_enabled is True:
                                  vlan["shutdown"] = False
                              else:
                                  vlan["shutdown"] = True

                              vlan["vrf"] = vrf["name"]

                              # IPv4 address configuration
                              if svi.get("nodes",{}).get(switch_facts['serial_number'], {}).get("ip_address"):
                                  vlan["ip_address"] = svi["nodes"][switch_facts['serial_number']]["ip_address"]

                              # IPv6 address configuration
                              if svi.get("nodes",{}).get(switch_facts['serial_number'], {}).get("ipv6_address"):
                                  vlan["ipv6_address"] = svi["nodes"][switch_facts['serial_number']]["ipv6_address"]

                              # Virtual Router IPv4 Address
                              vlan["ip_virtual_router_addresses"] = svi_ip_virtual_router_addresses

                              # Virtual Router IPv6 Address
                              vlan["ipv6_virtual_router_addresses"] = svi_ipv6_virtual_router_addresses

                              # Virtual IP address
                              if svi_ip_address_virtual is not None:
                                  vlan["ip_address_virtual"] = svi_ip_address_virtual

                              # Virtual Secondary IP address
                              if svi_ip_address_virtual_secondaries is not None:
                                  vlan["ip_address_virtual_secondaries"] = svi_ip_address_virtual_secondaries

                              # MTU definition
                              if svi_mtu is not None:
                                  vlan["mtu"] = svi_mtu

                              # IPv4 helper configuration
                              if svi_ip_helpers is not None and len(svi_ip_helpers) > 0:
                                  # Turn on global dhcp smart relay option
                                  config["ip_dhcp_relay"] = {"information_option": True}
                                  # Set helper addresses
                                  vlan["ip_helpers"] = {}
                                  for helper_ip in svi_ip_helpers:
                                      vlan["ip_helpers"][helper_ip] = {
                                          "vrf": svi_ip_helpers[helper_ip].get("source_vrf")
                                      }
                                      if svi_ip_helpers[helper_ip].get("source_interface", "").strip() != "":
                                          vlan["ip_helpers"][helper_ip]["source_interface"] = svi_ip_helpers[helper_ip]["source_interface"]

                              # IPv6 helper configuration
                              if svi_ip_helpers is not None and len(svi_ip_helpers) > 0:
                                  # Turn on global dhcp smart relay option
                                  # config["ipv6"]["dhcp"] = {"relay": {"always_on": True}}
                                  # Set helper addresses
                                  vlan["ipv6_helpers"] = {}
                                  for helper_ip in svi_ipv6_helpers:
                                      vlan["ipv6_helpers"][helper_ip] = {
                                          "vrf": svi_ipv6_helpers[helper_ip].get("source_vrf")
                                      }
                                      if svi_ipv6_helpers[helper_ip].get("local_interface", "").strip() != "":
                                          vlan["ipv6_helpers"][helper_ip]["local_interface"] = svi_ipv6_helpers[helper_ip]["local_interface"]

                              # ospf
                              if svi.get("ospf", {}).get("enabled", False) is True and vrf.get("ospf", {}).get("enabled", True) is True:
                                  # ospf area
                                  vlan["ospf_area"] = default(svi["ospf"]["area"], "0")

                                  # ospf network point to point
                                  vlan["ospf_network_point_to_point"] = default(svi["ospf"]["point_to_point"], True)

                                  # ospf cost
                                  if svi["ospf"].get("cost"):
                                      vlan["ospf_cost"] = svi["ospf"]["cost"]

                                  # authentication
                                  if svi["ospf"].get("authentication", "") == "simple" and svi["ospf"].get("simple_auth_key", "") != "":
                                      vlan["ospf_authentication"] = "simple"
                                      vlan["ospf_authentication"] = svi["ospf"]["simple_auth_key"]

                                  elif svi["ospf"].get("authentication", "") == "message-digest" and svi["ospf"].get("message_digest_keys"):
                                      vlan["ospf_authentication"] = "message-digest"
                                      vlan["ospf_message_digest_keys"] = {}
                                      for key in svi["ospf"].get("message-message_digest_keys", []):
                                          if key.get("id") and key.get("key"):
                                              vlan["ospf_message_digest_keys"][key["id"]] = {
                                                  "hash_algorithm": default(key.get("hash_algorithm"), "sha512"),
                                                  "key": key.get("key")
                                              }

                              if svi.get("underlay_multicast", False) is True:
                                  vlan["pim"] = {"ipv4": {"sparse_mode": True}}

                              # raw eos cli
                              if svi_raw_eos_cli is not None:
                                  vlan["eos_cli"] = svi_raw_eos_cli  # May need to indent each line by 6 spaces when input type changes to extended string

                              config["vlan_interfaces"][f"Vlan{svi['id']}"] = vlan

                          # VLAN interface for iBGP peering in overlay VRFs
                          if switch_facts.get("mlag_l3", False) is True:
                              configure_mlag_ibgp_peering = vrf.get("enable_mlag_ibgp_peering_vrfs", True)
                              if configure_mlag_ibgp_peering and vrf.get("mlag_ibgp_peering_vlan"):
                                  config["vlan_interfaces"][f"Vlan{vrf['mlag_ibgp_peering_vlan']}"] = {
                                      "tenant": tenant["name"],
                                      "type": "underlay_peering",
                                      "shutdown": False,
                                      "description": f"MLAG_PEER_L3_iBGP: vrf {vrf['name']}",
                                      "vrf": vrf["name"],
                                      "ip_address": f"{vrf['mlag_l3_ip']}/{vrf['mlag_peer_l3_subnet_mask']}",
                                      "mtu": switch_facts["p2p_uplinks_mtu"]
                                  }

              # l3
              if switch_facts["network_services_l3"] is True:
                  # ethernet-interfaces
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # configure ethernet interfaces
                          if vrf.get('l3_interfaces') is not None:
                              l3_interface_subif_parents = []
                              for l3_interface in vrf['l3_interfaces']:
                                  eth_iface = {}
                                  l3_interface_subif_id = None
                                  if "." in l3_interface['interfaces'][0]:
                                      if l3_interface.get('encapsulation_dot1q_vlan'):
                                          l3_interface_subif_id = l3_interface['encapsulation_dot1q_vlan']
                                      else:
                                          l3_interface_subif_id = l3_interface['interfaces'][0].split('.')[1]
                                      l3_interface_subif_parents.append(l3_interface['interfaces'][0].split('.')[0])
                                  if l3_interface_subif_id is not None:
                                      eth_iface['type'] = "l3dot1q"
                                      eth_iface['encapsulation_dot1q_vlan'] = l3_interface_subif_id
                                  else:
                                      eth_iface['type'] = "routed"
                                  eth_iface['peer_type'] = "l3_interface"
                                  eth_iface['vrf'] = vrf['name']
                                  eth_iface['ip_address'] = l3_interface['ip_addresses'][0] if l3_interface['ip_addresses'][0].strip() != "" else None
                                  if l3_interface.get('mtu'):
                                      eth_iface['mtu'] = l3_interface['mtu']
                                  if l3_interface.get('enabled'):
                                      eth_iface['shutdown'] = False
                                  else:
                                      eth_iface['shutdown'] = True
                                  if l3_interface.get('description') and l3_interface['description'].strip() != "":
                                      eth_iface['description'] = l3_interface['description']
                                  if l3_interface.get("ospf") and vrf.get("ospf"):
                                      if l3_interface["ospf"].get("enabled") and vrf["ospf"].get("enabled"):
                                          # area
                                          eth_iface["ospf_area"] = l3_interface["ospf"].get("area", "0")

                                          # ospf network point to point
                                          eth_iface["ospf_network_point_to_point"] = default(l3_interface["ospf"]["point_to_point"], True)

                                          # ospf cost
                                          if l3_interface["ospf"].get("cost"):
                                              eth_iface["ospf_cost"] = l3_interface["ospf"]["cost"]

                                          # authentication
                                          if l3_interface["ospf"].get("authentication", "") == "simple" and l3_interface["ospf"].get("simple_auth_key", "") != "":
                                              eth_iface["ospf_authentication"] = "simple"
                                              eth_iface["ospf_authentication"] = l3_interface["ospf"]["simple_auth_key"]

                                          elif l3_interface["ospf"].get("authentication", "") == "message-digest" and l3_interface["ospf"].get("message_digest_keys"):
                                              eth_iface["ospf_authentication"] = "message-digest"
                                              eth_iface["ospf_message_digest_keys"] = {}
                                              for key in l3_interface["ospf"].get("message-message_digest_keys", []):
                                                  if key.get("id") and key.get("key"):
                                                      eth_iface["ospf_message_digest_keys"][key["id"]] = {
                                                          "hash_algorithm": default(key.get("hash_algorithm"), "sha512"),
                                                          "key": key.get("key")
                                                      }

                                  # underlay multicast
                                  if l3_interface.get("multicast"):
                                      eth_iface["pim"] = {"ipv4": {"sparse_mode": True}}

                                  # ptp
                                  if l3_interface.get("ptp") and l3_interface["ptp"].get("enable") is True:
                                      ptp_config = {}
                                      # Apply PTP profile config
                                      ptp_profile = get_item(ptp_profiles, "profile", switch_facts["ptp"]["profile"], default={})
                                      ptp_config.update(ptp_profile)

                                      ptp_config["enable"] = True
                                      ptp_config.pop("profile", None)
                                      eth_iface["ptp"] = ptp_config

                                  # eos cli
                                  if l3_interface.get('eos_cli'):
                                      eth_iface['eos_cli'] = l3_interface['eos_cli']
                                  config['ethernet_interfaces'][l3_interface['interfaces'][0]] = eth_iface
                              for parent_iface in l3_interface_subif_parents:
                                  config['ethernet_interfaces'][parent_iface] = {
                                      "type": "routed",
                                      "peer_type": "l3_interface",
                                      "shutdown": False
                                  }


                  # route-maps
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # configure route maps
                          for peer, peer_info in vrf.get('bgp_peers', {}).items():
                              if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                  config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"] = {
                                      "sequence_numbers": {
                                          10: {
                                              "type": "permit",
                                              "set": []
                                          }
                                      }
                                  }
                                  if peer_info.get('set_ipv4_next_hop'):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ip next-hop {peer_info['set_ipv4_next_hop']}")
                                  elif peer_info.get('set_ipv6_next_hop'):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ipv6 next-hop {peer_info['set_ipv6_next_hop']}")

                  # static-routes
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          for static_route in vrf.get("static_routes", []):
                              sr = {}
                              sr["destination_address_prefix"] = static_route.get("destination_address_prefix")
                              sr["vrf"] = vrf["name"]
                              sr["gateway"] = static_route.get("gateway")
                              sr["distance"] = static_route.get("distance")
                              sr["tag"] = static_route.get("tag")
                              sr["name"] = static_route.get("name")
                              sr["metric"] = static_route.get("metric")
                              sr["interface"] = static_route.get("interface")
                              config["static_routes"].append(sr)

                          for svi in vrf.get("svis", []):
                              svi_varp = svi.get("ip_virtual_router_addresses", [])
                              for dest_addr_prefix in svi_varp:
                                  if "/" in dest_addr_prefix:
                                      config["static_routes"].append({
                                          "destination_address_prefix": str(ipaddress.ip_interface(dest_addr_prefix).network),
                                          "vrf": vrf["name"],
                                          "name": "VARP",
                                          "interface": f"Vlan{svi['id']}"
                                      })

                  # ip routing and multicast routing vrfs
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          config["vrfs"][vrf["name"]] = {
                              "tenant": tenant["name"],
                              "ip_routing": True
                          }
                          if vrf.get("multicast") and vrf["multicast"].get("enabled", False) is True:
                              # Enable multicast in vrf
                              if not config["router_multicast"].get("vrfs"):
                                  config["router_multicast"]["vrfs"] = []
                              config["router_multicast"]["vrfs"].append({
                                  "name": vrf["name"],
                                  "ipv4": {
                                      "routing": True
                                  }
                              })
                              # Configure IPv4 RPs
                              if len(vrf["multicast"].get("rps", [])) > 0:
                                  # Add vrfs key
                                  if not config["router_pim_sparse_mode"].get("vrfs"):
                                      config["router_pim_sparse_mode"]["vrfs"] = []

                                  vrf_rp_info = {
                                      "name": vrf["name"],
                                      "ipv4": {
                                          "rp_addresses": {}
                                      }
                                  }
                                  for rp in vrf["multicast"]["rps"]:
                                      if rp["ip_address"] not in vrf_rp_info["ipv4"]["rp_addresses"]:
                                          vrf_rp_info["ipv4"]["rp_addresses"][rp["ip_address"]] = {
                                              "groups": []
                                          }

                                      if rp["ip_address"] in vrf_rp_info["ipv4"]["rp_addresses"] \
                                              and rp.get("group_address", "").strip() != "" \
                                              and rp["group_address"] not in vrf_rp_info["ipv4"]["rp_addresses"][rp["ip_address"]]["groups"]:
                                          vrf_rp_info["ipv4"]["rp_addresses"][rp["ip_address"]]["groups"].append(rp["group_address"])
                                  config["router_pim_sparse_mode"]["vrfs"].append(vrf_rp_info)

                  # router-ospf
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      for tenant in network_services_data["tenants"]:
                          for vrf in tenant["vrfs"]:
                              if vrf.get("ospf") and vrf["ospf"].get("enabled"):
                                  network_services_data["ospf_configured"] = True
                                  break

                      if network_services_data.get("ospf_configured"):
                          # config["router_ospf"]["process_ids"][]
                          for tenant in network_services_data["tenants"]:
                              for vrf in tenant["vrfs"]:
                                  if vrf.get("ospf") and vrf["ospf"].get("enabled"):
                                      vrf_ospf_interfaces = []
                                      ospf_process_id = vrf["ospf"]["process_id"]
                                      ospf_router_id = vrf["ospf"].get("router_id", switch_facts["router_id"])
                                      for l3_interface in vrf.get("l3_interfaces", []):
                                          if switch_facts["serial_number"] in l3_interface.get("nodes", []) and l3_interface.get("interfaces") and l3_interface.get("ospf", {}).get("enabled"):
                                              for i, node in enumerate(l3_interface["nodes"]):
                                                  if node == switch_facts["serial_number"] and not l3_interface['ospf'].get("passive", False):
                                                      vrf_ospf_interfaces.append(l3_interface["interfaces"][i])
                                      for svi in vrf.get("svis", []):
                                          if not svi['ospf'].get("passive", False):
                                              vrf_ospf_interfaces.append(f"Vlan{svi['id']}")
                                      if switch_facts.get("mlag_l3") and vrf.get("mlag_ibgp_peering_vlan"):
                                          vrf_ospf_interfaces.append("Vlan{}".format(vrf["mlag_ibgp_peering_vlan"]))
                                      if ospf_process_id not in config["router_ospf"]["process_ids"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id] = {}
                                      # vrf
                                      config["router_ospf"]["process_ids"][ospf_process_id]["vrf"] = vrf["name"]
                                      # passive interface default
                                      config["router_ospf"]["process_ids"][ospf_process_id]["passive_interface_default"] = True
                                      # ospf_router_id
                                      config["router_ospf"]["process_ids"][ospf_process_id]["router_id"] = ospf_router_id
                                      # no passive interfaces
                                      config["router_ospf"]["process_ids"][ospf_process_id]["no_passive_interfaces"] = config["router_ospf"]["process_ids"][ospf_process_id].get("no_passive_interfaces", []) + vrf_ospf_interfaces
                                      # bfd enable
                                      if vrf["ospf"]["bfd"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id]["bfd_enable"] = True
                                      # max_lsa
                                      if vrf["ospf"]["max_lsa"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id]["max_lsa"] = vrf["ospf"]["max_lsa"]
                                      # redistribute bgp
                                      if vrf["ospf"].get("redistribute_bgp", {}).get("enabled"):
                                          # set if not already set
                                          if not config["router_ospf"]["process_ids"][ospf_process_id].get("redistribute"):
                                              config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"] = {"bgp": {}}
                                          # enable
                                          config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"]["bgp"]["enabled"] = True
                                          # route-map
                                          if vrf["ospf"]["redistribute_bgp"].get("route_map"):
                                              config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"]["bgp"]["route_map"] = vrf["ospf"]["redistribute_bgp"]["route_map"]

                  # router-bgp
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config['router_bgp']['vrfs'] = {}
                      for tenant in network_services_data["tenants"]:
                          for vrf in tenant["vrfs"]:
                              address_family_ipv4_neighbors = []
                              address_family_ipv6_neighbors = []
                              # initialize vrf
                              config['router_bgp']['vrfs'][vrf['name']] = {
                                  "router_id": switch_facts['router_id'],
                                  "route_distinguisher": vrf.get("route_distinguisher"),
                                  "neighbors": {},
                                  "redistribute_routes": {
                                      # "connected": {}
                                      # "attached-host": {}
                                  },
                                  "address_families": {
                                      "ipv4": {"neighbors": {}, "networks": {}},
                                      "ipv6": {"neighbors": {}, "networks": {}}
                                  },
                                  "eos_cli": []
                              }
                              if vrf['name'] != "default":
                                  config['router_bgp']['vrfs'][vrf['name']]['redistribute_routes']['connected'] = {}
                              # mlag ibgp peer
                              if switch_facts.get('mlag_l3') and vrf.get('mlag_peer_l3_ip'):
                                  # Add mlag_ip to nieghbors and address family
                                  config['router_bgp']['vrfs'][vrf['name']]['neighbors'][vrf['mlag_peer_l3_ip']] = {
                                      "remote_as": switch_facts['bgp_as'],
                                      "description": switch_facts['mlag_peer'],
                                      "send_community": "all",
                                      "next_hop_self": True,
                                  }
                                  address_family_ipv4_neighbors.append(vrf['mlag_peer_l3_ip'])
                              # external bgp peers
                              for peer, peer_info in vrf.get('bgp_peers', {}).items():
                                  if validIPAddress(peer) is True:
                                      address_family_ipv4_neighbors.append(peer)
                                  elif validIPAddress(peer) is False:
                                      address_family_ipv6_neighbors.append(peer)
                                  else:
                                      ctx.warning(f"Invalid BGP peer address provided: {switch_facts['building']} Services -> VRF {vrf['name']} -> {peer}")
                                      continue
                                  if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                      peer_info.update({"route_map_out": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"})
                                      if peer_info.get('default_originate'):
                                          if not peer_info['default_originate'].get('route_map'):
                                              peer_info['default_originate'].update(
                                                  {"route_map": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"}
                                              )
                                      if peer_info.get('set_ipv4_next_hop'):
                                          peer_info.pop("set_ipv4_next_hop")
                                      if peer_info.get('set_ipv6_next_hop'):
                                          peer_info.pop("set_ipv6_next_hop")
                                  config['router_bgp']['vrfs'][vrf['name']]['neighbors'][peer] = peer_info


              return config

          log_all_checkpoint_times = False

          start_time = time.time()

          if log_all_checkpoint_times:
              task_time = time.time()

          # Get studio info from ctx
          my_device = ctx.getDevice()
          workspace_id = ctx.studio.workspaceId

          # Initialize variables
          my_switch_facts = {}
          my_config = {}

          # Pre-populate dictionaries used for getting switch facts
          role_dict = populate_multi_value_dict(workspace_id, 'Role')
          campus_dict = populate_single_value_dict(workspace_id, 'Campus')
          building_dict = populate_single_value_dict(workspace_id, 'Building')
          campus_pod_dict = populate_single_value_dict(workspace_id, 'Campus-Pod')
          node_id_dict = populate_single_value_dict(workspace_id, 'NodeId')

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to get tags: {time.time() - task_time} seconds")
              task_time = time.time()

          # Set my_switch_facts' switch properties
          my_switch_facts = set_switch_facts_properties(my_device.id, campus, defaultNamingRules["nodeIdNamingConventionRules"], defaultFabricInterfaces, defaultNamingRules["groupNamingConventionRules"])

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set my_switch_facts properties: {time.time() - task_time} seconds")
              task_time = time.time()

          if my_switch_facts is None:
              ctx.info(f"{my_device.id}: my_switch_facts is {my_switch_facts}")
              return

          ctx.info(f"{my_switch_facts.get('hostname')} Device Properties: {my_switch_facts}")

          # Set all switches in same building as my_switch's switch_facts properties
          if my_switch_facts["type"] == "spline":
              query = "Campus:\"{}\" AND Building:\"{}\" AND (Role:Spline OR Role:Leaf)".format(my_switch_facts['campus'], my_switch_facts['building'])
          else:  #if my_switch_facts["type"] in ["leaf", "memberleaf"]
              query = "Campus:\"{}\" AND Building:\"{}\" AND (Role:Spline OR Campus-Pod:\"{}\")".format(my_switch_facts['campus'], my_switch_facts['building'], my_switch_facts['group'])

          my_switch_facts_neighbors = set_switch_facts_properties_for_query(query, campus, defaultNamingRules["nodeIdNamingConventionRules"], defaultFabricInterfaces, defaultNamingRules["groupNamingConventionRules"])

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set switch_facts properties for all switches in building: {time.time() - task_time} seconds")
              task_time = time.time()

          # Set uplink info for all switch_facts in my_switch_facts_neighbors
          for switch_facts in my_switch_facts_neighbors.values():
              switch_facts = set_switch_uplink_info(switch_facts, campus)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set switch_facts uplink info for all switches in building: {time.time() - task_time} seconds")
              task_time = time.time()

          # Set downlink info for all of my_switch_facts' neighbors
          for switch_facts in my_switch_facts_neighbors.values():
              switch_facts = set_switch_downlink_info(switch_facts)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set downlink info for all of my_switch_facts' neighbors: {time.time() - task_time} seconds")
              task_time = time.time()

          # Set switch_facts for all of my_switch_facts neighbors and my_switch_facts
          for switch_facts in my_switch_facts_neighbors.values():
              switch_facts = set_switch_facts(switch_facts, campus)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set switch_facts for all of my_switch_facts neighbors and my_switch_facts: {time.time() - task_time} seconds")
              task_time = time.time()

          # Get network services applied to each campus_pod switch (part 1a)
          for switch_facts in my_switch_facts_neighbors.values():
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  switch_facts = get_network_services_leaf_switch(switch_facts, campus)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to get network services applied to each campus_pod switch (part 1a): {time.time() - task_time} seconds")
              task_time = time.time()

          # Get network services applied to each spline switch (part 1b)
          #  Need to get network services for spline switches after campus pod leaf switches because
          #  the studio does not allow users to assign VLANs to spline switches so VLANs are assigned to splines
          #  based on downstream campus pod VLANs
          for switch_facts in my_switch_facts_neighbors.values():
              if switch_facts["type"] == "spline":
                  switch_facts = get_network_services_spline_switch(switch_facts, campus)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to network services applied to each spline switch (part 1b): {time.time() - task_time} seconds")
              task_time = time.time()

          # Set topology facts ( in order to set transit p2p and port-channel links )
          for switch_facts in my_switch_facts_neighbors.values():
              switch_facts = set_topology_facts(switch_facts)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to set topology_facts: {time.time() - task_time} seconds")
              task_time = time.time()

          # Get my_switch_facts from my_switch_facts_neighbors
          my_switch_facts = my_switch_facts_neighbors[my_switch_facts["serial_number"]]

          # Get network services in AVD format (part 2)
          my_switch_facts = get_tenants(my_switch_facts, campus)

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to get network services in AVD format (part 2) for my_switch_facts: {time.time() - task_time} seconds")
              task_time = time.time()

          # Set structured config
          my_config = {
              "spanning_tree": {},
              "vlans": {},
              "vlan_interfaces": {},
              "port_channel_interfaces": {},
              "ethernet_interfaces": {},
              "loopback_interfaces": {},
              "prefix_lists": {},
              "route_maps": {},
              ## "router_bfd": {},
              "router_multicast": {},
              "router_bgp": {
                  "peer_groups": {},
                  "address_family_ipv4": {
                      "peer_groups": {}
                  },
                  "address_family_evpn": {
                      "peer_groups": {}
                  },
                  "neighbor_interfaces": {},
                  "neighbors": {},
                  "redistribute_routes": {
                      "connected": {}
                  }
              },
              "router_ospf": {
                  "process_ids": {}
              },
              "vrfs": {},
              "virtual_source_nat_vrfs": {},
              "static_routes": []
          }

          my_config = set_base_config(my_config, my_switch_facts)
          my_config = set_mlag_config(my_config, my_switch_facts)
          my_config = set_underlay_config(my_config, my_switch_facts)
          my_config = set_overlay_config(my_config, my_switch_facts)
          my_config = set_vxlan_config(my_config, my_switch_facts)
          my_config = set_inband_management_config(my_config, my_switch_facts)
          my_config = set_network_services_config(my_config, my_switch_facts)

          config = my_config

          if log_all_checkpoint_times:
              ctx.info(f"Time taken to get set config for my_switch_facts: {time.time() - task_time} seconds")
              task_time = time.time()

          # ctx.info(f"{my_switch_facts}")
          %>
          % if config.get("address_locking"):
          address locking
          %     for dhcp_server in config["address_locking"].get("dhcp_servers", []):
             dhcp server ipv4 ${dhcp_server}
          %     endfor
          %     if config["address_locking"].get("local_interface"):
             local-interface ${ config["address_locking"]["local_interface"] }
          %     endif
          %     if config["address_locking"].get("locked_address"):
          %         if config["address_locking"]["locked_address"].get("ipv4"):
          %             if config["address_locking"]["locked_address"]["ipv4"]["enforcement"].get("disabled", False) is True:
             locked-address ipv4 enforcement disabled
          %              endif
          %         endif
          %         if config["address_locking"]["locked_address"].get("ipv6"):
          %             if config["address_locking"]["locked_address"]["ipv6"]["enforcement"].get("disabled", False) is True:
             locked-address ipv6 enforcement disabled
          %             endif
          %         endif
          %         if config["address_locking"]["locked_address"].get("expiration"):
          %             if config["address_locking"]["locked_address"]["expiration"]["mac"]["enforcement"].get("disabled", False) is True:
             locked-address expiration mac enforcement disabled
          %             endif
          %         endif
          %     endif
          !
          % endif
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - routing model
          % if config.get("service_routing_protocols_model") is not None and config.get("service_routing_protocols_model") == "multi-agent":
          service routing protocols model multi-agent
          !
          % endif
          ## eos - ptp
          % if config.get("ptp"):
          %     if config["ptp"].get("clock_identity"):
          ptp clock-identity ${ config["ptp"]["clock_identity"] }
          %     endif
          %     if config["ptp"].get("source", {}).get("ip"):
          ptp source ip ${ config["ptp"]["source"]["ip"] }
          %     endif
          %     if config["ptp"].get("priority1"):
          ptp priority1 ${ config["ptp"]["priority1"] }
          %     endif
          %     if config["ptp"].get("priority2"):
          ptp priority2 ${ config["ptp"]["priority2"] }
          %     endif
          %     if config["ptp"].get("ttl"):
          ptp ttl ${ config["ptp"]["ttl"] }
          %     endif
          %     if config["ptp"].get("domain"):
          ptp domain ${ config["ptp"]["domain"] }
          %     endif
          %     if config["ptp"].get("message_type"):
          %         if config["ptp"]["message_type"]["general"].get("dscp"):
          ptp message-type general dscp ${ config["ptp"]["message_type"]["general"]["dscp"] } default
          %         endif
          %         if config["ptp"]["message_type"]["event"].get("dscp"):
          ptp message-type event dscp ${ config["ptp"]["message_type"]["event"]["dscp"] } default
          %         endif
          %     endif
          %     if config["ptp"].get("mode"):
          ptp mode ${ config["ptp"]["mode"] }
          %     endif
          %     if config["ptp"].get("forward_unicast") is True:
          ptp forward-unicast
          %     endif
          %     if config["ptp"].get("monitor", {}).get("enabled") is False:
          no ptp monitor
          %     elif config["ptp"].get("monitor"):
          %         if config["ptp"]["monitor"].get("threshold", {}).get("offset_from_master"):
          ptp monitor threshold offset-from-master ${ config["ptp"]["monitor"]["threshold"]["offset_from_master"] }
          %         endif
          %         if config["ptp"]["monitor"].get("threshold", {}).get("mean_path_delay"):
          ptp monitor threshold mean-path-delay ${ config["ptp"]["monitor"]["threshold"]["mean_path_delay"] }
          %         endif
          %         if config["ptp"]["monitor"].get("threshold", {}).get("drop", {}).get("offset_from_master"):
          ptp monitor threshold offset-from-master ${ config["ptp"]["monitor"]["threshold"]["drop"]["offset_from_master"] } nanoseconds drop
          %         endif
          %         if config["ptp"]["monitor"].get("threshold", {}).get("drop", {}).get("mean_path_delay"):
          ptp monitor threshold mean-path-delay ${ config["ptp"]["monitor"]["threshold"]["drop"]["mean_path_delay"] } nanoseconds drop
          %         endif
          %         if config["ptp"]["monitor"].get("missing_message", {}).get("intervals"):
          %             if config["ptp"]["monitor"]["missing_message"]["intervals"].get("announce"):
          ptp monitor threshold missing-message announce ${ config["ptp"]["monitor"]["missing_message"]["intervals"]["announce"] } intervals
          %             endif
          %             if config["ptp"]["monitor"]["missing_message"]["intervals"].get("follow_up"):
          ptp monitor threshold missing-message follow-up ${ config["ptp"]["monitor"]["missing_message"]["intervals"]["follow_up"] } intervals
          %             endif
          %             if config["ptp"]["monitor"]["missing_message"]["intervals"].get("sync"):
          ptp monitor threshold missing-message sync ${ config["ptp"]["monitor"]["missing_message"]["intervals"]["sync"] } intervals
          %             endif
          %         endif
          %         if config["ptp"]["monitor"].get("missing_message", {}).get("sequence_ids", {}).get("enabled", True) is False:
          no ptp monitor sequence-id
          %         elif config["ptp"]["monitor"].get("missing_message", {}).get("sequence_ids", {}).get("enabled", False) is True:
          ptp monitor sequence-id
          %             if config["ptp"]["monitor"]["missing_message"]["sequence_ids"].get("announce"):
          ptp monitor threshold missing-message announce ${ config["ptp"]["monitor"]["missing_message"]["sequence_ids"]["announce"] } sequence-ids
          %             endif
          %             if config["ptp"]["monitor"]["missing_message"]["sequence_ids"].get("delay_resp"):
          ptp monitor threshold missing-message delay-resp ${ config["ptp"]["monitor"]["missing_message"]["sequence_ids"]["delay_resp"] } sequence-ids
          %             endif
          %             if config["ptp"]["monitor"]["missing_message"]["sequence_ids"].get("follow_up"):
          ptp monitor threshold missing-message follow-up ${ config["ptp"]["monitor"]["missing_message"]["sequence_ids"]["follow_up"] } sequence-ids
          %             endif
          %             if config["ptp"]["monitor"]["missing_message"]["sequence_ids"].get("sync"):
          ptp monitor threshold missing-message sync ${ config["ptp"]["monitor"]["missing_message"]["sequence_ids"]["sync"] } sequence-ids
          %             endif
          %         endif
          %     endif
          !
          % endif
          ## eos - spanning-tree
          % if config.get("spanning_tree") is not None:
          %     if config["spanning_tree"].get("mode") is not None:
          spanning-tree mode ${ config["spanning_tree"].get("mode") }
          %     endif
          %     if config["spanning_tree"].get("no_spanning_tree_vlan") is not None:
          no spanning-tree vlan-id ${ config["spanning_tree"].get("no_spanning_tree_vlan") }
          %     endif
          %     if config["spanning_tree"].get("mode", "") == "mstp":
          %         for mst_instance_id in natural_sort(config["spanning_tree"].get("mst_instances", {}).keys()):
          %             if config["spanning_tree"]["mst_instances"][mst_instance_id].get("priority"):
          spanning-tree mst ${ mst_instance_id } priority ${ config["spanning_tree"]["mst_instances"][mst_instance_id]["priority"] }
          %             endif
          %         endfor
          %     elif  config["spanning_tree"].get("mode", "") == "rapid-pvst":
          %         for vlan_id in natural_sort(config["spanning_tree"].get("rapid_pvst_instances", {}).keys()):
          %             if config["spanning_tree"]["rapid_pvst_instances"][vlan_id].get("priority"):
          spanning-tree vlan-id ${ vlan_id } priority ${ config["spanning_tree"]["rapid_pvst_instances"][vlan_id]["priority"] }
          %             endif
          %         endfor
          %     else:
          %         if config["spanning_tree"].get("rstp_priority"):
          spanning-tree priority ${ config["spanning_tree"]["rstp_priority"] }
          %         endif
          %     endif
          %     if config['spanning_tree'].get('mst', {}).get('configuration'):
          !
          spanning-tree mst configuration
          %         if config['spanning_tree']['mst']['configuration'].get('name'):
             name ${ config['spanning_tree']['mst']['configuration']['name'] }
          %         endif
          %         if config['spanning_tree']['mst']['configuration'].get('revision'):
             revision ${ config['spanning_tree']['mst']['configuration']['revision'] }
          %         endif
          %         for instance in natural_sort(config['spanning_tree']['mst']['configuration'].get('instances', {}).keys()):
          %             if config['spanning_tree']['mst']['configuration']['instances'][instance].get('vlans'):
             instance ${ instance } vlan ${ config['spanning_tree']['mst']['configuration']['instances'][instance]['vlans'] }
          %             endif
          %         endfor
          %     endif
          !
          % endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          %     if vrf != "default":
          vrf instance ${ vrf }
          %       if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %       endif
          %     endif
          !
          %   endfor
          %endif
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("vlans") and config["port_channel_interfaces"][port_channel_interface]["mode"] == "trunk":
             switchport trunk allowed vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mlag"):
             mlag ${ config["port_channel_interfaces"][port_channel_interface]["mlag"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("ptp"):
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("enable", False) is True:
             ptp enable
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("sync_message", {}).get("interval") is not None:
             ptp sync-message interval ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["sync_message"]["interval"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("delay_mechanism") is not None:
             ptp delay-mechanism ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["delay_mechanism"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("announce", {}).get("interval") is not None:
             ptp announce interval ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["announce"]["interval"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("transport"):
             ptp transport ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["transport"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("announce", {}).get("timeout") is not None:
             ptp announce timeout ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["announce"]["timeout"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("delay_req") is not None:
             ptp delay-req interval ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["delay_req"] }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("role"):
             ptp role ${ config["port_channel_interfaces"][port_channel_interface]["ptp"].get("role") }
          %         endif
          %         if config["port_channel_interfaces"][port_channel_interface]["ptp"].get("vlan"):
             ptp vlan ${ config["port_channel_interfaces"][port_channel_interface]["ptp"]["vlan"] }
          %         endif
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("eos_cli"):
          %         for cli_statement in config["port_channel_interfaces"][port_channel_interface]["eos_cli"]:
             ${cli_statement}
          %         endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("speed") and config["ethernet_interfaces"][ethernet_interface]["speed"].strip() not in ["", "auto"]:
             speed ${config["ethernet_interfaces"][ethernet_interface]["speed"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("boot_vlan"):
             lldp tlv transmit ztp vlan ${config["ethernet_interfaces"][ethernet_interface]["boot_vlan"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type", "") in ["l2dot1q", "l3dot1q"]:
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlan_id") and config["ethernet_interfaces"][ethernet_interface]["type"] == 'l2dot1q':
             vlan id ${ config["ethernet_interfaces"][ethernet_interface]["vlan_id"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
             encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %             endif
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
             ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point", False):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_cost"):
             ip ospf cost ${ config["ethernet_interfaces"][ethernet_interface]["ospf_cost"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_authentication") is not None:
          %           if config["ethernet_interfaces"][ethernet_interface]["ospf_authentication"] == "simple":
             ip ospf authentication
          %           elif config["ethernet_interfaces"][ethernet_interface]["ospf_authentication"] == "message-digest":
             ip ospf authentication message-digest
          %           endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_authentication_key") is not None:
             ip ospf authentication-key 7 ${ config["ethernet_interfaces"][ethernet_interface]["ospf_authentication_key"] }
          %         endif
          %         for ospf_message_digest_key in natural_sort(config["ethernet_interfaces"][ethernet_interface].get("ospf_message_digest_keys", [])):
          %           if config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("hash_algorithm") is not None and config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("key") is not None:
             ip ospf message-digest-key ${ ospf_message_digest_key } ${ config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["hash_algorithm"] } 7 ${ config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["key"] }
          %           endif
          %         endfor
          %         if config["ethernet_interfaces"][ethernet_interface].get("ptp"):
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("enable", False) is True:
             ptp enable
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("sync_message", {}).get("interval") is not None:
             ptp sync-message interval ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["sync_message"]["interval"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("delay_mechanism") is not None:
             ptp delay-mechanism ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["delay_mechanism"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("announce", {}).get("interval") is not None:
             ptp announce interval ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["announce"]["interval"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("transport"):
             ptp transport ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["transport"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("announce", {}).get("timeout") is not None:
             ptp announce timeout ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["announce"]["timeout"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("delay_req") is not None:
             ptp delay-req interval ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["delay_req"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("role"):
             ptp role ${ config["ethernet_interfaces"][ethernet_interface]["ptp"].get("role") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface]["ptp"].get("vlan"):
             ptp vlan ${ config["ethernet_interfaces"][ethernet_interface]["ptp"]["vlan"] }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %         for cli_statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
             ${cli_statement}
          %         endfor
          %     endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
             ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          %     if config["loopback_interfaces"][loopback_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %     endif
          %     if config["loopback_interfaces"][loopback_interface].get("ospf_area"):
             ip ospf area ${ config["loopback_interfaces"][loopback_interface]["ospf_area"] }
          %     endif
          !
          %   endfor
          %endif
          ## eos - Management Interfaces
          % for management_interface in natural_sort( config.get("management_interfaces", {}).keys() ):
          interface ${ management_interface }
          %     if config["management_interfaces"][management_interface].get("description"):
            description ${ config["management_interfaces"][management_interface]["description"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("shutdown") and config["management_interfaces"][management_interface]["shutdown"] is True:
             shutdown
          %     elif config["management_interfaces"][management_interface].get("shutdown") and config["management_interfaces"][management_interface]["shutdown"] is False:
             no shutdown
          %     endif
          %     if config["management_interfaces"][management_interface].get("vrf") and config["management_interfaces"][management_interface]["vrf"] != 'default':
             vrf ${ config["management_interfaces"][management_interface]["vrf"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("ip_address"):
             ip address ${ config["management_interfaces"][management_interface]["ip_address"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("ipv6_enable") is not None and config["management_interfaces"][management_interface]["ipv6_enable"] is True:
             ipv6 enable
          %     endif
          %     if config["management_interfaces"][management_interface].get("ipv6_address"):
             ipv6 address ${ config["management_interfaces"][management_interface]["ipv6_address"] }
          %     endif
          !
          % endfor
          ## eos - VLAN Interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown", False) == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown", True) == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface].get("vrf") != 'default':
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
             ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses", []):
             ip virtual-router address ${ ip_virtual_router_address }
          %     endfor
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
             ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ipv6_enable", False) is True:
             ipv6 enable
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ipv6_address"):
             ipv6 address ${ config["vlan_interfaces"][vlan_interface]["ipv6_address"] }
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ipv6_address_link_local"):
             ipv6 address ${ config["vlan_interfaces"][vlan_interface]["ipv6_address_link_local"] } link-local
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ipv6_address_virtual"):
             ipv6 address virtual ${ config["vlan_interfaces"][vlan_interface]["ipv6_address_virtual"] }
          %     endif
          %     for ipv6_address_virtual in natural_sort(config["vlan_interfaces"][vlan_interface].get("ipv6_address_virtuals", [])):
             ipv6 address virtual ${ ipv6_address_virtual }
          %     endfor
          %     for ipv6_virtual_router_address in natural_sort(config["vlan_interfaces"][vlan_interface].get("ipv6_virtual_router_addresses", [])):
             ipv6 virtual-router address ${ ipv6_virtual_router_address }
          %     endfor
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper]["source_interface"] %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ipv6_helpers") is not None:
          %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ipv6_helpers").keys():
          <%        ip_helper_cli = "ipv6 dhcp relay destination " + ip_helper %>
          %         if config.get("vlan_interfaces")[vlan_interface]["ipv6_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ipv6_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config.get("vlan_interfaces")[vlan_interface]["ipv6_helpers"][ip_helper].get("local_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " local-interface " + config.get("vlan_interfaces")[vlan_interface]["ipv6_helpers"][ip_helper]["local_interface"] %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ospf_area"):
             ip ospf area ${ config.get("vlan_interfaces")[vlan_interface]["ospf_area"] }
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ospf_cost"):
             ip ospf cost ${ config["vlan_interfaces"][vlan_interface]["ospf_cost"] }
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ospf_authentication") is not None:
          %         if config["vlan_interfaces"][vlan_interface]["ospf_authentication"] == "simple":
             ip ospf authentication
          %         elif config["vlan_interfaces"][vlan_interface]["ospf_authentication"] == "message-digest":
             ip ospf authentication message-digest
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ospf_authentication_key") is not None:
             ip ospf authentication-key 7 ${ config["vlan_interfaces"][vlan_interface]["ospf_authentication_key"] }
          %     endif
          %     for ospf_message_digest_key in natural_sort(config["vlan_interfaces"][vlan_interface].get("ospf_message_digest_keys", [])):
          %         if config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("hash_algorithm") is not None and config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("key") is not None:
             ip ospf message-digest-key ${ ospf_message_digest_key } ${ config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["hash_algorithm"] } 7 ${ config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["key"] }
          %         endif
          %     endfor
          %     if config["vlan_interfaces"][vlan_interface].get("pim"):
          %         if config["vlan_interfaces"][vlan_interface]["pim"]["ipv4"].get("sparse_mode", False) is True:
             pim ipv4 sparse-mode
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %         for cli_statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
             ${cli_statement}
          %         endfor
          %     endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["source_interface"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - tcam profile
          % if config.get("tcam_profile") is not None:
          hardware tcam
          %     if config["tcam_profile"].get("system") is not None:
             system profile ${ config["tcam_profile"]["system"] }
          %     endif
          !
          % endif
          ## eos - ip virtual router mac
          % if config.get("ip_virtual_router_mac_address") is not None:
          ip virtual-router mac-address ${ config["ip_virtual_router_mac_address"] }
          !
          % endif
          ## eos - IP Routing
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          ## eos - VRFs
          % if config.get('vrfs'):
          %   for vrf in config["vrfs"]:
          %       if config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % for static_route in config.get("static_routes", []):
          <%    static_route_cli = "ip route" %>
          %     if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%        static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %     endif
          %     if static_route.get("destination_address_prefix"):
          <%        static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %     endif
          %     if static_route.get("interface"):
          <%        static_route_cli = static_route_cli + " " + static_route["interface"] %>
          %     endif
          %     if static_route.get("gateway"):
          <%        static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %     endif
          %     if static_route.get("distance"):
          <%        static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %     endif
          %     if static_route.get("tag"):
          <%        static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %     endif
          %     if static_route.get("name"):
          <%        static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %     endif
          %     if static_route.get("metric"):
          <%        static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %     endif
          ${ static_route_cli }
          !
          %    endfor %}
          ## eos - Router Multicast
          % if config.get("router_multicast"):
          router multicast
          %     if config["router_multicast"].get("ipv4"):
             ipv4
          %         if config["router_multicast"]["ipv4"].get("routing"):
                routing
          %         endif
          %         if config["router_multicast"]["ipv4"].get("multipath"):
                multipath ${ config["router_multicast"]["ipv4"]["multipath"] }
          %         endif
          %         if config["router_multicast"]["ipv4"].get("software_forwarding"):
                software-forwarding ${ config["router_multicast"]["ipv4"]["software_forwarding"] }
          %         endif
          %     endif
          %     for vrf in natural_sort(config["router_multicast"].get("vrfs",[]), sort_key="name"):
          %         if vrf["name"] != "default":
             vrf ${ vrf["name"] }
          %             if vrf.get("ipv4"):
                ipv4
          %             endif
          %             if vrf["ipv4"].get("routing", False) is True:
                   routing
          %             endif
             !
          %         endif
          %     endfor
          !
          % endif
          ## eos - prefix-lists
          % if config.get("prefix_lists") is not None:
          %    for prefix_list in config["prefix_lists"].keys():
          ip prefix-list ${ prefix_list }
          %       for sequence in config["prefix_lists"][prefix_list]["sequence_numbers"].keys():
          %         if config["prefix_lists"][prefix_list]["sequence_numbers"][sequence].get("action") is not None:
             seq ${ sequence } ${ config["prefix_lists"][prefix_list]["sequence_numbers"][sequence]["action"] }
          %         endif
          %       endfor
          !
          %    endfor
          % endif
          ## eos - mlag configuration
          % if config.get("mlag_configuration") is not None and config["mlag_configuration"].get("enabled") == True:
          mlag configuration
          %     if config["mlag_configuration"].get("domain_id") is not None:
             domain-id ${ config["mlag_configuration"]["domain_id"] }
          %     endif
          %     if config["mlag_configuration"].get("local_interface") is not None:
             local-interface ${ config["mlag_configuration"]["local_interface"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address") is not None:
             peer-address ${ config["mlag_configuration"]["peer_address"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address_heartbeat") is not None:
          %       if config["mlag_configuration"]["peer_address_heartbeat"].get("peer_ip") is not None:
          %           if config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") is not None and config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") != 'default':
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] } vrf ${ config["mlag_configuration"]["peer_address_heartbeat"]["vrf"] }
          ## using the default VRF #}
          %           else:
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] }
          %           endif
          %       endif
          %     endif
          %     if config["mlag_configuration"].get("peer_link") is not None:
             peer-link ${ config["mlag_configuration"]["peer_link"] }
          %     endif
          %     if config["mlag_configuration"].get("dual_primary_detection_delay") is not None:
             dual-primary detection delay ${ config["mlag_configuration"]["dual_primary_detection_delay"] } action errdisable all-interfaces
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_mlag") is not None:
             reload-delay mlag ${ config["mlag_configuration"]["reload_delay_mlag"] }
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_non_mlag") is not None:
             reload-delay non-mlag ${ config["mlag_configuration"]["reload_delay_non_mlag"] }
          %     endif
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in config["route_maps"].keys():
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## eos - peer-filters
          % if config.get("peer_filters") is not None:
          %   for peer_filter in config["peer_filters"].keys():
          peer-filter ${ peer_filter }
          %     for sequence in config["peer_filters"][peer_filter]["sequence_numbers"].keys():
          %         if config["peer_filters"][peer_filter]["sequence_numbers"][sequence].get("match") is not None:
             ${ sequence } match ${ config["peer_filters"][peer_filter]["sequence_numbers"][sequence]["match"] }
          %         endif
          %     endfor
          !
          %   endfor
          % endif
          ## eos - Router bfd
          % if config.get("router_bfd") is not None and config.get("router_bfd") != {}:
          router bfd
          %   if config["router_bfd"].get("multihop") is not None:
          %     if config["router_bfd"]["multihop"].get("interval") is not None and config["router_bfd"]["multihop"].get("min_rx") is not None and config["router_bfd"]["multihop"].get("multiplier") is not None:
             multihop interval ${ config["router_bfd"]["multihop"]["interval"] } min-rx ${ config["router_bfd"]["multihop"]["min_rx"] } multiplier ${ config["router_bfd"]["multihop"]["multiplier"] }
          %     endif
          %   endif
          !
          % endif
          ## eos - Router BGP
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("maximum_paths"):
          <% max_paths_cli = "maximum-paths {} ".format(config["router_bgp"]["maximum_paths"]) %>
          %        if config["router_bgp"].get("ecmp"):
          <% max_paths_cli += "ecmp {}".format(config["router_bgp"]["ecmp"]) %>
                  % endif
             ${max_paths_cli}
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in natural_sort(config["router_bgp"]["neighbors"].keys()):
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
             neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
             neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          !
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].rd is not None:
                rd ${ config["router_bgp"]["vlans"][vlan].rd }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
                neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
             !
          % endif
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## router-ospf
          %if config.get("router_ospf") and config["router_ospf"].get("process_ids"):
          %for process_id in config["router_ospf"]["process_ids"].keys():
          %     if config["router_ospf"]["process_ids"][process_id].get("vrf"):
          router ospf ${ process_id } vrf ${ config["router_ospf"]["process_ids"][process_id]["vrf"] }
          %     else:
          router ospf ${ process_id }
          %     endif
          %     if config["router_ospf"]["process_ids"].get("log_adjacency_changes_detail"):
             log-adjacency-changes detail
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("router_id"):
             router-id ${ config["router_ospf"]["process_ids"][process_id]["router_id"] }
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("passive_interface_default"):
             passive-interface default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("no_passive_interfaces"):
          %         for interface in config["router_ospf"]["process_ids"][process_id]["no_passive_interfaces"]:
             no passive-interface ${ interface }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("network_prefixes"):
          %         for network_prefix in natural_sort(config["router_ospf"]["process_ids"][process_id]["network_prefixes"].keys()):
             network ${ network_prefix } area ${ config["router_ospf"]["process_ids"][process_id]["network_prefixes"][network_prefix]["area"] }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("bfd_enable"):
             bfd default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("ospf_defaults"):
          %         for ospf_default in config["router_ospf"]["process_ids"][process_id]["ospf_defaults"]:
             ${ospf_default}
          %         endfor
          %     endif
          !
          %endfor
          %endif
          ## router pim sparse mode
          % if config.get('router_pim_sparse_mode'):
          router pim sparse-mode
          %     if config["router_pim_sparse_mode"].get("ipv4"):
             ipv4
          %         if config["router_pim_sparse_mode"]["ipv4"].get("bfd", False) is True:
                bfd
          %         endif
          %         for rp_address in natural_sort(config["router_pim_sparse_mode"]["ipv4"].get("rp_addresses", {}).keys()):
          %             if len(config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address].get("groups", {})) > 0 or len(config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address].get("access_lists", {})) > 0:
          %                 if config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address].get("groups"):
          %                     for group in natural_sort(config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address]["groups"]):
                rp address ${ rp_address } ${ group }
          %                     endfor
          %                 endif
          %                 if config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address].get("access_lists"):
          %                     for access_list in natural_sort(config["router_pim_sparse_mode"]["ipv4"]['rp_addresses'][rp_address]["access_lists"]):
                rp address ${ rp_address } access-list ${ access_list }
          %                     endfor
          %                 endif
          %             else:
                rp address ${ rp_address }
          %             endif
          %         endfor
             !
          %     endif
          %     for vrf in natural_sort(config["router_pim_sparse_mode"].get("vrfs", []), sort_key="name"):
             vrf ${ vrf["name"] }
          %         if vrf.get("ipv4"):
                ipv4
          %             if vrf.get("bfd", False) is True:
                   bfd
          %             endif
          %             for rp_address in natural_sort(vrf["ipv4"].get("rp_addresses", {}).keys()):
          %                 if len(vrf["ipv4"]['rp_addresses'][rp_address].get("groups", [])) > 0 or len(vrf["ipv4"]['rp_addresses'][rp_address].get("access_lists", [])) > 0:
          %                     if vrf["ipv4"]['rp_addresses'][rp_address].get("groups"):
          %                         for group in natural_sort(vrf["ipv4"]['rp_addresses'][rp_address]["groups"]):
                   rp address ${ rp_address } ${ group }
          %                         endfor
          %                     endif
          %                     if vrf["ipv4"]['rp_addresses'][rp_address].get("access_lists"):
          %                         for access_list in natural_sort(vrf["ipv4"]['rp_addresses'][rp_address]["access_lists"]):
                   rp address ${ rp_address } access-list ${ access_list }
          %                         endfor
          %                     endif
          %                 else:
                   rp address ${ rp_address }
          %                 endif
          %             endfor
          %         endif
             !
          %     endfor
          % endif
          <% ctx.info(f"Time taken to run studio: {time.time() - start_time} seconds") %>
      input_schema:
        fields:
          values:
            campusPodRouterIdPool:
              id: campusPodRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each leaf's Loopback0 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodUplinkIpv4Pool:
              id: campusPodUplinkIpv4Pool
              name: uplinkIpv4Pool
              label: Uplink Ipv4 Pool
              description: IPv4 subnet to use to connect to uplink switches
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerVlan:
              id: leafMlagPeerVlan
              name: mlagPeerVlan
              label: MLAG Peer VLAN
              description: MLAG Peer Link (control link) SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            leafMlagPeerIPv4Pool:
              id: leafMlagPeerIPv4Pool
              name: mlagPeerIPv4Pool
              label: MLAG Peer IPv4 Pool
              description: IP address pool used for MLAG Peer Link (control link)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 169.254.0.0/31
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerL3Vlan:
              id: leafMlagPeerL3Vlan
              name: mlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: Underlay L3 peering SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            leafMlagPeerL3IPv4Pool:
              id: leafMlagPeerL3IPv4Pool
              name: mlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IP address pool used for MLAG underlay L3 peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafVirtualRouterMacAddress:
              id: leafVirtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Virtual router mac address for anycast gateway
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfaceName:
              id: leafMlagPeerInterfaceName
              name: mlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfaces:
              id: leafMlagPeerInterfaces
              name: mlagPeerInterfaces
              label: MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the primary and secondary leaf in this Campus Pod.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafMlagPeerInterfaceName
                key: ''
            leafMlagPeerInterfacesSpeed:
              id: leafMlagPeerInterfacesSpeed
              name: mlagPeerInterfacesSpeed
              label: MLAG Peer Interfaces Speed
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: auto
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfacesCliStatement:
              id: leafMlagPeerInterfacesCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfacesEosCli:
              id: leafMlagPeerInterfacesEosCli
              name: mlagPeerInterfacesEosCli
              label: MLAG Peer Interfaces EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafMlagPeerInterfacesCliStatement
                key: ''
            leafMlagPeerLinkCliStatement:
              id: leafMlagPeerLinkCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerLinkEosCli:
              id: leafMlagPeerLinkEosCli
              name: mlagPeerLinkEosCli
              label: MLAG Peer Link EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafMlagPeerLinkCliStatement
                key: ''
            leafMlagDetails:
              id: leafMlagDetails
              name: mlagDetails
              label: MLAG Details
              description: MLAG settings to be applied on leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafMlagPeerVlan
                    - leafMlagPeerIPv4Pool
                    - leafMlagPeerL3Vlan
                    - leafMlagPeerL3IPv4Pool
                    - leafVirtualRouterMacAddress
                    - leafMlagPeerInterfaces
                    - leafMlagPeerInterfacesSpeed
                    - leafMlagPeerInterfacesEosCli
                    - leafMlagPeerLinkEosCli
            campusPodSpanningTreeMode:
              id: campusPodSpanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - MSTP
                    - Rapid-PVST
                    - RSTP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafSpanningTreePriority:
              id: leafSpanningTreePriority
              name: leafSpanningTreePriority
              label: Leaf Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, uses EOS default. If no value is entered and L3 is selected for Campus Type, defaults to 4096.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            memberLeafSpanningTreePriority:
              id: memberLeafSpanningTreePriority
              name: memberLeafSpanningTreePriority
              label: Member Leaf Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, uses EOS default.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            campusPodSpanningTreeDetails:
              id: campusPodSpanningTreeDetails
              name: spanningTreeDetails
              label: Spanning Tree Details
              description: Spanning tree settings to be applied on Campus Pod switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodSpanningTreeMode
                    - leafSpanningTreePriority
                    - memberLeafSpanningTreePriority
            leafVtepLoopbackIPv4Pool:
              id: leafVtepLoopbackIPv4Pool
              name: vtepLoopbackIPv4Pool
              label: VTEP Loopback IPv4 Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each leaf's Loopback1 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpAsRange:
              id: campusPodBgpAsRange
              name: bgpAsns
              label: BGP AS Range
              description: Define the ASN range from which BGP ASNs are allocated to each Campus Pod's primary and secondary leaf switch.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaultsConfigStatement:
              id: campusPodBgpDefaultsConfigStatement
              name: bgpDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaults:
              id: campusPodBgpDefaults
              name: bgpDefaults
              label: BGP Defaults
              description: Configure additional commands under the 'router bgp' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodBgpDefaultsConfigStatement
                key: ''
            leafBgpDetails:
              id: leafBgpDetails
              name: bgpDetails
              label: BGP Details
              description: BGP settings to be applied on Leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodBgpAsRange
                    - campusPodBgpDefaults
            leafOspfDefaultsConfigStatement:
              id: leafOspfDefaultsConfigStatement
              name: ospfDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafOspfDefaults:
              id: leafOspfDefaults
              name: ospfDefaults
              label: OSPF Defaults
              description: Configure additional commands under the 'router ospf <process-id>' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafOspfDefaultsConfigStatement
                key: ''
            leafOspfDetails:
              id: leafOspfDetails
              name: ospfDetails
              label: OSPF Details
              description: OSPF settings to be applied on Leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafOspfDefaults
            campusPodDefaultsLeafUplinkInterfacesSpeed:
              id: campusPodDefaultsLeafUplinkInterfacesSpeed
              name: leafUplinkInterfacesSpeed
              label: Leaf Uplink Interfaces Speed
              description: Speed will apply to switch interfaces on both ends of uplinks.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: auto
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodDefaultsMemberLeafUplinkInterfacesSpeed:
              id: campusPodDefaultsMemberLeafUplinkInterfacesSpeed
              name: memberLeafUplinkInterfacesSpeed
              label: Member-Leaf Uplink Interfaces Speed
              description: Speed will apply to switch interfaces on both ends of uplinks.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: auto
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinksCliStatement:
              id: leafUplinksCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinksEosCli:
              id: leafUplinksEosCli
              name: leafUplinksEosCli
              label: Leaf Uplinks EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafUplinksCliStatement
                key: ''
            memberLeafUplinksCliStatement:
              id: memberLeafUplinksCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinksEosCli:
              id: memberLeafUplinksEosCli
              name: memberLeafUplinksEosCli
              label: Member-Leaf Uplinks EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: memberLeafUplinksCliStatement
                key: ''
            campusPodUplinkInterfaceDetails:
              id: campusPodUplinkInterfaceDetails
              name: uplinkInterfaceDetails
              label: Uplink Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodDefaultsLeafUplinkInterfacesSpeed
                    - campusPodDefaultsMemberLeafUplinkInterfacesSpeed
                    - leafUplinksEosCli
                    - memberLeafUplinksEosCli
            leafPtpPriority1:
              id: leafPtpPriority1
              name: leafPriority1
              label: Leaf PTP Priority 1
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '30'
                range: null
                static_options: null
                dynamic_options: null
            memberLeafPtpPriority1:
              id: memberLeafPtpPriority1
              name: memberLeafPriority1
              label: Member Leaf PTP Priority 1
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '127'
                range: null
                static_options: null
                dynamic_options: null
            campusPodPtpClockIdentityPrefix:
              id: campusPodPtpClockIdentityPrefix
              name: ptpClockIdentityPrefix
              label: PTP Clock Identity Prefix
              description: The PTP clock identity is generated and set automatically using the formula < (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as HEX) >.  Customize the PTP clock identity by modifying Clock Identity Prefix.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1C:73
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodPtpAutoClockIdentity:
              id: campusPodPtpAutoClockIdentity
              name: autoClockIdentity
              label: Auto Clock Identity
              description: Enable to set a custom PTP clock identity.  If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the default EOS behavior, disable the automatic PTP clock identity.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            campusPodPtpDetails:
              id: campusPodPtpDetails
              name: ptpDetails
              label: PTP Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafPtpPriority1
                    - memberLeafPtpPriority1
                    - campusPodPtpClockIdentityPrefix
                    - campusPodPtpAutoClockIdentity
            campusPodDefaults:
              id: campusPodDefaults
              name: campusPodDefaults
              label: Campus Pod Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodRouterIdPool
                    - campusPodUplinkIpv4Pool
                    - leafMlagDetails
                    - campusPodSpanningTreeDetails
                    - leafVtepLoopbackIPv4Pool
                    - leafBgpDetails
                    - leafOspfDetails
                    - campusPodUplinkInterfaceDetails
                    - campusPodPtpDetails
            splineRouterIdPool:
              id: splineRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each spline's Loopback0 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineSpanningTreeMode:
              id: splineSpanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - RSTP
                    - MSTP
                    - Rapid-PVST
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineSpanningTreePriority:
              id: splineSpanningTreePriority
              name: splineSpanningTreePriority
              label: Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, defaults to 4096. If no value is entered and L3 is selected for Campus Type, uses EOS default.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            splineSpanningTreeDetails:
              id: splineSpanningTreeDetails
              name: spanningTreeDetails
              label: Spanning Tree Details
              description: Spanning tree settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineSpanningTreeMode
                    - splineSpanningTreePriority
            splineMlagPeerVlan:
              id: splineMlagPeerVlan
              name: mlagPeerVlan
              label: MLAG Peer VLAN
              description: MLAG Peer Link (control link) SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            splineMlagPeerIPv4Pool:
              id: splineMlagPeerIPv4Pool
              name: mlagPeerIPv4Pool
              label: MLAG Peer IPv4 Pool
              description: IP address pool used for MLAG Peer Link (control link)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 169.254.0.0/31
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerL3Vlan:
              id: splineMlagPeerL3Vlan
              name: mlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: Underlay L3 peering SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            splineMlagPeerL3IPv4Pool:
              id: splineMlagPeerL3IPv4Pool
              name: mlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IP address pool used for MLAG underlay L3 peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineVirtualRouterMacAddress:
              id: splineVirtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Virtual router mac address for anycast gateway
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfaceName:
              id: splineMlagPeerInterfaceName
              name: mlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfaces:
              id: splineMlagPeerInterfaces
              name: mlagPeerInterfaces
              label: MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the splines.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineMlagPeerInterfaceName
                key: ''
            splineMlagPeerInterfacesSpeed:
              id: splineMlagPeerInterfacesSpeed
              name: mlagPeerInterfacesSpeed
              label: MLAG Peer Interfaces Speed
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: auto
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfacesCliStatement:
              id: splineMlagPeerInterfacesCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfacesEosCli:
              id: splineMlagPeerInterfacesEosCli
              name: mlagPeerInterfacesEosCli
              label: MLAG Peer Interfaces EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineMlagPeerInterfacesCliStatement
                key: ''
            splineMlagPeerLinkCliStatement:
              id: splineMlagPeerLinkCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerLinkEosCli:
              id: splineMlagPeerLinkEosCli
              name: mlagPeerLinkEosCli
              label: MLAG Peer Link EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineMlagPeerLinkCliStatement
                key: ''
            splineMlagDetails:
              id: splineMlagDetails
              name: mlagDetails
              label: MLAG Details
              description: MLAG settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineMlagPeerVlan
                    - splineMlagPeerIPv4Pool
                    - splineMlagPeerL3Vlan
                    - splineMlagPeerL3IPv4Pool
                    - splineVirtualRouterMacAddress
                    - splineMlagPeerInterfaces
                    - splineMlagPeerInterfacesSpeed
                    - splineMlagPeerInterfacesEosCli
                    - splineMlagPeerLinkEosCli
            splineVtepLoopbackIPv4Pool:
              id: splineVtepLoopbackIPv4Pool
              name: vtepLoopbackIPv4Pool
              label: VTEP Loopback IPv4 Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each spline's Loopback1 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpAsn:
              id: splineBgpAsn
              name: bgpAsns
              label: BGP ASN
              description: BGP AS assigned to spline switches
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaultsConfigStatement:
              id: splineBgpDefaultsConfigStatement
              name: bgpDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaults:
              id: splineBgpDefaults
              name: bgpDefaults
              label: BGP Defaults
              description: Configure additional commands under the 'router bgp' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineBgpDefaultsConfigStatement
                key: ''
            splineBgpDetails:
              id: splineBgpDetails
              name: bgpDetails
              label: BGP Details
              description: BGP settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineBgpAsn
                    - splineBgpDefaults
            splineOspfDefaultsConfigStatement:
              id: splineOspfDefaultsConfigStatement
              name: ospfDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineOspfDefaults:
              id: splineOspfDefaults
              name: ospfDefaults
              label: OSPF Defaults
              description: Configure additional commands under the 'router ospf <process-id>' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineOspfDefaultsConfigStatement
                key: ''
            splineOspfDetails:
              id: splineOspfDetails
              name: ospfDetails
              label: OSPF Details
              description: OSPF settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineOspfDefaults
            splinesPtpPriority1:
              id: splinesPtpPriority1
              name: priority1
              label: Priority 1
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '20'
                range: null
                static_options: null
                dynamic_options: null
            splinesPtpAutoClockIdentity:
              id: splinesPtpAutoClockIdentity
              name: autoClockIdentity
              label: Auto Clock Identity
              description: Enable to set a custom PTP clock identity.  If you prefer to have PTP clock identity be the system MAC-address of the switch, which is the default EOS behavior, disable the automatic PTP clock identity.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            splinesPtpClockIdentityPrefix:
              id: splinesPtpClockIdentityPrefix
              name: ptpClockIdentityPrefix
              label: PTP Clock Identity Prefix
              description: The PTP clock identity is generated and set automatically using the formula < (clock_identity_prefix = 00:1C:73 (default)) + (PTP priority 1 as HEX) + ":00:" + (PTP priority 2 as HEX) >.  Customize the PTP clock identity by modifying Clock Identity Prefix.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1C:73
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splinesPtpDetails:
              id: splinesPtpDetails
              name: ptpDetails
              label: PTP Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splinesPtpPriority1
                    - splinesPtpAutoClockIdentity
                    - splinesPtpClockIdentityPrefix
            splineDefaults:
              id: splineDefaults
              name: splineDefaults
              label: Spline Defaults
              description: Set parameters which will be used to generate configuration across all spline switches in this building.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineRouterIdPool
                    - splineSpanningTreeDetails
                    - splineMlagDetails
                    - splineVtepLoopbackIPv4Pool
                    - splineBgpDetails
                    - splineOspfDetails
                    - splinesPtpDetails
            podId:
              id: podId
              name: podId
              label: Pod ID
              description: Used as an index for certain inputs defined under the Campus Pod Defaults section.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            leafUplinkInterfaceName:
              id: leafUplinkInterfaceName
              name: uplinkInterface
              label: Leaf Interface
              description: Leaf switch's uplink interface to spline. For example, `Ethernet 27`.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkHostname:
              id: leafUplinkHostname
              name: hostname
              label: Leaf Hostname
              description: Hostname of the Leaf
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkSplineHostname:
              id: leafUplinkSplineHostname
              name: uplinkSwitchHostname
              label: Spline Hostname
              description: Upstream spline switch's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkSplineInterface:
              id: leafUplinkSplineInterface
              name: uplinkSwitchInterface
              label: Spline Interface
              description: Upstream spline switch's interface connecting to the leaf switch.  For example, `Ethernet 1`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkInterfaceDetails:
              id: leafUplinkInterfaceDetails
              name: leafUplinkInterfaceDetails
              label: Leaf Uplink Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafUplinkInterfaceName
                    - leafUplinkHostname
                    - leafUplinkSplineHostname
                    - leafUplinkSplineInterface
            leafUplinkInterfaces:
              id: leafUplinkInterfaces
              name: leafUplinkInterfaces
              label: Leaf Uplink Interfaces
              description: Define the links the Leaf switches will use to connect to the upstream Spline switches.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafUplinkInterfaceDetails
                key: ''
            memberLeafUplinkInterfaceName:
              id: memberLeafUplinkInterfaceName
              name: uplinkInterface
              label: Interface Name
              description: Member Leaf switch's uplink interface to Leaf. For example, `Ethernet 27`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkHostname:
              id: memberLeafUplinkHostname
              name: hostname
              label: Member-Leaf Hostname
              description: Member Leaf's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkLeafHostname:
              id: memberLeafUplinkLeafHostname
              name: uplinkSwitchHostname
              label: Leaf Hostname
              description: Upstream leaf switch's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkLeafInterface:
              id: memberLeafUplinkLeafInterface
              name: uplinkSwitchInterface
              label: Leaf Interface
              description: Upstream leaf switch's interface connecting to the member-leaf switch.  For example, `Ethernet 1`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkInterfaceDetails:
              id: memberLeafUplinkInterfaceDetails
              name: memberLeafUplinkInterfaceDetails
              label: Member Leaf Uplink Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - memberLeafUplinkInterfaceName
                    - memberLeafUplinkHostname
                    - memberLeafUplinkLeafHostname
                    - memberLeafUplinkLeafInterface
            memberLeafUplinkInterfaces:
              id: memberLeafUplinkInterfaces
              name: memberLeafUplinkInterfaces
              label: Member Leaf Uplink Interfaces
              description: Define the links the Member-Leaf switches will use to connect to the upstream Leaf switches in the Campus Pod.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: memberLeafUplinkInterfaceDetails
                key: ''
            campusPodMlagPeerInterfaceName:
              id: campusPodMlagPeerInterfaceName
              name: campusPodMlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodMlagPeerInterfaces:
              id: campusPodMlagPeerInterfaces
              name: campusPodMlagPeerInterfaces
              label: Leaf MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the primary and secondary leaf in this Campus Pod. Note that this will override any MLAG peer interfaces defined under the Campus Pod Defaults MLAG Details section.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodMlagPeerInterfaceName
                key: ''
            displayPodFabricInterfaceInputsToggle:
              id: displayPodFabricInterfaceInputsToggle
              name: displayPodFabricInterfaceInputs
              label: Define Campus Pod topology
              description: Toggle on to display fields which allow users to define interface connections at the Campus Pod level, overriding the topology's interface connections defined in the Inventory & Topology studio.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            campusPodHideShowTogglesGroup:
              id: campusPodHideShowTogglesGroup
              name: hideShowToggles
              label: Hide/Show Toggles
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - displayPodFabricInterfaceInputsToggle
            podInbandManagementIpv4Range:
              id: podInbandManagementIpv4Range
              name: podInbandManagementIpv4Range
              label: Inband Management IP Allocation Range
              description: Enter the IP range from which to allocate inband management IP addresses from.  This range should fall within the larger Inband Management Subnet Pool defined in the Inband Management Details section of Campus Pod Defaults.  For example, if the Inband Management subnet is 192.168.0.0/24, a valid range of IP addresses would be 192.168.0.4-192.168.12.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            podInbandManagementGroup:
              id: podInbandManagementGroup
              name: inbandManagementDetails
              label: Inband Management Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - podInbandManagementIpv4Range
            campusPodFacts:
              id: campusPodFacts
              name: campusPodFacts
              label: Campus Pod Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - podId
                    - leafUplinkInterfaces
                    - memberLeafUplinkInterfaces
                    - campusPodMlagPeerInterfaces
                    - campusPodHideShowTogglesGroup
                    - podInbandManagementGroup
            campusPods:
              id: campusPods
              name: campusPods
              label: Campus Pods
              description: A Campus Pod is a group of switches that acts as an IDF. Create Campus-Pods and define how the switches in the Campus Pod should be connected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusPodFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            allowAllVlansOnTrunkToggle:
              id: allowAllVlansOnTrunkToggle
              name: allowAllVLANs
              label: Allow All VLANs
              description: Allow all VLANs on trunk interfaces or only necessary VLANs based on what services are applied to switches.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviVrf:
              id: vlanCampusSviVrf
              name: vrf
              label: VRF
              description: VRF this VLAN will be configured in.  If no value is selected, VLAN will be put in the default VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusSviEnabled:
              id: l2CampusSviEnabled
              name: sviEnabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            l2CampusSviIpv6VirtualRouterAddress:
              id: l2CampusSviIpv6VirtualRouterAddress
              name: ipv6VirtualRouterAddress
              label: IPv6 Virtual Router Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusPrimarySplineSviIpv6Address:
              id: l2CampusPrimarySplineSviIpv6Address
              name: primarySwitchSviIpv6Address
              label: Primary Spline IPv6 SVI IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusSecondarySplineSviIpv6Address:
              id: l2CampusSecondarySplineSviIpv6Address
              name: secondarySwitchSviIpv6Address
              label: Secondary Spline IPv6 SVI IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusSviIpv6Addressing:
              id: l2CampusSviIpv6Addressing
              name: ipv6Addressing
              label: IPv6 Addressing
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l2CampusSviIpv6VirtualRouterAddress
                    - l2CampusPrimarySplineSviIpv6Address
                    - l2CampusSecondarySplineSviIpv6Address
            l2CampusSviIpVirtualRouterAddress:
              id: l2CampusSviIpVirtualRouterAddress
              name: sviIpVirtualRouterAddress
              label: IP Virtual Router Address
              description: Virtual IP address for SVI shared between splines to enable VARP.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusPrimarySplineSviIpAddress:
              id: l2CampusPrimarySplineSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Spline SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to primary spline.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusSecondarySplineSviIpAddress:
              id: l2CampusSecondarySplineSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Spline SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to secondary spline.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviGroup:
              id: vlanCampusSviGroup
              name: sviDetails
              label: VLAN Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanCampusSviVrf
                    - l2CampusSviEnabled
                    - l2CampusSviIpv6Addressing
                    - l2CampusSviIpVirtualRouterAddress
                    - l2CampusPrimarySplineSviIpAddress
                    - l2CampusSecondarySplineSviIpAddress
            vlanDhcpHelpersServer:
              id: vlanDhcpHelpersServer
              name: dhcpServer
              label: DHCP Server
              description: IP Address or FQDN of DHCP server
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersSourceInterface:
              id: vlanDhcpHelpersSourceInterface
              name: dhcpSourceInterface
              label: DHCP Source Interface
              description: Interface to source DHCP requests from
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersGroup:
              id: vlanDhcpHelpersGroup
              name: dhcpHelperDetails
              label: DHCP Helper Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpHelpersServer
                    - vlanDhcpHelpersSourceInterface
            vlanDhcpHelpers:
              id: vlanDhcpHelpers
              name: dhcpHelpers
              label: DHCP Helpers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpHelpersGroup
                key: ''
            vlanName:
              id: vlanName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusSviIpVirtualRouterAddress:
              id: l3CampusSviIpVirtualRouterAddress
              name: sviIpVirtualRouterAddress
              label: IP Virtual Router Address
              description: Virtual IP address for SVI shared between primary and secondary leaf to enable VARP.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            l3CampusPrimaryLeafSviIpAddress:
              id: l3CampusPrimaryLeafSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Leaf SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to primary leaf.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusSecondaryLeafSviIpAddress:
              id: l3CampusSecondaryLeafSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Leaf SVI IP Address
              description: 'IP address (in CIDR notation) for SVI assigned to secondary leaf. If no value is entered, IP address will be allocated automatically based on virtual IP address. '
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusVlanName:
              id: l3CampusVlanName
              name: name
              label: Name
              description: If no value is entered, the value entered in the Name field below will be used.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodGroup:
              id: vlansCampusPodGroup
              name: podDetails
              label: Pod Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l3CampusSviIpVirtualRouterAddress
                    - l3CampusPrimaryLeafSviIpAddress
                    - l3CampusSecondaryLeafSviIpAddress
                    - l3CampusVlanName
            vlansCampusPodResolver:
              id: vlansCampusPodResolver
              name: campusPod
              label: Campus Pods
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlansCampusPodGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            vlanSviEosCliStatement:
              id: vlanSviEosCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCli:
              id: vlanSviEosCli
              name: eosCli
              label: EOS CLI
              description: Raw CLI to be applied on SVI
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviEosCliStatement
                key: ''
            vlanStpPrioritySpline:
              id: vlanStpPrioritySpline
              name: vlanStpPrioritySpline
              label: Spline STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            vlanStpPriorityLeaf:
              id: vlanStpPriorityLeaf
              name: vlanStpPriorityLeaf
              label: Leaf STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanStpPriorityMemberLeaf:
              id: vlanStpPriorityMemberLeaf
              name: vlanStpPriorityMemberLeaf
              label: Member Leaf STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSpanningTreeDetails:
              id: vlanSpanningTreeDetails
              name: vlanSpanningTreeDetails
              label: VLAN Spanning Tree Details
              description: Edit any of the default spanning tree settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanStpPrioritySpline
                    - vlanStpPriorityLeaf
                    - vlanStpPriorityMemberLeaf
            sviOspfEnabled:
              id: sviOspfEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            sviOspfPointToPoint:
              id: sviOspfPointToPoint
              name: pointToPoint
              label: Point-to-Point Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            sviOspfArea:
              id: sviOspfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfCost:
              id: sviOspfCost
              name: cost
              label: Cost
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            sviOspfAuthentication:
              id: sviOspfAuthentication
              name: authentication
              label: Authentication
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Simple
                    - Message-Digest
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfSimpleAuthKey:
              id: sviOspfSimpleAuthKey
              name: simpleAuthKey
              label: Simple Auth Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfHashAlgorithm:
              id: sviOspfHashAlgorithm
              name: hashAlgorithm
              label: Hash Algorithm
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: sha512
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfKey:
              id: sviOspfKey
              name: key
              label: Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfKeyId:
              id: sviOspfKeyId
              name: id
              label: ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            sviOspfMessageDigestKeysDetails:
              id: sviOspfMessageDigestKeysDetails
              name: sviOspfMessageDigestKeysDetails
              label: Message Digest Keys Group
              description: Group of members for messageDigestKeys
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - sviOspfHashAlgorithm
                    - sviOspfKey
                    - sviOspfKeyId
            sviOspfMessageDigestKeys:
              id: sviOspfMessageDigestKeys
              name: messageDigestKeys
              label: Message Digest Keys
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: sviOspfMessageDigestKeysDetails
                key: ''
            sviOspfPassive:
              id: sviOspfPassive
              name: passive
              label: Passive Interface
              description: Enable to make the SVI a passive interface
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            sviOspfConfiguration:
              id: sviOspfConfiguration
              name: sviOspfConfiguration
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - sviOspfEnabled
                    - sviOspfPointToPoint
                    - sviOspfArea
                    - sviOspfCost
                    - sviOspfAuthentication
                    - sviOspfSimpleAuthKey
                    - sviOspfMessageDigestKeys
                    - sviOspfPassive
            sviPimEnabled:
              id: sviPimEnabled
              name: pim
              label: PIM
              description: Enable PIM sparse mode
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            sviMulticast:
              id: sviMulticast
              name: multicast
              label: Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - sviPimEnabled
            vlansDetails:
              id: vlansDetails
              name: vlanDetails
              label: VLAN Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanCampusSviGroup
                    - vlanDhcpHelpers
                    - vlanName
                    - vlansCampusPodResolver
                    - vlanSviEosCli
                    - vlanSpanningTreeDetails
                    - sviOspfConfiguration
                    - sviMulticast
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: Configure VLANs on switches at this building
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlansDetails
                key: vlanId
            buildingServices:
              id: buildingServices
              name: services
              label: Services
              description: Create and assign services to switches in this building.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - allowAllVlansOnTrunkToggle
                    - vlans
            campusType:
              id: campusType
              name: campusType
              label: Campus Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - L3
                    - L2
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineEvpnRoleDefault:
              id: splineEvpnRoleDefault
              name: splineEvpnRoleDefault
              label: EVPN Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Server
                    - Client
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagSupportDefault:
              id: splineMlagSupportDefault
              name: splineMlagSupportDefault
              label: MLAG Support
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineVtepDefault:
              id: splineVtepDefault
              name: splineVtepDefault
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineConnectedEndpointsDefault:
              id: splineConnectedEndpointsDefault
              name: splineConnectedEndpointsDefault
              label: Connected Endpoints
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL2NetworkServicesDefault:
              id: splineL2NetworkServicesDefault
              name: splineL2NetworkServicesDefault
              label: L2 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL3NetworkServicesDefault:
              id: splineL3NetworkServicesDefault
              name: splineL3NetworkServicesDefault
              label: L3 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultSplineProperties:
              id: defaultSplineProperties
              name: defaultSplineProperties
              label: Default Spline Properties
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineEvpnRoleDefault
                    - splineMlagSupportDefault
                    - splineVtepDefault
                    - splineConnectedEndpointsDefault
                    - splineL2NetworkServicesDefault
                    - splineL3NetworkServicesDefault
            leafEvpnRoleDefault:
              id: leafEvpnRoleDefault
              name: leafEvpnRoleDefault
              label: EVPN Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Server
                    - Client
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagSupport:
              id: leafMlagSupport
              name: leafMlagSupport
              label: MLAG Support
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafVtepDefault:
              id: leafVtepDefault
              name: leafVtepDefault
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafConnectedEndpointsDefault:
              id: leafConnectedEndpointsDefault
              name: leafConnectedEndpointsDefault
              label: Connected Endpoints
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafL2NetworkServicesDefault:
              id: leafL2NetworkServicesDefault
              name: leafL2NetworkServicesDefault
              label: L2 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafL3NetworkServicesDefault:
              id: leafL3NetworkServicesDefault
              name: leafL3NetworkServicesDefault
              label: L3 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultLeafProperties:
              id: defaultLeafProperties
              name: defaultLeafProperties
              label: Default Leaf Properties
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafEvpnRoleDefault
                    - leafMlagSupport
                    - leafVtepDefault
                    - leafConnectedEndpointsDefault
                    - leafL2NetworkServicesDefault
                    - leafL3NetworkServicesDefault
            nodeTypeProperties:
              id: nodeTypeProperties
              name: nodeTypeProperties
              label: Node Type Properties
              description: Customize role properties for switches in this building.  Set fields to None to use defaults.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - defaultSplineProperties
                    - defaultLeafProperties
            buildingUnderlayRoutingProtocol:
              id: buildingUnderlayRoutingProtocol
              name: buildingUnderlayRoutingProtocol
              label: Underlay Routing Protocol
              description: Set the routing protocol used for underlay connectivity for this building.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: BGP
                static_options:
                  values:
                    - BGP
                    - OSPF
                format: null
                length: null
                pattern: null
                dynamic_options: null
            buildingOverlayRoutingProtocol:
              id: buildingOverlayRoutingProtocol
              name: buildingOverlayRoutingProtocol
              label: Overlay Routing Protocol
              description: Set the routing protocol used for the overlay connectivity for this building.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - BGP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            buildingRoutingProtocols:
              id: buildingRoutingProtocols
              name: buildingRoutingProtocols
              label: Routing Protocols
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingUnderlayRoutingProtocol
                    - buildingOverlayRoutingProtocol
            ospfProcessId:
              id: ospfProcessId
              name: processId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '100'
                range: null
                static_options: null
                dynamic_options: null
            ospfArea:
              id: ospfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            ospfMaxLsa:
              id: ospfMaxLsa
              name: maxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '12000'
                range: null
                static_options: null
                dynamic_options: null
            ospfBfdKnob:
              id: ospfBfdKnob
              name: bfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            ospfConfiguration:
              id: ospfConfiguration
              name: ospfDetails
              label: OSPF
              description: Underlay OSFP fabric settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ospfProcessId
                    - ospfArea
                    - ospfMaxLsa
                    - ospfBfdKnob
            mstInstanceId:
              id: mstInstanceId
              name: mstInstanceId
              label: Instance ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mstInstanceSplineStpPriority:
              id: mstInstanceSplineStpPriority
              name: mstInstanceSplineStpPriority
              label: Spline Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            mstInstanceLeafStpPriority:
              id: mstInstanceLeafStpPriority
              name: mstInstanceLeafStpPriority
              label: Leaf Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            mstInstanceMemberLeafStpPriority:
              id: mstInstanceMemberLeafStpPriority
              name: mstInstanceMemberLeafStpPriority
              label: Member Leaf Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '4096'
                    - '8192'
                    - '12288'
                    - '16384'
                    - '20480'
                    - '24576'
                    - '28672'
                    - '32768'
                    - '36864'
                    - '40960'
                    - '45056'
                    - '49152'
                    - '53248'
                    - '57344'
                    - '61440'
                dynamic_options: null
            mstInstanceVlans:
              id: mstInstanceVlans
              name: mstInstanceVlans
              label: VLANs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mstInstanceDetails:
              id: mstInstanceDetails
              name: mstInstanceDetails
              label: MST Instance Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - mstInstanceId
                    - mstInstanceSplineStpPriority
                    - mstInstanceLeafStpPriority
                    - mstInstanceMemberLeafStpPriority
                    - mstInstanceVlans
            mstInstances:
              id: mstInstances
              name: mstInstances
              label: MST Instances
              description: MST instances settings
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: mstInstanceDetails
                key: mstInstanceId
            l2CampusInbandManagementVlan:
              id: l2CampusInbandManagementVlan
              name: inbandManagementVlan
              label: Inband Management VLAN
              description: VLAN number assigned to Inband Management SVI in default VRF
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            l2CampusInbandManagementSubnet:
              id: l2CampusInbandManagementSubnet
              name: inbandManagementSubnet
              label: Inband Management Subnet
              description: Assign a range larger than total leafs + 5
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusInbandManagementDhcpServer:
              id: l2CampusInbandManagementDhcpServer
              name: dhcpServer
              label: DHCP Server
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusInbandManagementIpHelperAddressesDetails:
              id: l2CampusInbandManagementIpHelperAddressesDetails
              name: ipHelperAddressesDetails
              label: IP Helper Addresses Details
              description: Group of members for IP Helper Addresses
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l2CampusInbandManagementDhcpServer
            l2CampusInbandManagementIpHelperAddresses:
              id: l2CampusInbandManagementIpHelperAddresses
              name: ipHelperAddresses
              label: IP Helper Addresses
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: l2CampusInbandManagementIpHelperAddressesDetails
                key: ''
            l2CampusInbandManagementVrf:
              id: l2CampusInbandManagementVrf
              name: inbandManagementVrf
              label: Inband Management VRF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: default
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusInbandManagementDetails:
              id: l2CampusInbandManagementDetails
              name: inbandManagementDetails
              label: Inband Management
              description: Inband Management settings used for Campus Pod switches.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l2CampusInbandManagementVlan
                    - l2CampusInbandManagementSubnet
                    - l2CampusInbandManagementIpHelperAddresses
                    - l2CampusInbandManagementVrf
            buildingUnderlayMulticast:
              id: buildingUnderlayMulticast
              name: underlayMulticast
              label: Underlay Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            buildingStaticRpIpAddress:
              id: buildingStaticRpIpAddress
              name: ipAddress
              label: IP Address
              description: IP address of the rendezvous point
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            buildingStaticRpGroupAddress:
              id: buildingStaticRpGroupAddress
              name: groupAddress
              label: Group Address
              description: Group address range with prefix.  If no group address range is provided, the RP will be configured for all groups.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            buildingStaticRpInfo:
              id: buildingStaticRpInfo
              name: rpInfo
              label: RP Info
              description: Rendezvous point
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingStaticRpIpAddress
                    - buildingStaticRpGroupAddress
            buildingStaticRps:
              id: buildingStaticRps
              name: rps
              label: RPs
              description: Define static rendezvous points that will be configured on all L3 devices.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: buildingStaticRpInfo
                key: ''
            buildingMulticast:
              id: buildingMulticast
              name: multicast
              label: Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingUnderlayMulticast
                    - buildingStaticRps
            buildingPtpEnabled:
              id: buildingPtpEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            1cb355a1-1446-4f98-8c9c-1300c973ac7f:
              id: 1cb355a1-1446-4f98-8c9c-1300c973ac7f
              name: profile
              label: Profile
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: aes67-r16-2016
                static_options:
                  values:
                    - aes67-r16-2016
                    - aes67
                    - smpte2059-2
                format: null
                length: null
                pattern: null
                dynamic_options: null
            buildingPtpDomain:
              id: buildingPtpDomain
              name: domain
              label: Domain
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '127'
                range: null
                static_options: null
                dynamic_options: null
            buildingPtpIdfsApply:
              id: buildingPtpIdfsApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            buildingPtpIdfsGroup:
              id: buildingPtpIdfsGroup
              name: ptpIdfGroup
              label: PTP IDF Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingPtpIdfsApply
            buildingPtpIdfs:
              id: buildingPtpIdfs
              name: idfs
              label: IDFs
              description: Select the IDFs on which to configure PTP
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: buildingPtpIdfsGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            buildingPtp:
              id: buildingPtp
              name: ptp
              label: PTP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingPtpEnabled
                    - 1cb355a1-1446-4f98-8c9c-1300c973ac7f
                    - buildingPtpDomain
                    - buildingPtpIdfs
            bbe0a827-afcf-47a3-b698-f133528db3b1:
              id: bbe0a827-afcf-47a3-b698-f133528db3b1
              name: ipv4LockingEnabled
              label: IPv4 Locking Enabled
              description: When enabled, IPv4 address locking will be configured on all L2 only switches.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            d29ad9f8-4cc6-4415-addc-67f6801bc3ff:
              id: d29ad9f8-4cc6-4415-addc-67f6801bc3ff
              name: ipv6LockingEnabled
              label: IPv6 Locking Enabled
              description: When enabled, IPv6 address locking will be configured on all L2 only switches.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            ab96c755-f7b4-493d-8516-6edab04edbd5:
              id: ab96c755-f7b4-493d-8516-6edab04edbd5
              name: ipAddress
              label: IP Address
              description: IPv4 address of the DHCP server
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            0d0f1a8e-2877-4f80-85e7-bc18b2bb3cda:
              id: 0d0f1a8e-2877-4f80-85e7-bc18b2bb3cda
              name: ipLockingDhcpServersDetails
              label: DHCP Servers Details
              description: Group of members for DHCP Servers
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ab96c755-f7b4-493d-8516-6edab04edbd5
            f37d3105-563f-408b-99bb-12e7e61e37b9:
              id: f37d3105-563f-408b-99bb-12e7e61e37b9
              name: dhcpServers
              label: DHCP Servers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: 0d0f1a8e-2877-4f80-85e7-bc18b2bb3cda
                key: ''
            61894527-2f42-4093-8973-7eed2c59372a:
              id: 61894527-2f42-4093-8973-7eed2c59372a
              name: ipLocking
              label: IP Locking
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - bbe0a827-afcf-47a3-b698-f133528db3b1
                    - d29ad9f8-4cc6-4415-addc-67f6801bc3ff
                    - f37d3105-563f-408b-99bb-12e7e61e37b9
            advancedFabricConfigurations:
              id: advancedFabricConfigurations
              name: advancedFabricConfigurations
              label: Advanced Fabric Configurations
              description: Modify default fabric configuration parameters if necessary.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ospfConfiguration
                    - mstInstances
                    - l2CampusInbandManagementDetails
                    - buildingMulticast
                    - buildingPtp
                    - 61894527-2f42-4093-8973-7eed2c59372a
            buildingFacts:
              id: buildingFacts
              name: buildingFacts
              label: Building Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodDefaults
                    - splineDefaults
                    - campusPods
                    - buildingServices
                    - campusType
                    - nodeTypeProperties
                    - buildingRoutingProtocols
                    - advancedFabricConfigurations
            buildingResolver:
              id: buildingResolver
              name: building
              label: Building
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: buildingFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Building
                tag_filter_query: null
            vrfName:
              id: vrfName
              name: vrfName
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagPeerL3Vlan:
              id: vrfMlagPeerL3Vlan
              name: vrfMlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: VLAN for the L3 peering
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfMlagPeerL3IPv4Pool:
              id: vrfMlagPeerL3IPv4Pool
              name: vrfMlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IPv4 pool to allocate addresses from for SVIs used for L3 peering. If no IPv4 pool is entered, will default to IPv4 pool entered in default VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3Peering:
              id: vrfMlagL3Peering
              name: mlagL3PeeringDetails
              label: MLAG L3 Peering
              description: Configure an L3 peering in this VRF between MLAG peers.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfMlagPeerL3Vlan
                    - vrfMlagPeerL3IPv4Pool
            vrfStaticRoutesDescription:
              id: vrfStaticRoutesDescription
              name: description
              label: Description
              description: Unique description for route
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesApply:
              id: vrfStaticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfStaticRoutesHostname:
              id: vrfStaticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfStaticRoutesDevicesGroup:
              id: vrfStaticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesHostname
            vrfStaticRoutesDevicesResolver:
              id: vrfStaticRoutesDevicesResolver
              name: devices
              label: Devices
              description: Enter a tag query to target devices the static route will be configured on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfStaticRoutesDestinationAddressPrefix:
              id: vrfStaticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesGateway:
              id: vrfStaticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesInterface:
              id: vrfStaticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesDistance:
              id: vrfStaticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesTag:
              id: vrfStaticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesMetric:
              id: vrfStaticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesDetails:
              id: vrfStaticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDestinationAddressPrefix
                    - vrfStaticRoutesGateway
                    - vrfStaticRoutesInterface
                    - vrfStaticRoutesDistance
                    - vrfStaticRoutesTag
                    - vrfStaticRoutesMetric
            vrfStaticRoutesGroup:
              id: vrfStaticRoutesGroup
              name: staticRoutesGroup
              label: Static Routes Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDescription
                    - vrfStaticRoutesDevicesResolver
                    - vrfStaticRoutesDetails
            vrfStaticRoutes:
              id: vrfStaticRoutes
              name: staticRoutes
              label: Static Routes
              description: Create static routes
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfStaticRoutesGroup
                key: vrfStaticRoutesDescription
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: Toggle on to redistribute static routes within the VRF
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersNeighborIpAddress:
              id: vrfExternalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersApply:
              id: vrfExternalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersHostname:
              id: vrfExternalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfExternalBgpPeersDevicesGroup:
              id: vrfExternalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersHostname
            vrfExternalBgpPeersDevicesResolver:
              id: vrfExternalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfExternalBgpPeersRemoteAs:
              id: vrfExternalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersDescription:
              id: vrfExternalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersPassword:
              id: vrfExternalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersSendCommunity:
              id: vrfExternalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopSelf:
              id: vrfExternalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersMaximumRoutes:
              id: vrfExternalBgpPeersMaximumRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesWarningLimit:
              id: vrfExternalBgpPeersMaxRoutesWarningLimit
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesGroup:
              id: vrfExternalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersMaximumRoutes
                    - vrfExternalBgpPeersMaxRoutesWarningLimit
            vrfExternalBgpPeersUpdateSource:
              id: vrfExternalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersEbgpMultihop:
              id: vrfExternalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersWeight:
              id: vrfExternalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersIpv4NextHop:
              id: vrfExternalBgpPeersIpv4NextHop
              name: ipv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersIpv6NextHop:
              id: vrfExternalBgpPeersIpv6NextHop
              name: ipv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopGroup:
              id: vrfExternalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersIpv4NextHop
                    - vrfExternalBgpPeersIpv6NextHop
            vrfExternalBgpPeersRouteMapIn:
              id: vrfExternalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapOut:
              id: vrfExternalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapGroup:
              id: vrfExternalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersRouteMapIn
                    - vrfExternalBgpPeersRouteMapOut
            vrfExternalBgpPeersDefaultOriginateAlwaysToggle:
              id: vrfExternalBgpPeersDefaultOriginateAlwaysToggle
              name: always
              label: Always
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersDefaultOriginateGroup:
              id: vrfExternalBgpPeersDefaultOriginateGroup
              name: defaultOriginate
              label: Default Originate
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersDefaultOriginateAlwaysToggle
            vrfExternalBgpPeersLocalAs:
              id: vrfExternalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersGroup:
              id: vrfExternalBgpPeersGroup
              name: externalBgpPeerDetails
              label: External BGP Peers Group
              description: Group of members for External BGP Peers
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersNeighborIpAddress
                    - vrfExternalBgpPeersDevicesResolver
                    - vrfExternalBgpPeersRemoteAs
                    - vrfExternalBgpPeersDescription
                    - vrfExternalBgpPeersPassword
                    - vrfExternalBgpPeersSendCommunity
                    - vrfExternalBgpPeersNextHopSelf
                    - vrfExternalBgpPeersMaxRoutesGroup
                    - vrfExternalBgpPeersUpdateSource
                    - vrfExternalBgpPeersEbgpMultihop
                    - vrfExternalBgpPeersWeight
                    - vrfExternalBgpPeersNextHopGroup
                    - vrfExternalBgpPeersRouteMapGroup
                    - vrfExternalBgpPeersDefaultOriginateGroup
                    - vrfExternalBgpPeersLocalAs
            vrfExternalBgpPeers:
              id: vrfExternalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfExternalBgpPeersGroup
                key: vrfExternalBgpPeersDescription
            vrfOspfProcessId:
              id: vrfOspfProcessId
              name: vrfOspfProcessId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfOspfMaxLsa:
              id: vrfOspfMaxLsa
              name: vrfOspfMaxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfOspfBfd:
              id: vrfOspfBfd
              name: vrfOspfBfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOspfEnabled:
              id: vrfOspfEnabled
              name: vrfOspfEnabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfOspfConfiguration:
              id: vrfOspfConfiguration
              name: vrfOspfConfiguration
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOspfProcessId
                    - vrfOspfMaxLsa
                    - vrfOspfBfd
                    - vrfOspfEnabled
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceOspfEnabled:
              id: vrfL3InterfaceOspfEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfL3InterfaceOspfArea:
              id: vrfL3InterfaceOspfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfCost:
              id: vrfL3InterfaceOspfCost
              name: cost
              label: Cost
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceOspfPointToPoint:
              id: vrfL3InterfaceOspfPointToPoint
              name: pointToPoint
              label: Point-to-Point Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceOspfAuthentication:
              id: vrfL3InterfaceOspfAuthentication
              name: authentication
              label: Authentication
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Simple
                    - Message-Digest
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfSimpleAuthKey:
              id: vrfL3InterfaceOspfSimpleAuthKey
              name: simpleAuthKey
              label: Simple Auth Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyId:
              id: vrfL3InterfaceOspfMessageDigestKeyId
              name: id
              label: ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm:
              id: vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm
              name: hashAlgorithm
              label: Hash Algorithm
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyKey:
              id: vrfL3InterfaceOspfMessageDigestKeyKey
              name: key
              label: Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeysGroup:
              id: vrfL3InterfaceOspfMessageDigestKeysGroup
              name: messageDigestKeysGroup
              label: Message Digest Keys Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceOspfMessageDigestKeyId
                    - vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm
                    - vrfL3InterfaceOspfMessageDigestKeyKey
            vrfL3InterfaceOspfMessageDigestKeys:
              id: vrfL3InterfaceOspfMessageDigestKeys
              name: messageDigestKeys
              label: Message Digest Keys
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceOspfMessageDigestKeysGroup
                key: ''
            vrfL3InterfaceOspfPassive:
              id: vrfL3InterfaceOspfPassive
              name: passive
              label: Passive Interface
              description: Enable to make a passive interface
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfL3InterfaceOspf:
              id: vrfL3InterfaceOspf
              name: ospf
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceOspfEnabled
                    - vrfL3InterfaceOspfArea
                    - vrfL3InterfaceOspfCost
                    - vrfL3InterfaceOspfPointToPoint
                    - vrfL3InterfaceOspfAuthentication
                    - vrfL3InterfaceOspfSimpleAuthKey
                    - vrfL3InterfaceOspfMessageDigestKeys
                    - vrfL3InterfaceOspfPassive
            vrfL3InterfacePimEnabled:
              id: vrfL3InterfacePimEnabled
              name: pim
              label: PIM
              description: Enable PIM sparse mode
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceMulticast:
              id: vrfL3InterfaceMulticast
              name: multicast
              label: Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfacePimEnabled
            vrfL3InterfacePtpEnabled:
              id: vrfL3InterfacePtpEnabled
              name: enable
              label: Enable
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfacePtp:
              id: vrfL3InterfacePtp
              name: ptp
              label: PTP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfacePtpEnabled
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
                    - vrfL3InterfaceOspf
                    - vrfL3InterfaceMulticast
                    - vrfL3InterfacePtp
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfMulticastEnable:
              id: vrfMulticastEnable
              name: enable
              label: Enable
              description: Toggle on to enable multicast
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfStaticRpIpAddress:
              id: vrfStaticRpIpAddress
              name: ipAddress
              label: IP Address
              description: IP address of the rendezvous point
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRpGroupAddress:
              id: vrfStaticRpGroupAddress
              name: groupAddress
              label: Group Address
              description: Group address range with prefix.  If no group address range is provided, the RP will be configured for all groups.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRpInfo:
              id: vrfStaticRpInfo
              name: rpInfo
              label: RP Info
              description: Rendezvous point
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRpIpAddress
                    - vrfStaticRpGroupAddress
            vrfStaticRps:
              id: vrfStaticRps
              name: rps
              label: RPs
              description: Define static rendezvous points that will be configured on all L3 devices within this VRF.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfStaticRpInfo
                key: ''
            vrfMulticastGroup:
              id: vrfMulticastGroup
              name: multicast
              label: Multicast
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfMulticastEnable
                    - vrfStaticRps
            vrfDetails:
              id: vrfDetails
              name: vrfDetails
              label: VRF Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - vrfMlagL3Peering
                    - vrfStaticRoutes
                    - vrfRedistributeStaticRoutesToggle
                    - vrfExternalBgpPeers
                    - vrfOspfConfiguration
                    - vrfL3InterfacesDevice
                    - vrfMulticastGroup
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: Add/Update/Delete VRFs
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfDetails
                key: vrfName
            campusServices:
              id: campusServices
              name: services
              label: Services
              description: Create VRFs which will be configured on switches in this campus.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfs
            campusDetails:
              id: campusDetails
              name: campusDetails
              label: Campus Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - buildingResolver
                    - campusServices
            campus:
              id: campus
              name: campus
              label: Campus Fabrics
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            20b56f3b-8e82-4da4-a01c-98279875ae4b:
              id: 20b56f3b-8e82-4da4-a01c-98279875ae4b
              name: matchHostnames
              label: Matching Hostname Regex
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            822ac100-cf16-4761-a9a9-77030b6b3804:
              id: 822ac100-cf16-4761-a9a9-77030b6b3804
              name: group
              label: Group
              description: The group in the regex match (0 is the first group)
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            b001bbc6-72fc-4da5-8125-52036fd295e5:
              id: b001bbc6-72fc-4da5-8125-52036fd295e5
              name: type
              label: Type
              description: Type will convert the group value to an integer. Type number will convert the group to integer.  Type letter will lowercase a single letter and take the ascii_code - 97. (a=0, b=1, ... , z=25). An error will be raised if multiple letters are matched in the group.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - number
                    - letter
                format: null
                length: null
                pattern: null
                dynamic_options: null
            abe470a0-fbe5-4d50-b731-e212df90ed78:
              id: abe470a0-fbe5-4d50-b731-e212df90ed78
              name: multiplier
              label: Multiplier
              description: Multiplier applied on value of group.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '1'
                range: null
                static_options: null
                dynamic_options: null
            323b54fe-9ce9-4e8b-841d-7d960f981389:
              id: 323b54fe-9ce9-4e8b-841d-7d960f981389
              name: offset
              label: Offset
              description: Offset applied before multiplying.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            4f78d68a-4ed6-4cec-a691-0ce711e7b888:
              id: 4f78d68a-4ed6-4cec-a691-0ce711e7b888
              name: groupRules
              label: Group Rules
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - 822ac100-cf16-4761-a9a9-77030b6b3804
                    - b001bbc6-72fc-4da5-8125-52036fd295e5
                    - abe470a0-fbe5-4d50-b731-e212df90ed78
                    - 323b54fe-9ce9-4e8b-841d-7d960f981389
            583481a8-cae0-40ac-ac92-9f98a9d90591:
              id: 583481a8-cae0-40ac-ac92-9f98a9d90591
              name: regexGroups
              label: Group Rules
              description: Set rules to generate unique NodeIds based on the hostname.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: 4f78d68a-4ed6-4cec-a691-0ce711e7b888
                key: 822ac100-cf16-4761-a9a9-77030b6b3804
            ffd071dc-b7b9-4567-a264-442cb18bbe03:
              id: ffd071dc-b7b9-4567-a264-442cb18bbe03
              name: rules
              label: Rules
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - 20b56f3b-8e82-4da4-a01c-98279875ae4b
                    - 583481a8-cae0-40ac-ac92-9f98a9d90591
            dba80cb8-95c2-4fab-9f91-c806d4f2bdd8:
              id: dba80cb8-95c2-4fab-9f91-c806d4f2bdd8
              name: nodeIdNamingConventionRules
              label: Node ID Naming Convention Rules
              description: Use hostname matches against a regular expression and formula to generate a device's NodeId
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: ffd071dc-b7b9-4567-a264-442cb18bbe03
                key: 20b56f3b-8e82-4da4-a01c-98279875ae4b
            f1c30415-06f1-4fc7-b38b-5d1f30eb3454:
              id: f1c30415-06f1-4fc7-b38b-5d1f30eb3454
              name: matchHostnames
              label: Matching Hostname Regex
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            b00fb5ee-1d58-4aad-9dbd-859fdbf43b75:
              id: b00fb5ee-1d58-4aad-9dbd-859fdbf43b75
              name: group
              label: Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            334beeef-9762-4d29-b6c4-000419b173b2:
              id: 334beeef-9762-4d29-b6c4-000419b173b2
              name: label
              label: Tag Label
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            285aea05-b802-4cbc-9eab-ec1768a94b34:
              id: 285aea05-b802-4cbc-9eab-ec1768a94b34
              name: value
              label: Tag Value
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            1960442c-4731-448f-a8ba-9cbc8e682437:
              id: 1960442c-4731-448f-a8ba-9cbc8e682437
              name: value
              label: Group Rules Group
              description: Group of members for Group Rules
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - b00fb5ee-1d58-4aad-9dbd-859fdbf43b75
                    - 334beeef-9762-4d29-b6c4-000419b173b2
                    - 285aea05-b802-4cbc-9eab-ec1768a94b34
            17da3583-18be-4246-ad42-2ad291287010:
              id: 17da3583-18be-4246-ad42-2ad291287010
              name: regexGroups
              label: Group Rules
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: 1960442c-4731-448f-a8ba-9cbc8e682437
                key: b00fb5ee-1d58-4aad-9dbd-859fdbf43b75
            afa2b137-9dc0-4bc5-94d2-858dadcc1723:
              id: afa2b137-9dc0-4bc5-94d2-858dadcc1723
              name: rules
              label: Rules
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - f1c30415-06f1-4fc7-b38b-5d1f30eb3454
                    - 17da3583-18be-4246-ad42-2ad291287010
            e032d1ad-af90-406b-a353-93e08a6c061d:
              id: e032d1ad-af90-406b-a353-93e08a6c061d
              name: groupNamingConventionRules
              label: Group Naming Convention Rules
              description: Use hostname matches against a regular expression and label, value inputs to tag devices based on the hostname.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: afa2b137-9dc0-4bc5-94d2-858dadcc1723
                key: f1c30415-06f1-4fc7-b38b-5d1f30eb3454
            37837a95-a505-4b8d-8f64-4ad94967b0a6:
              id: 37837a95-a505-4b8d-8f64-4ad94967b0a6
              name: defaultNamingRules
              label: Naming Convention Rules
              description: Use hostname matches against a regular expression to determine device role.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - dba80cb8-95c2-4fab-9f91-c806d4f2bdd8
                    - e032d1ad-af90-406b-a353-93e08a6c061d
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campus
                    - 37837a95-a505-4b8d-8f64-4ad94967b0a6
        layout:
          value: |
            {
              "buildingFacts":{
                "key":"buildingFacts",
                "type":"INPUT",
                "order":[
                  "campusType",
                  "buildingRoutingProtocols",
                  "splineTagger",
                  "splineDefaults",
                  "campusPods",
                  "campusPodDefaults",
                  "advancedFabricConfigurations",
                  "buildingServices",
                  "nodeTypeProperties"
                ]
              },
              "fabricSubnet":{
                "key":"fabricSubnet",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "fabricChildSubnetsMask":{
                "key":"fabricChildSubnetsMask",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vxlanOverlay":{
                "key":"vxlanOverlay",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vtepAddressRange":{
                "key":"vtepAddressRange",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafBgpAS":{
                "key":"leafBgpAS",
                "dependency":{
                  "campusPodUnderlayRoutingProtocol":{
                    "value":[
                      "bgp"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "campusPodFacts":{
                "key":"campusPodFacts",
                "type":"INPUT",
                "order":[
                  "podId",
                  "podInbandManagementGroup",
                  "leafTagger",
                  "memberLeafTagger",
                  "campusPodHideShowTogglesGroup",
                  "leafUplinkInterfaces",
                  "campusPodMlagPeerInterfaces",
                  "memberLeafUplinkInterfaces"
                ]
              },
              "campusPodBgpDefaultsConfigStatement":{
                "key":"campusPodBgpDefaultsConfigStatement",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "campusPodDefaults":{
                "key":"campusPodDefaults",
                "type":"INPUT",
                "order":[
                  "campusPodSpanningTreeDetails",
                  "leafMlagDetails",
                  "campusPodUplinkIpv4Pool",
                  "campusPodRouterIdPool",
                  "leafVtepLoopbackIPv4Pool",
                  "leafOspfDetails",
                  "leafBgpDetails",
                  "campusPodUplinkInterfaceDetails",
                  "campusPodPtpDetails"
                ]
              },
              "splineDefaults":{
                "key":"splineDefaults",
                "type":"INPUT",
                "order":[
                  "splineSpanningTreeDetails",
                  "splineMlagDetails",
                  "splineRouterIdPool",
                  "splineVtepLoopbackIPv4Pool",
                  "splineOspfDetails",
                  "splineBgpDetails",
                  "splinesPtpDetails"
                ]
              },
              "campusPodUnderlayRoutingProtocol":{
                "key":"campusPodUnderlayRoutingProtocol",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodRouterIdPool":{
                "key":"campusPodRouterIdPool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodBgpAsRange":{
                "key":"campusPodBgpAsRange",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "splineBgpAs":{
                "key":"splineBgpAs",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "splineBgpDefaultsConfigStatement":{
                "key":"splineBgpDefaultsConfigStatement",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "buildingOverlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "ospfProcessId":{
                "key":"ospfProcessId",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfArea":{
                "key":"ospfArea",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfMaxLsa":{
                "key":"ospfMaxLsa",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfBfdKnob":{
                "key":"ospfBfdKnob",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "campusPodUplinkIpv4Pool":{
                "key":"campusPodUplinkIpv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineVtepKnob":{
                "key":"splineVtepKnob",
                "type":"INPUT",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mlagConfiguration":{
                "key":"mlagConfiguration",
                "type":"INPUT",
                "order":[
                  "mlagPeerLinkVlan",
                  "mlagPeerIPv4Pool",
                  "mlagSubnetMask",
                  "mlagPeerL3Vlan",
                  "mlagPeerL3IPv4Pool",
                  "mlagPeerL3SubnetMask",
                  "mlagPortChannelId",
                  "virtualRouterMacAddress",
                  "lacpMode"
                ]
              },
              "splineTagger":{
                "type":"TAGGER",
                "parentKey":"buildingFacts",
                "key":"splineTagger",
                "name":"Splines",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Spline",
                "tagType":"DEVICE",
                "description":"Splines are often the switch at the MDF layer which sit between the core and IDF layers.  Each spline at this building should have a unique NodeId value starting from 1.",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "roleTagger":{
                "type":"TAGGER",
                "parentKey":"campusDetails",
                "key":"roleTagger",
                "name":"Role",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Assign a role to each switch in this campus.",
                "columns":[
                  {
                    "tagLabel":"Building",
                    "suggestedValues":[

                    ]
                  },
                  {
                    "tagLabel":"Role",
                    "suggestedValues":[
                      "Spline",
                      "Leaf",
                      "Member-Leaf"
                    ]
                  },
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "campusDetails":{
                "key":"campusDetails",
                "type":"INPUT",
                "order":[
                  "buildingResolver",
                  "campusServices",
                  "roleTagger"
                ]
              },
              "leafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"leafTagger",
                "name":"Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "memberLeafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"memberLeafTagger",
                "name":"Member Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Member-Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "campusPodResolver":{
                "key":"campusPodResolver",
                "type":"INPUT",
                "isPageLayout":true,
                "showDefaultRow":false
              },
              "overlayDetails":{
                "key":"overlayDetails",
                "type":"INPUT",
                "order":[
                  "vxlanOverlay",
                  "vtepAddressRange"
                ]
              },
              "campusPods":{
                "key":"campusPods",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "buildingResolver":{
                "key":"buildingResolver",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "campus":{
                "key":"campus",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlansCampusPodResolver":{
                "key":"vlansCampusPodResolver",
                "type":"INPUT"
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "l3CampusSviIpVirtualRouterAddress":{
                "key":"l3CampusSviIpVirtualRouterAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlansDetails":{
                "key":"vlansDetails",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlansCampusPodResolver",
                  "vlanName",
                  "vlanCampusSviGroup",
                  "vlanDhcpHelpers",
                  "sviOspfConfiguration",
                  "sviMulticast",
                  "vlanSpanningTreeDetails",
                  "vlanSviEosCli"
                ]
              },
              "vlanCampusSviGroup":{
                "key":"vlanCampusSviGroup",
                "type":"INPUT",
                "order":[
                  "l2CampusSviEnabled",
                  "vlanCampusSviVrf",
                  "l2CampusSviIpVirtualRouterAddress",
                  "l2CampusPrimarySplineSviIpAddress",
                  "l2CampusSecondarySplineSviIpAddress",
                  "l2CampusSviIpv6Addressing"
                ]
              },
              "vlanL2CampusSviIpAddress":{
                "key":"vlanL2CampusSviIpAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfStaticRoutes":{
                "key":"vrfStaticRoutes",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfExternalBgpPeers":{
                "key":"vrfExternalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSpanningTreePriority":{
                "key":"vlanSpanningTreePriority",
                "dependency":{
                  "spanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "mstInstanceId":{
                "key":"mstInstanceId",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "mstPriority":{
                "key":"mstPriority",
                "type":"INPUT",
                "dependency":{
                  "spanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersNeighborIpAddress":{
                "key":"vrfExternalBgpPeersNeighborIpAddress",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersApply":{
                "key":"vrfExternalBgpPeersApply",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersRemoteAs":{
                "key":"vrfExternalBgpPeersRemoteAs",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersDescription":{
                "key":"vrfExternalBgpPeersDescription",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersPassword":{
                "key":"vrfExternalBgpPeersPassword",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersSendCommunity":{
                "key":"vrfExternalBgpPeersSendCommunity",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfExternalBgpPeersNextHopSelf":{
                "key":"vrfExternalBgpPeersNextHopSelf",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersMaximumRoutes":{
                "key":"vrfExternalBgpPeersMaximumRoutes",
                "type":"INPUT",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersMaxRoutesWarningLimit":{
                "key":"vrfExternalBgpPeersMaxRoutesWarningLimit",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersUpdateSource":{
                "key":"vrfExternalBgpPeersUpdateSource",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersEbgpMultihop":{
                "key":"vrfExternalBgpPeersEbgpMultihop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersWeight":{
                "key":"vrfExternalBgpPeersWeight",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersIpv4NextHop":{
                "key":"vrfExternalBgpPeersIpv4NextHop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersIpv6NextHop":{
                "key":"vrfExternalBgpPeersIpv6NextHop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersRouteMapIn":{
                "key":"vrfExternalBgpPeersRouteMapIn",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersRouteMapOut":{
                "key":"vrfExternalBgpPeersRouteMapOut",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersDefaultOriginateAlwaysToggle":{
                "key":"vrfExternalBgpPeersDefaultOriginateAlwaysToggle",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersLocalAs":{
                "key":"vrfExternalBgpPeersLocalAs",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSpanningTreeDetails":{
                "key":"vlanSpanningTreeDetails",
                "type":"INPUT",
                "order":[
                  "vlanStpPrioritySpline",
                  "vlanStpPriorityLeaf",
                  "vlanStpPriorityMemberLeaf"
                ]
              },
              "mstInstanceDetails":{
                "key":"mstInstanceDetails",
                "type":"INPUT",
                "order":[
                  "mstInstanceId",
                  "mstInstanceVlans",
                  "mstInstanceSplineStpPriority",
                  "mstInstanceLeafStpPriority",
                  "mstInstanceMemberLeafStpPriority"
                ]
              },
              "p2pLinks":{
                "key":"p2pLinks",
                "type":"INPUT",
                "isPageLayout":true
              },
              "p2pLinkDetails":{
                "key":"p2pLinkDetails",
                "type":"INPUT",
                "order":[
                  "p2pLinkName",
                  "p2pLinkInterfaceDetails",
                  "p2pLinkIncludeInUnderlayRoutingProtocol"
                ]
              },
              "podId":{
                "key":"podId",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "leafMlagPeerL3Vlan":{
                "key":"leafMlagPeerL3Vlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "leafMlagPeerL3IPv4Pool":{
                "key":"leafMlagPeerL3IPv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafVirtualRouterMacAddress":{
                "key":"leafVirtualRouterMacAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mstInstanceMemberLeafStpPriority":{
                "key":"mstInstanceMemberLeafStpPriority",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "mstInstanceLeafStpPriority":{
                "key":"mstInstanceLeafStpPriority",
                "type":"INPUT",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mstInstanceSplineStpPriority":{
                "key":"mstInstanceSplineStpPriority",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPrioritySpline":{
                "key":"vlanStpPrioritySpline",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPriorityLeaf":{
                "key":"vlanStpPriorityLeaf",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPriorityMemberLeaf":{
                "key":"vlanStpPriorityMemberLeaf",
                "type":"INPUT",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vlanAssignmentSwitchTagger":{
                "type":"TAGGER",
                "parentKey":"vlansCampusPodGroup",
                "key":"vlanAssignmentSwitchTagger",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches where the VLAN will be configured.",
                "columns":[
                  {
                    "tagLabel":"Campus-Pod",
                    "suggestedValues":[

                    ]
                  }
                ],
                "fieldOverrides":{
                  "description":"For viewing purposes only. Do NOT change the values in this table."
                }
              },
              "sviOspfSimpleAuthKey":{
                "key":"sviOspfSimpleAuthKey",
                "dependency":{
                  "sviOspfAuthentication":{
                    "value":[
                      "Simple"
                    ],
                    "mode":"SHOW"
                  },
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "sviOspfMessageDigestKeysDetails":{
                "key":"sviOspfMessageDigestKeysDetails",
                "type":"INPUT",
                "order":[
                  "sviOspfKeyId",
                  "sviOspfHashAlgorithm",
                  "sviOspfKey"
                ]
              },
              "sviOspfEnabled":{
                "key":"sviOspfEnabled",
                "type":"INPUT",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfPointToPoint":{
                "key":"sviOspfPointToPoint",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "sviOspfArea":{
                "key":"sviOspfArea",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "sviOspfCost":{
                "key":"sviOspfCost",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "sviOspfAuthentication":{
                "key":"sviOspfAuthentication",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "sviOspfKeyId":{
                "key":"sviOspfKeyId",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "sviOspfHashAlgorithm":{
                "key":"sviOspfHashAlgorithm",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "sviOspfKey":{
                "key":"sviOspfKey",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusPrimarySplineSviIpAddress":{
                "key":"l2CampusPrimarySplineSviIpAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusSecondarySplineSviIpAddress":{
                "key":"l2CampusSecondarySplineSviIpAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusSviIpVirtualRouterAddress":{
                "key":"l2CampusSviIpVirtualRouterAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "sviOspfConfiguration":{
                "key":"sviOspfConfiguration",
                "type":"INPUT",
                "order":[
                  "sviOspfEnabled",
                  "sviOspfArea",
                  "sviOspfCost",
                  "sviOspfPointToPoint",
                  "sviOspfPassive",
                  "sviOspfAuthentication",
                  "sviOspfSimpleAuthKey",
                  "sviOspfMessageDigestKeys"
                ]
              },
              "splineVtepLoopbackIPv4Pool":{
                "key":"splineVtepLoopbackIPv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "splineVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafVtepLoopbackIPv4Pool":{
                "key":"leafVtepLoopbackIPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "leafVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfOspfConfiguration":{
                "key":"vrfOspfConfiguration",
                "type":"INPUT",
                "order":[
                  "vrfOspfEnabled",
                  "vrfOspfProcessId",
                  "vrfOspfMaxLsa",
                  "vrfOspfBfd"
                ]
              },
              "vrfOspfProcessId":{
                "key":"vrfOspfProcessId",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfOspfEnabled":{
                "key":"vrfOspfEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfOspfMaxLsa":{
                "key":"vrfOspfMaxLsa",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfOspfBfd":{
                "key":"vrfOspfBfd",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l3CampusPrimaryLeafSviIpAddress":{
                "key":"l3CampusPrimaryLeafSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l3CampusSecondaryLeafSviIpAddress":{
                "key":"l3CampusSecondaryLeafSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerVlan":{
                "key":"splineMlagPeerVlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerIPv4Pool":{
                "key":"splineMlagPeerIPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerL3Vlan":{
                "key":"splineMlagPeerL3Vlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerL3IPv4Pool":{
                "key":"splineMlagPeerL3IPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineVirtualRouterMacAddress":{
                "key":"splineVirtualRouterMacAddress",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerInterfaceName":{
                "key":"splineMlagPeerInterfaceName",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineBgpAsn":{
                "key":"splineBgpAsn",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "buildingOverlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "leafUplinkInterfaceDetails":{
                "key":"leafUplinkInterfaceDetails",
                "type":"INPUT",
                "order":[
                  "leafUplinkHostname",
                  "leafUplinkInterfaceName",
                  "leafUplinkSplineHostname",
                  "leafUplinkSplineInterface"
                ]
              },
              "memberLeafUplinkInterfaceDetails":{
                "key":"memberLeafUplinkInterfaceDetails",
                "type":"INPUT",
                "order":[
                  "memberLeafUplinkHostname",
                  "memberLeafUplinkInterfaceName",
                  "memberLeafUplinkLeafHostname",
                  "memberLeafUplinkLeafInterface"
                ]
              },
              "accessInterfaces":{
                "key":"accessInterfaces",
                "type":"INPUT",
                "isPageLayout":true
              },
              "l2CampusInbandManagementVlan":{
                "key":"l2CampusInbandManagementVlan",
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "l2CampusInbandManagementSubnet":{
                "key":"l2CampusInbandManagementSubnet",
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "buildingOverlayRoutingProtocol":{
                "key":"buildingOverlayRoutingProtocol",
                "type":"INPUT",
                "dependencyType":"OR",
                "dependency":{
                  "splineVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "leafVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "buildingServices":{
                "key":"buildingServices",
                "type":"INPUT",
                "order":[
                  "vlans",
                  "allowAllVlansOnTrunkToggle"
                ]
              },
              "splineOspfDefaultsConfigStatement":{
                "key":"splineOspfDefaultsConfigStatement",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafOspfDefaultsConfigStatement":{
                "key":"leafOspfDefaultsConfigStatement",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  },
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfDetails":{
                "key":"vrfDetails",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfMlagL3Peering",
                  "vrfStaticRoutes",
                  "vrfRedistributeStaticRoutesToggle",
                  "vrfMulticastGroup",
                  "vrfOspfConfiguration",
                  "vrfExternalBgpPeers",
                  "vrfL3InterfacesDevice"
                ]
              },
              "l3CampusVlanName":{
                "key":"l3CampusVlanName",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfRedistributeStaticRoutesToggle":{
                "key":"vrfRedistributeStaticRoutesToggle",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfStaticRoutesDevicesTagger":{
                "type":"TAGGER",
                "parentKey":"vrfStaticRoutesDevicesGroup",
                "key":"vrfStaticRoutesDevicesTagger",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches which will have the static route configured on them.",
                "columns":[
                  {
                    "tagLabel":"Building",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "vrfStaticRoutesApply":{
                "key":"vrfStaticRoutesApply",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfL3InterfaceDetails":{
                "key":"vrfL3InterfaceDetails",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfaceName",
                  "vrfL3InterfaceIpAddress",
                  "vrfL3InterfaceDescription",
                  "vrfL3InterfaceEnabled",
                  "vrfL3InterfaceMtu",
                  "vrfL3InterfaceOspf",
                  "vrfL3InterfaceMulticast",
                  "vrfL3InterfacePtp",
                  "vrfL3InterfaceEosCli"
                ]
              },
              "vrfL3InterfaceOspfSimpleAuthKey":{
                "key":"vrfL3InterfaceOspfSimpleAuthKey",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Simple"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfEnabled":{
                "key":"vrfL3InterfaceOspfEnabled",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfArea":{
                "key":"vrfL3InterfaceOspfArea",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfCost":{
                "key":"vrfL3InterfaceOspfCost",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfPointToPoint":{
                "key":"vrfL3InterfaceOspfPointToPoint",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfAuthentication":{
                "key":"vrfL3InterfaceOspfAuthentication",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfMessageDigestKeyId":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyId",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfMessageDigestKeyKey":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyKey",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfExternalBgpPeersDevicesTagger":{
                "type":"TAGGER",
                "parentKey":"vrfExternalBgpPeersDevicesGroup",
                "key":"vrfExternalBgpPeersDevicesTagger",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches which will have the BGP peer configured on them.",
                "columns":[
                  {
                    "tagLabel":"Building",
                    "suggestedValues":[

                    ]
                  }
                ],
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "defaultSplineFabricInterfaces":{
                "key":"defaultSplineFabricInterfaces",
                "type":"INPUT",
                "isPageLayout":true
              },
              "defaultLeafFabricInterfaces":{
                "key":"defaultLeafFabricInterfaces",
                "type":"INPUT",
                "isPageLayout":true
              },
              "defaultMemberLeafFabricInterfaces":{
                "key":"defaultMemberLeafFabricInterfaces",
                "type":"INPUT",
                "isPageLayout":true
              },
              "leafUplinkHostname":{
                "key":"leafUplinkHostname",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafUplinkInterfaceName":{
                "key":"leafUplinkInterfaceName",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafUplinkSplineHostname":{
                "key":"leafUplinkSplineHostname",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafUplinkSplineInterface":{
                "key":"leafUplinkSplineInterface",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodMlagPeerInterfaceName":{
                "key":"campusPodMlagPeerInterfaceName",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "memberLeafUplinkHostname":{
                "key":"memberLeafUplinkHostname",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "memberLeafUplinkInterfaceName":{
                "key":"memberLeafUplinkInterfaceName",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "memberLeafUplinkLeafHostname":{
                "key":"memberLeafUplinkLeafHostname",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "memberLeafUplinkLeafInterface":{
                "key":"memberLeafUplinkLeafInterface",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "displayPodFabricInterfaceInputsToggle":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "dba80cb8-95c2-4fab-9f91-c806d4f2bdd8":{
                "key":"dba80cb8-95c2-4fab-9f91-c806d4f2bdd8",
                "type":"INPUT",
                "isPageLayout":true
              },
              "e032d1ad-af90-406b-a353-93e08a6c061d":{
                "key":"e032d1ad-af90-406b-a353-93e08a6c061d",
                "type":"INPUT",
                "isPageLayout":true
              },
              "mstInstanceVlans":{
                "key":"mstInstanceVlans",
                "type":"INPUT",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfPassive":{
                "key":"sviOspfPassive",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "splineMlagDetails":{
                "key":"splineMlagDetails",
                "type":"INPUT",
                "order":[
                  "splineMlagPeerVlan",
                  "splineMlagPeerIPv4Pool",
                  "splineMlagPeerL3Vlan",
                  "splineMlagPeerL3IPv4Pool",
                  "splineVirtualRouterMacAddress",
                  "splineMlagPeerInterfaces",
                  "splineMlagPeerInterfacesSpeed",
                  "splineMlagPeerInterfacesEosCli",
                  "splineMlagPeerLinkEosCli"
                ]
              },
              "advancedFabricConfigurations":{
                "key":"advancedFabricConfigurations",
                "type":"INPUT",
                "order":[
                  "l2CampusInbandManagementDetails",
                  "ospfConfiguration",
                  "mstInstances",
                  "buildingMulticast",
                  "buildingPtp",
                  "61894527-2f42-4093-8973-7eed2c59372a"
                ]
              },
              "vrfL3InterfaceOspf":{
                "key":"vrfL3InterfaceOspf",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfaceOspfEnabled",
                  "vrfL3InterfaceOspfArea",
                  "vrfL3InterfaceOspfCost",
                  "vrfL3InterfaceOspfPointToPoint",
                  "vrfL3InterfaceOspfPassive",
                  "vrfL3InterfaceOspfAuthentication",
                  "vrfL3InterfaceOspfSimpleAuthKey",
                  "vrfL3InterfaceOspfMessageDigestKeys"
                ]
              },
              "campusPodUplinkInterfaceDetails":{
                "key":"campusPodUplinkInterfaceDetails",
                "type":"INPUT",
                "order":[
                  "campusPodDefaultsLeafUplinkInterfacesSpeed",
                  "leafUplinksEosCli",
                  "campusPodDefaultsMemberLeafUplinkInterfacesSpeed",
                  "memberLeafUplinksEosCli"
                ]
              },
              "vrfL3InterfaceOspfPassive":{
                "key":"vrfL3InterfaceOspfPassive",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "vrfOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "vrfL3InterfaceOspfEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l2CampusInbandManagementDetails":{
                "key":"l2CampusInbandManagementDetails",
                "type":"INPUT",
                "order":[
                  "l2CampusInbandManagementVrf",
                  "l2CampusInbandManagementVlan",
                  "l2CampusInbandManagementSubnet",
                  "l2CampusInbandManagementIpHelperAddresses"
                ]
              },
              "sviPimEnabled":{
                "key":"sviPimEnabled",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfacePimEnabled":{
                "key":"vrfL3InterfacePimEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "vrfMulticastEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodPtpDetails":{
                "key":"campusPodPtpDetails",
                "type":"INPUT",
                "order":[
                  "leafPtpPriority1",
                  "memberLeafPtpPriority1",
                  "campusPodPtpAutoClockIdentity",
                  "campusPodPtpClockIdentityPrefix"
                ]
              },
              "campusPodPtpClockIdentityPrefix":{
                "key":"campusPodPtpClockIdentityPrefix",
                "dependency":{
                  "campusPodPtpAutoClockIdentity":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "splinesPtpClockIdentityPrefix":{
                "key":"splinesPtpClockIdentityPrefix",
                "dependency":{
                  "splinesPtpAutoClockIdentity":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  },
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusSecondarySplineSviIpv6Address":{
                "key":"l2CampusSecondarySplineSviIpv6Address",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusPrimarySplineSviIpv6Address":{
                "key":"l2CampusPrimarySplineSviIpv6Address",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "l2CampusSviIpv6VirtualRouterAddress":{
                "key":"l2CampusSviIpv6VirtualRouterAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "buildingPtpIdfsApply":{
                "key":"buildingPtpIdfsApply",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "buildingPtpIdfsTagger":{
                "type":"TAGGER",
                "parentKey":"buildingPtpIdfsGroup",
                "key":"buildingPtpIdfsTagger",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches where the VLAN will be configured.",
                "columns":[
                  {
                    "tagLabel":"Campus-Pod",
                    "suggestedValues":[

                    ]
                  }
                ],
                "fieldOverrides":{
                  "description":"For viewing purposes only. Do NOT change the values in this table."
                },
                "dependencyType":"AND",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splinesPtpPriority1":{
                "key":"splinesPtpPriority1",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafPtpPriority1":{
                "key":"leafPtpPriority1",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "memberLeafPtpPriority1":{
                "key":"memberLeafPtpPriority1",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "campusPodPtpAutoClockIdentity":{
                "key":"campusPodPtpAutoClockIdentity",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "splinesPtpAutoClockIdentity":{
                "key":"splinesPtpAutoClockIdentity",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "1cb355a1-1446-4f98-8c9c-1300c973ac7f":{
                "key":"1cb355a1-1446-4f98-8c9c-1300c973ac7f",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "buildingPtpDomain":{
                "key":"buildingPtpDomain",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfacePtpEnabled":{
                "key":"vrfL3InterfacePtpEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingPtpEnabled":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "cfe21dcf-d098-4736-ad56-17f082ef965c":{
                "key":"cfe21dcf-d098-4736-ad56-17f082ef965c",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "fba15ab0-5fb6-4f3f-ab7b-4fb2237bf199":{
                "key":"fba15ab0-5fb6-4f3f-ab7b-4fb2237bf199",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "8d49b48b-3234-49c7-8768-ae052d215c2a":{
                "key":"8d49b48b-3234-49c7-8768-ae052d215c2a",
                "type":"INPUT",
                "order":[
                  "5912edbf-18ef-4a93-9219-1b6b8cfd3e30",
                  "cfe21dcf-d098-4736-ad56-17f082ef965c",
                  "fba15ab0-5fb6-4f3f-ab7b-4fb2237bf199"
                ]
              },
              "5912edbf-18ef-4a93-9219-1b6b8cfd3e30":{
                "key":"5912edbf-18ef-4a93-9219-1b6b8cfd3e30",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "buildingStaticRpIpAddress":{
                "key":"buildingStaticRpIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "buildingStaticRpGroupAddress":{
                "key":"buildingStaticRpGroupAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "buildingUnderlayMulticast":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfStaticRpIpAddress":{
                "key":"vrfStaticRpIpAddress",
                "dependency":{
                  "vrfMulticastEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfStaticRpGroupAddress":{
                "key":"vrfStaticRpGroupAddress",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "vrfMulticastEnable":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              }
            }
