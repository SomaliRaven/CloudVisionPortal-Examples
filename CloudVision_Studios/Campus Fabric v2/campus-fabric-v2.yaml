- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: campus-fabric-advanced
        workspace_id: ''
      display_name: Advanced Campus Fabric
      description: Provision the fabric of an L2 or L3 campus network.
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          from collections import Counter, OrderedDict
          ## from packaging import version
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.services import TagServiceStub, \
              TagAssignmentServiceStub, \
              TagConfigServiceStub,\
              TagAssignmentConfigServiceStub
          from arista.tag.v2.services.gen_pb2 import TagRequest, \
              TagConfigSetRequest, \
              TagStreamRequest, \
              TagConfigStreamRequest, \
              TagAssignmentStreamRequest, \
              TagAssignmentConfigSetRequest, \
              TagAssignmentConfigStreamRequest
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          fabric_variables  = {
              "bgp_peer_groups": {
                  "IPv4_UNDERLAY_PEERS": {
                      "name": "IPv4_UNDERLAY_PEERS",
                      "password": None
                  },
                  "MLAG_IPv4_UNDERLAY_PEER": {
                      "name": "MLAG-IPv4-UNDERLAY-PEER",
                      "password": None,
                  },
                  "EVPN_OVERLAY_PEERS": {
                      "name": "EVPN_OVERLAY_PEERS",
                      "password": None
                  }
              },
              "bfd_multihop": {
                  "interval": 300,
                  "min_rx": 300,
                  "multiplier": 3
              },
              "evpn_ebgp_multihop": 3,
              "evpn_hostflap_detection": {
                  "enabled": False,
                  "threshold": 5,
                  "window": 180
              }
          }

          jericho_platform_regexes = [
              r'7048T',
              r'7280',
              r'75\d\d',
              r'780\d'
          ]

          veos_regex = r'(v|c)EOS(-)*(Lab)*'

          def convert(text):
              return int(text) if text.isdigit() else text.lower()

          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]

          def natural_sort(iterable):
              if iterable is None:
                  return list()
              return sorted(iterable, key=alphanum_key)

          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",") if segment.strip() != ""]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          if i not in numbers:
                              numbers.append(i)
                  else:
                      if int(segment) not in numbers:
                          numbers.append(int(segment))
              return numbers

          # Needed for network services
          from itertools import count, groupby
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))


          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None


          def get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=True):
              '''
              Returns all tags applied to a device that match the label of the input tag_assignment_key

              Args:
                  tag_assignment_key: TagAssignmentKey object with the label field set
              '''
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              # Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              # Create TagValueSearchRequest
              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
                  tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags

          def get_tag_value(device_id=None, label=None, workspace_id=None, topology_studio_request=True):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=topology_studio_request)
              if len(tag_values) > 0:
                  return tag_values[0].value

          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [ tag_value.value for tag_value in tag_values ]

          def create_tag(tag_key):
              '''
              tag_key is a TagKey
              '''
              tcsr = TagConfigSetRequest()
              tcsr.value.key.workspace_id.value = tag_key.workspace_id.value
              tcsr.value.key.element_type = tag_key.element_type
              tcsr.value.key.label.value = tag_key.label.value
              tcsr.value.key.value.value = tag_key.value.value
              client = ctx.getApiClient(TagConfigServiceStub)
              client.Set(tcsr)

          def apply_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = False
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = True
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_all_tag_values(tag_label, device_id, workspace_id, value=None):
              '''
              Removes all tags with the input tag label matchiing the input device_id
              If a value is supplied, only tags matching the label and value will be removed from the device
              '''
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = tag_label
              # tag_assignment_key.value.value = None
              matching_tags = get_tag_values_applied_to_device(tag_assignment_key)
              # If there are any mlag_configuration.peer_link tags applied
              if len(matching_tags) > 0:
                  # Remove tags
                  for tag in matching_tags:
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      if value is None:
                          remove_tag(tak_to_remove)
                      else:
                          if tag.value == value:
                              remove_tag(tak_to_remove)


          def update_device_tag(tag_assignment_key, multiple_values=False):
              """
              tag_assignment_key is a TagAssignmentKey that you want to update the device with
              """
              applied_tags = get_tag_values_applied_to_device(tag_assignment_key)
              already_assigned = False
              for tag in applied_tags:
                  if tag.value != tag_assignment_key.value.value:
                      if multiple_values == True:
                          continue
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      remove_tag(tak_to_remove)
                  else:
                      already_assigned = True

              if already_assigned:
                  return

              #Create desired tag
              tag_key = TagKey()
              tag_key.workspace_id.value = workspace_id
              tag_key.element_type = 1
              tag_key.label.value = tag_assignment_key.label.value
              tag_key.value.value = tag_assignment_key.value.value
              create_tag(tag_key)

              # Apply desired tag
              apply_tag(tag_assignment_key)


          def update_tags(switch_facts):
              device_id = switch_facts["serial_number"]
              # node_id tag
              # Create/Update/Apply the node_id tag
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = "node_id"
              tag_assignment_key.value.value = str(switch_facts["id"])
              update_device_tag(tag_assignment_key)
              # Update campus-pod tag
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "Campus-Pod"
                  tag_assignment_key.value.value = str(switch_facts["group"])
                  update_device_tag(tag_assignment_key)
              # Update network services tags
              if switch_facts["network_services"].get("l2"):
                  # Create/Apply the following tag 'network_services:L2'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "NetworkServices"
                  tag_assignment_key.value.value = "L2"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L2'
                  remove_all_tag_values("network_services", device_id, workspace_id, value="L2")
              if switch_facts["network_services"].get("l3"):
                  # Create/Apply the following tag 'network_services:L3'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "NetworkServices"
                  tag_assignment_key.value.value = "L3"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L3'
                  remove_all_tag_values("network_services", device_id, workspace_id, value="L3")
              # Update mlag_configuration.peer_link
              if switch_facts.get("mlag"):
                  mlag_peer_link = "Port-Channel{}".format(switch_facts["mlag_port_channel_id"])
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "mlag_configuration.peer_link"
                  tag_assignment_key.value.value = str(mlag_peer_link)
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("mlag_configuration.peer_link", device_id, workspace_id)

              # Update routing tags
              bgp_tags = {"router_bgp.as": switch_facts.get("bgp_as"), "router_bgp.router_id": switch_facts.get("router_id")}
              if switch_facts.get("underlay_router") \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  # Set bgp as and router id tags
                  for label, value in bgp_tags.items():
                      tag_assignment_key = TagAssignmentKey()
                      tag_assignment_key.workspace_id.value = workspace_id
                      tag_assignment_key.element_type = 1
                      tag_assignment_key.device_id.value =  device_id
                      tag_assignment_key.label.value = str(label)
                      tag_assignment_key.value.value = str(value)
                      update_device_tag(tag_assignment_key)
              else:
                  # Remove possible bgp tags
                  for label, value in bgp_tags.items():
                      #Remove tags with same label that don't match proper value
                      if value is None:
                          remove_all_tag_values(str(label), device_id, workspace_id)
              # Update VTEP tag
              if switch_facts.get("vtep"):
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "Vtep"
                  tag_assignment_key.value.value = "True"
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("vtep", device_id, workspace_id)
              return


          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          def get_interfaces_info(switch_facts):
              device_id = switch_facts["serial_number"]
              uplink_interfaces = {}
              downlink_interfaces = {}
              mlag_peer_link_interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None:
                      if switches_in_my_campus.get(peer_device.id):
                          neighbor = switches_in_my_campus.get(peer_device.id)
                          if switch_facts["type"] == "spline":
                              if neighbor["type"] == "spline":
                                  mlag_peer_link_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] in ["leaf", "memberleaf"]:
                                  downlink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                          elif switch_facts["type"] == "leaf":
                              if neighbor["type"] == "spline":
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] == "memberleaf":
                                  downlink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] == "leaf":
                                  mlag_peer_link_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                          elif switch_facts["type"] == "memberleaf":
                              if neighbor["type"] in ["leaf", "spline"]:
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}

              return OrderedDict(natural_sort(uplink_interfaces.items())), \
                      OrderedDict(natural_sort(downlink_interfaces.items())), \
                      OrderedDict(natural_sort(mlag_peer_link_interfaces.items()))


          def get_highest_spline_node_id_in_my_site(switch_facts):
              highest_spline_node_id = 0
              for switch_facts in switches_in_my_campus.values():
                  if switch_facts["site"] == switch_facts["site"] and \
                      switch_facts["type"] == "spline" and switch_facts["id"] > highest_spline_node_id:
                      highest_spline_node_id = switch_facts["id"]
              return highest_spline_node_id


          def get_highest_leaf_node_id_in_my_site(switch_facts):
              highest_leaf_node_id = 0
              for switch_facts in switches_in_my_campus.values():
                  if switch_facts["site"] == switch_facts["site"] and \
                     switch_facts["type"] == "leaf" and switch_facts["id"] > highest_leaf_node_id:
                      highest_leaf_node_id = switch_facts["id"]
              return highest_leaf_node_id


          def get_inband_management_ip(switch_facts):
              if switch_facts["type"] == "spline":
                  return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())[switch_facts["id"]]
              else:
                  spline_offset = get_highest_spline_node_id_in_my_site(switch_facts)
                  leaf_offset = get_highest_leaf_node_id_in_my_site(switch_facts)
                  if site_details["campusPodDetails"]["uplinkType"] == "port-channel":
                      if switch_facts["type"] == "leaf":
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                                  [switch_facts["id"] + spline_offset]
                      else:
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                                  [switch_facts["id"] + spline_offset + leaf_offset]
                  else:
                      if switch_facts["type"] == "leaf":
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                              [switch_facts["id"]]
                      else:
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                              [switch_facts["id"] + leaf_offset]


          def get_router_id(switch_facts):
              router_id_subnet = switch_facts["loopback_ipv4_pool"]
              switch_id = switch_facts["id"]
              offset = switch_facts["loopback_ipv4_offset"]
              return list(ipaddress.ip_network(router_id_subnet).hosts())[(switch_id - 1) + offset]


          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, "MLAG Subnet mask length must be longer than the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[int(switch_facts["mlag_primary_id"]) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return


          def get_vtep_loopback(switch_facts, offset=None):
              if switch_facts["type"] == "spline" or offset is None:
                  offset = 0
              vtep_loopback_subnet = switch_facts["vtep_loopback_ipv4_pool"]
              if switch_facts.get("mlag_primary_id"):
                  switch_id = switch_facts["mlag_primary_id"] - 1 + offset
                  switch_id = switch_facts["group_index"] + offset
              else:
                  switch_id = switch_facts["id"] - 1 + offset
                  switch_id = switch_facts["group_index"] + offset
              return list(ipaddress.ip_network(vtep_loopback_subnet).hosts())[switch_id]


          def get_p2p_uplinks_ip(switch_facts, uplink_switch_facts):
              if switch_facts.get("type") != "leaf":
                  return
              uplink_ipv4_pool = switch_facts["uplink_ipv4_pool"]
              uplink_subnet_mask = switch_facts["uplink_ipv4_subnet_mask"]
              switch_id = switch_facts["id"]
              uplink_switch_id = uplink_switch_facts["id"]
              max_uplink_switches = get_highest_spline_node_id_in_my_site(switch_facts)
              max_parallel_uplinks = 1
              child_subnet = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask)) \
                  [ (switch_id - 1) * max_uplink_switches * max_parallel_uplinks + (uplink_switch_id - 1) ]
              return list(child_subnet.hosts())[1]


          def get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts):
              if switch_facts.get("type") != "leaf":
                  return
              uplink_ipv4_pool = switch_facts["uplink_ipv4_pool"]
              uplink_subnet_mask = switch_facts["uplink_ipv4_subnet_mask"]
              switch_id = switch_facts["id"]
              uplink_switch_id = uplink_switch_facts["id"]
              max_uplink_switches = get_highest_spline_node_id_in_my_site(switch_facts)
              max_parallel_uplinks = 1
              child_subnet = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask)) \
                  [ (switch_id - 1) * max_uplink_switches * max_parallel_uplinks + (uplink_switch_id - 1) ]
              return list(child_subnet.hosts())[0]

          def get_all_vlans(switch_facts):
              all_vlans = []
              for vrf_info in switch_facts["vrfs"].values():
                  if vrf_info.get("svis"):
                      all_vlans += [ int(svi) for svi in vrf_info["svis"].keys() ]

              all_vlans += [ int(vlan) for vlan in switch_facts["l2vlans"].keys() ]
              return all_vlans

          def set_bgp_as_from_studio_input(switch_facts, campus_resolver):
              if switch_facts["type"] not in ["leaf"]:
                  return switch_facts
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=switch_facts["serial_number"])
              site_facts = campus_resolved["campusDetails"]["site"].resolve(device=switch_facts["serial_number"])["siteFacts"]
              ## assert site_facts is not None, "{} resolves site_facts to None".format(switch_facts["hostname"])
              ## assert site_facts["campusPods"] is not None, "{} does not have value for 'campusPods' key".format(switch_facts["hostname"])
              ## assert site_facts["campusPods"].resolve(device=switch_facts["serial_number"]) is not None, "{} resolves 'campusPods' to None".format(switch_facts["hostname"])
              pod_facts = site_facts["campusPods"].resolve(device=switch_facts["serial_number"])["campusPodFacts"]
              if pod_facts.get("leafBgpConfiguration") and \
                  pod_facts["leafBgpConfiguration"].get("leafBgpAs") and \
                  pod_facts["leafBgpConfiguration"]["leafBgpAs"] != 0:
                  switch_facts["bgp_as"] = pod_facts["leafBgpConfiguration"]["leafBgpAs"]
              return switch_facts


          def set_topology_facts(switch_facts):
              topology_facts = {
                  "links": {}
              }
              if switch_facts["uplink_type"] == "p2p":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      link_facts["peer_bgp_as"] = uplink_switch_facts.get("bgp_as")
                      link_facts["type"] = "underlay_p2p"
                      link_facts["ip_address"] = str(get_p2p_uplinks_ip(switch_facts, uplink_switch_facts))
                      link_facts["peer_ip_address"] = str(get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts))
                      if switch_facts.get("underlay_multicast"):
                          link_facts["pim_enabled"] = True
                      else:
                          link_facts["pim_enabled"] = False
                      topology_facts["links"][uplink_interface] = link_facts

              elif switch_facts["uplink_type"] == "port-channel":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      # Campus Service has a field here for allowed_vlans
                      link_facts["allowed_vlans"] = get_all_vlans(switch_facts)
                      link_facts["type"] = "underlay_l2"
                      if uplink_switch_facts.get("mlag") is not None and uplink_switch_facts.get("mlag") == True:
                          link_facts["channel_description"] = uplink_switch_facts["mlag_group"]
                      if switch_facts.get("mlag") is not None and switch_facts.get("mlag") == True:
                          link_facts["peer_channel_description"] = switch_facts["mlag_group"]
                      if switch_facts.get("mlag_role") is not None and switch_facts["mlag_role"] == "secondary":
                          mlag_peer_switch_facts =  switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_switch_interfaces"][0]))
                      else:
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_switch_interfaces"][0]))
                      topology_facts["links"][uplink_interface] = link_facts

              switch_facts["topology"] = topology_facts
              return switch_facts


          def get_switch_basics(device_id, campus_resolver):
              # Process Studio inputs
              campus_resolved = campus.resolve(device=device_id)
              site_details = campus_resolved["campusDetails"]["site"].resolve(device=device_id)["siteFacts"]
              # Initialize switch_facts
              switch_facts = {}
              switch_facts = {"serial_number": device_id}
              # Get facts from tags
              switch_facts["hostname"] = [ dev.hostName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["platform"] = [ dev.modelName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["eos_version"] = get_tag_value(device_id=device_id, label="eos", workspace_id=workspace_id, topology_studio_request=False)
              switch_facts["campus"] = campus_dict.get(device_id)
              switch_facts["site"] = site_dict.get(device_id)
              switch_facts["allow_all_vlans"] = site_details["allowAllVLANs"]

              # First attempt to set switch role
              switch_role = None
              potential_roles = {"Spline": "spline", "Leaf": "leaf", "Member-Leaf": "memberleaf"}
              roles_applied_to_switch = role_dict.get(device_id)
              # If no role is applied to switch, switch should not be in fabric build
              if roles_applied_to_switch is None:
                  ctx.info(f"No Role tag set for {switch_facts['hostname']}")
                  return
              # Check to see that a device isn't assigned multiple roles within the L3 Leaf-Spine fabric
              roles_intersect = [role for role in roles_applied_to_switch if role in list(potential_roles.keys())]
              assert len(roles_intersect) <= 1, f"Only 1 campus role should be applied to the switch. " \
                                                f"Detected the following roles applied to {switch_facts['hostname']}: {roles_intersect}"

              # Set role
              if roles_applied_to_switch is not None:
                  for role in potential_roles.keys():
                      if role in roles_applied_to_switch:
                          switch_role = role
                          break

              if potential_roles.get(switch_role):
                  switch_facts["type"] = potential_roles[switch_role]
              else:
                  ctx.info(f"No Role tag set for {switch_facts['hostname']}")

              # Set switch id based on NodeId mini-tagger values
              node_id = node_id_dict.get(device_id)
              if node_id is not None:
                  switch_facts['id'] = int(node_id)
              else:
                  ctx.info(f"No NodeId tag set for {switch_facts['hostname']}")
                  return

              # Set spline switch facts if device is a spline
              if switch_facts["type"] == "spline":
                  switch_facts["group"] = "{}_{}_Splines".format(switch_facts["campus"], switch_facts["site"])
                  switch_facts["group_index"] = 0
                  switch_facts["underlay_router"] = True
                  switch_facts["uplink_type"] = "p2p"
                  if site_details["campusPodDetails"]["uplinkType"] == "port-channel":
                      switch_facts["vtep"] = True if site_details['overlayDetails']['vxlanOverlay'] == True else False
                      switch_facts["evpn_role"] = "client" if site_details['overlayDetails']['vxlanOverlay'] == True else None
                      switch_facts["mlag_support"] = True
                      switch_facts["network_services"] = {
                          "l2": True,
                          "l3": True
                      }
                  elif site_details["campusPodDetails"]["uplinkType"] == "p2p":
                      switch_facts["vtep"] = False
                      switch_facts["mlag_support"] = False
                      switch_facts["evpn_role"] = "server" if site_details['overlayDetails']['vxlanOverlay'] == True else None
                      switch_facts["network_services"] = {
                          "l2": False,
                          "l3": True
                      }
                  # Overwrite spline defaults with custom settings
                  spline_defaults = site_details['splineDefaults']['defaultSplineProperties']
                  # Set custom EVPN role
                  if spline_defaults.get('splineEvpnRoleDefault', '').strip() != "":
                      switch_facts['evpn_role'] = True if spline_defaults['splineEvpnRoleDefault'] == "Yes" else False
                  # Set custom MLAG support role
                  if spline_defaults.get('splineMlagSupportDefault', '').strip() != "":
                      switch_facts['mlag_support'] = True if spline_defaults['splineMlagSupportDefault'] == "Yes" else False
                  # Set custom Vtep role
                  if spline_defaults.get('splineVtepDefault', '').strip() != "":
                      switch_facts['vtep'] = True if spline_defaults['splineVtepDefault'] == "Yes" else False
                  # Set custom Connnected Endpoints role
                  if spline_defaults.get('splineConnectedEndpointsDefault', '').strip() != "":
                      switch_facts['connected_endpoints'] = True if spline_defaults['splineConnectedEndpointsDefault'] == "Yes" else False
                  # Set custom L2 Network Services role
                  if spline_defaults.get('splineL2NetworkServicesDefault', '').strip() != "":
                      switch_facts['network_services']['l2'] = True if spline_defaults['splineL2NetworkServicesDefault'] == "Yes" else False
                  # Set custom L3 Network Services role
                  if spline_defaults.get('splineL3NetworkServicesDefault', '').strip() != "":
                      switch_facts['network_services']['l3'] = True if spline_defaults['splineL3NetworkServicesDefault'] == "Yes" else False

              # If switch still hasn't been found, check to see if it is a leaf
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  # Get Campus-Pod tag
                  switch_facts['campus_pod'] = campus_pod_dict.get(device_id)
                  if switch_facts['campus_pod'] is None:
                      ctx.info(f"{switch_facts['hostname']} does not have a Campus-Pod tag applied.")
                      return
                  pod_details = site_details["campusPods"].resolve(device=device_id)['campusPodFacts']
                  switch_facts["group"] = switch_facts['campus_pod']
                  switch_facts["group_index"] = int(pod_details['podId']) - 1
                  # Set leaf switch facts if device is a leaf
                  if switch_facts["type"] == "leaf":
                      if site_details["campusPodDetails"]["uplinkType"] == "port-channel":
                          switch_facts["vtep"] = False
                          switch_facts["mlag_support"] = True
                          switch_facts["evpn_role"] = None
                          switch_facts["underlay_router"] = False
                          switch_facts["uplink_type"] = "port-channel"
                          switch_facts["network_services"] = {
                              "l2": True,
                              "l3": False
                          }
                      elif site_details["campusPodDetails"]["uplinkType"] == "p2p":
                          switch_facts["vtep"] = True
                          switch_facts["mlag_support"] = True
                          switch_facts["underlay_router"] = True
                          switch_facts["evpn_role"] = "client"
                          switch_facts["uplink_type"] = "p2p"
                          switch_facts["network_services"] = {
                              "l2": True,
                              "l3": True
                          }
                  # Set member-leaf switch facts if device is a member-leaf
                  else:
                      ## switch_facts["type"] = "memberleaf"
                      switch_facts["vtep"] = False
                      switch_facts["mlag_support"] = False
                      switch_facts["underlay_router"] = False
                      switch_facts["evpn_role"] = None
                      switch_facts["uplink_type"] = "port-channel"
                      switch_facts["network_services"] = {
                          "l2": True,
                          "l3": False
                      }

              # Normalize names
              if switch_facts.get('campus'):
                  switch_facts['campus'] = switch_facts['campus'].replace(" ", "_")
              if switch_facts.get('site'):
                  switch_facts['site'] = switch_facts['site'].replace(" ", "_")
              if switch_facts.get('campus_pod'):
                  switch_facts['campus_pod'] = switch_facts['campus_pod'].replace(" ", "_")
              if switch_facts.get('group'):
                  switch_facts['group'] = switch_facts['group'].replace(" ", "_")
              # Return switch_facts if switch was found in studios input
              if switch_facts.get("type") is not None:
                  return switch_facts


          def get_switches_in_my_campus_basics(switch_facts):
              # Dictionary of switches that will be returned
              switches_in_my_campus = {}

              #Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              #Get switches in same Campus
              query= "{}:\"{}\"".format("Campus", switch_facts["campus"])
              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
              for match in tagmresp.matches:
                  switch_in_my_campus_facts = get_switch_basics(match.device.device_id, campus)
                  if switch_in_my_campus_facts is None:
                      continue
                  if match.device.device_id not in switches_in_my_campus:
                      switches_in_my_campus[match.device.device_id] = switch_in_my_campus_facts
              return switches_in_my_campus


          def set_switch_facts(switch_facts, campus_resolver):
              device_id = switch_facts["serial_number"]
              campus_resolved = campus.resolve(device=device_id)
              site_details = campus_resolved["campusDetails"]["site"].resolve(device=device_id)["siteFacts"]
              # Get interface info from studio topology tags
              uplink_interfaces = switch_facts["uplink_interfaces"]
              downlink_interfaces = switch_facts["downlink_interfaces"]
              mlag_peer_link_interfaces = switch_facts["mlag_peer_link_interfaces"]

              # Get fabric details
              if switch_facts["underlay_router"] == True:
                  switch_facts["underlay_routing_protocol"] = site_details["siteUnderlayRoutingProtocol"].lower()
                  if site_details["overlayDetails"].get("vxlanOverlay") == True:
                      switch_facts["overlay_routing_protocol"] = "bgp"
                  else:
                      switch_facts["overlay_routing_protocol"] = ""

              # Get spanning tree details
              if switch_facts["network_services"].get("l2"):
                  switch_facts["spanning_tree_mode"] = site_details["defaultSpanningTreeDetails"].get("spanningTreeMode", "").lower()
                  switch_facts["spanning_tree_priority"] = site_details["defaultSpanningTreeDetails"].get("defaultSpanningTreePriority")

              # Get virtual router mac
              if switch_facts["network_services"]["l2"] == True and \
                  switch_facts["network_services"]["l3"] == True:
                  switch_facts["virtual_router_mac_address"] = site_details["mlagConfiguration"]["virtualRouterMacAddress"]

              # Define switch uplink info
              switch_facts["uplink_switches_ids"] = [ info["neighborId"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switches"] = [ info["neighborHostname"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switch_interfaces"] = [ info["neighborInterface"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_interfaces"] = [ iface for iface in uplink_interfaces.keys() ]

              # Define switch downlink neighbor ids
              switch_facts["downlink_switches_ids"] = [ info["neighborId"] for info in downlink_interfaces.values() ]

              # Get mlag settings
              if switch_facts["mlag_support"] == True:
                  if len(mlag_peer_link_interfaces) > 0:
                      switch_facts["mlag"] = True
                  else:
                      switch_facts["mlag"] = False

                  if switch_facts["mlag"] == True:
                      if switch_facts["type"] == "spline":
                          switch_facts["mlag_group"] = "Splines"
                      elif switch_facts["type"] == "leaf":
                          switch_facts["mlag_group"] = f"Pod{switch_facts['group']}"
                      if switch_facts["underlay_router"] == True:
                          switch_facts["mlag_l3"] = True
                      else:
                          switch_facts["mlag_l3"] = False
                      switch_facts["mlag_peer_vlan"] =  site_details["mlagConfiguration"]["mlagPeerLinkVlan"]
                      switch_facts["mlag_peer_ipv4_pool"] = site_details["mlagConfiguration"]["mlagPeerIPv4Pool"]
                      switch_facts["mlag_subnet_mask"] = site_details["mlagConfiguration"]["mlagSubnetMask"]
                      # Set mlag_peer_l3_vlan if there is value set in studio input
                      if site_details['mlagConfiguration']['mlagPeerL3Vlan'] is not None \
                              and site_details['mlagConfiguration']['mlagPeerL3IPv4Pool'].strip() != "" \
                              and site_details['mlagConfiguration']['mlagPeerL3SubnetMask'] is not None:
                          switch_facts['mlag_peer_l3_vlan'] = site_details['mlagConfiguration']['mlagPeerL3Vlan']
                          switch_facts['mlag_peer_l3_ipv4_pool'] = site_details['mlagConfiguration']['mlagPeerL3IPv4Pool']
                          switch_facts['mlag_l3_subnet_mask'] = site_details['mlagConfiguration']['mlagPeerL3SubnetMask']

                      else:
                          switch_facts['mlag_peer_l3_vlan'] = switch_facts['mlag_peer_vlan']
                          switch_facts[''] = switch_facts["mlag_peer_ipv4_pool"]
                          switch_facts['mlag_l3_subnet_mask']= switch_facts["mlag_subnet_mask"]

                      switch_facts["mlag_port_channel_id"] = site_details["mlagConfiguration"]["mlagPortChannelId"]
                      switch_facts["mlag_lacp_mode"] = site_details["mlagConfiguration"]["lacpMode"]
                      switch_facts["reload_delay_mlag"] = 300
                      switch_facts["reload_delay_non_mlag"] = 330
                      switch_facts["mlag_ibgp_origin_incomplete"] = True
                      switch_facts["mlag_peer_serial_number"] = [ info["neighborId"] for info in mlag_peer_link_interfaces.values() ][0]
                      mlag_peer_switch_facts = switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
                      switch_facts["mlag_peer"] = mlag_peer_switch_facts["hostname"]
                      switch_facts["mlag_peer_switch_interfaces"] = [ info["neighborInterface"] for info in mlag_peer_link_interfaces.values() ]
                      switch_facts["mlag_interfaces"] = [ iface for iface in mlag_peer_link_interfaces.keys() ]
                      if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                          switch_facts["mlag_primary_id"] = int(switch_facts["id"])
                          switch_facts["mlag_role"] = "primary"
                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "primary"))
                          switch_facts["mlag_l3_ip"] = switch_facts["mlag_ip"]
                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "secondary"))
                          switch_facts["mlag_peer_l3_ip"] = switch_facts["mlag_peer_ip"]
                      else:
                          switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])
                          switch_facts["mlag_role"] = "secondary"
                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "secondary"))
                          switch_facts["mlag_l3_ip"] = switch_facts["mlag_ip"]
                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "primary"))
                          switch_facts["mlag_peer_l3_ip"] = switch_facts["mlag_peer_ip"]

              if switch_facts["underlay_router"] == True:
                  # Parse user inputs to get transit ips and router ids
                  switch_facts["uplink_ipv4_pool"] = site_details["campusPodDetails"]["uplinkIpv4Pool"]
                  switch_facts["uplink_ipv4_subnet_mask"] = 31  # site_details["routingDetails"]["fabricChildSubnetsMask"]
                  if switch_facts["type"] == "spline":
                      switch_facts["loopback_ipv4_pool"] = site_details["splineDefaults"]["routerIdPool"]
                      switch_facts["loopback_ipv4_offset"] = 0
                  elif switch_facts["type"] == "leaf":
                      switch_facts["loopback_ipv4_pool"] = site_details["campusPodDetails"]["routerIdPool"]
                      if site_details["splineDefaults"]["routerIdPool"] == site_details["campusPodDetails"]["routerIdPool"]:
                          # Calculate offset
                          switch_facts["loopback_ipv4_offset"] = get_highest_spline_node_id_in_my_site(switch_facts)
                      else:
                          # Offset is 0
                          switch_facts["loopback_ipv4_offset"] = 0
                  # Get Router ID
                  switch_facts["router_id"] = str(get_router_id(switch_facts))
                  # Set BGP parameters
                  if switch_facts["underlay_routing_protocol"] == "bgp" or switch_facts["overlay_routing_protocol"] == "bgp":
                      if switch_facts["type"] == "spline":
                          asns = string_to_list(str(site_details["splineDefaults"]["splineBgpAs"]))
                          if len(asns) > 1:
                              switch_facts["bgp_as"] = asns[switch_facts["group_index"]]
                          else:
                              switch_facts["bgp_as"] = asns[0]
                          switch_facts["bgp_defaults"] = site_details["splineDefaults"]["splineDefaults"]
                          switch_facts["bgp_maximum_paths"] = 4
                          switch_facts["bgp_ecmp"] = 4
                      elif switch_facts["type"] == "leaf":
                          if switch_facts.get("bgp_as") is None:
                              asns = string_to_list(str(site_details["campusPodDetails"]["bgpAsRange"]))
                              if len(asns) > 1:
                                  # remove any manually set bgp_as numbers
                                  manually_set_leaf_domains = {}
                                  for switch_in_my_campus_facts in switches_in_my_campus.values():
                                      if manually_set_leaf_domains.get(switch_facts["group_index"]):
                                          switch_facts["bgp_as"] = manually_set_leaf_domains[switch_facts["group_index"]]
                                          break
                                      if switch_in_my_campus_facts.get("bgp_as") is not None and switch_in_my_campus_facts["bgp_as"] in asns:
                                          if int(switch_in_my_campus_facts["group_index"]) not in manually_set_leaf_domains:
                                              manually_set_leaf_domains[int(switch_in_my_campus_facts["group_index"])] = switch_in_my_campus_facts["bgp_as"]
                                              asns.remove(switch_in_my_campus_facts["bgp_as"])

                                  # check to see if this switch's leaf_domain is already set
                                  if not switch_facts.get("bgp_as"):
                                      # get leaf_domain shift
                                      leaf_domain_shift = len([ld for ld in manually_set_leaf_domains.keys() if ld < int(switch_facts["group_index"])])
                                      # set bgp_as
                                      switch_facts["bgp_as"] = asns[int(switch_facts["group_index"]) - leaf_domain_shift]
                              else:
                                  switch_facts["bgp_as"] = asns[0]
                          switch_facts["bgp_defaults"] = site_details["campusPodDetails"]["campusPodDefaults"]
                          switch_facts["bgp_maximum_paths"] = get_highest_spline_node_id_in_my_site(switch_facts)
                          switch_facts["bgp_ecmp"] = get_highest_spline_node_id_in_my_site(switch_facts)
                      switch_facts["evpn_route_servers"] = switch_facts["uplink_switches"]
                      switch_facts["evpn_route_server_ids"] = switch_facts["uplink_switches_ids"]
                  # Set ospf parameters
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      switch_facts["underlay_ospf_process_id"] = site_details["ospfConfiguration"]["processId"]
                      switch_facts["underlay_ospf_area"] = site_details["ospfConfiguration"]["area"]
                      switch_facts["underlay_ospf_max_lsa"] = site_details["ospfConfiguration"]["maxLsa"]
                      switch_facts["underlay_ospf_bfd_enable"] = site_details["ospfConfiguration"]["bfd"]
                      if switch_facts["type"] == "spline":
                          switch_facts["ospf_defaults"] = site_details["splineDefaults"]["splinesOspfDefaults"]
                      elif switch_facts["type"] == "leaf":
                          switch_facts["ospf_defaults"] = site_details["campusPodDetails"]["leafsOspfDefaults"]
                  if switch_facts["vtep"] and site_details["overlayDetails"]["vxlanOverlay"] == True:
                      switch_facts["vtep_loopback_ipv4_pool"] = site_details["overlayDetails"]["vtepAddressRange"]
                      switch_facts["vtep_loopback"] = "Loopback1"
                      if site_details["splineDefaults"].get("vtep"):
                          vtep_offset = 1
                      else:
                          vtep_offset = 0
                      switch_facts["vtep_ip"] =  str(get_vtep_loopback(switch_facts, offset=vtep_offset))
                  else:
                      # Turn off the vtep setting since there are no VTEPs in this network
                      switch_facts["vtep"] = False

              # Get inband management details
              if site_details.get("inbandManagement"):
                  switch_facts["inband_management_subnet"] = site_details["inbandManagement"].get("managementSubnet")
                  switch_facts["inband_management_vlan"] = site_details["inbandManagement"].get("vlanId")
              if switch_facts.get("inband_management_subnet") and switch_facts.get("inband_management_vlan"):
                  switch_facts["inband_management_interface"] = "Vlan{}".format(switch_facts["inband_management_vlan"])
                  switch_facts["inband_management_ip"] = "{}/{}".format(
                      str(get_inband_management_ip(switch_facts)),
                      str(ipaddress.ip_network(switch_facts["inband_management_subnet"]).prefixlen)
                  )
                  switch_facts["inband_management_gateway"] = str(list(ipaddress.ip_network(switch_facts["inband_management_subnet"])).hosts(0))

              ## if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3") and \
              ##     version.parse(switch_facts["eos_version"]) >= version.parse("4.27.1F"):
              ##     switch_facts["boot_vlan"] = switch_facts.get("inband_management_vlan")

              if re.match(veos_regex, switch_facts["platform"]):
                  switch_facts["p2p_uplinks_mtu"] = 1500
              else:
                  switch_facts["p2p_uplinks_mtu"] = 9214

              for regex in jericho_platform_regexes:
                  if re.search(regex, switch_facts["platform"]):
                      switch_facts["reload_delay_mlag"] = 780
                      switch_facts["reload_delay_non_mlag"] = 1020
                      break

              return switch_facts


          def set_base_config(config, switch_facts):
              # Set spanning tree
              if switch_facts.get("spanning_tree_mode"):
                  config["spanning_tree"]["mode"] = switch_facts["spanning_tree_mode"]
                  if switch_facts.get("spanning_tree_priority"):
                      if config["spanning_tree"]["mode"] == "mstp":
                          config["spanning_tree"]["mst_instances"] = {
                              0: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                      elif config["spanning_tree"]["mode"] == "rapid-pvst":
                          config["spanning_tree"]["rapid_pvst_instances"] = {
                              1: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                      elif config["spanning_tree"]["mode"] == "rstp":
                          config["spanning_tree"]["rstp_priority"] = switch_facts["spanning_tree_priority"]

              # Set tcam profile
              for regex in jericho_platform_regexes:
                  if re.search(regex, switch_facts["platform"]):
                      config["tcam_profile"] = {
                          "system": "vxlan-routing"
                      }
                      break
              # Set routing
              config["service_routing_protocols_model"] = "multi-agent"
              if switch_facts["underlay_router"] == True:
                  config["ip_routing"] = True
                  if switch_facts.get("underlay_multicast"):
                      config["router_multicast"] = {
                          "ipv4": {
                              "routing": True
                          }
                      }
              # Set router-bgp
              if switch_facts["underlay_router"] == True \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  config["router_bgp"]["as"] = switch_facts["bgp_as"]
                  config["router_bgp"]["router_id"] = switch_facts["router_id"]
                  config["router_bgp"]["bgp_defaults"] = switch_facts["bgp_defaults"]
                  if switch_facts.get("bgp_maximum_paths"):
                      config["router_bgp"]["maximum_paths"] = switch_facts["bgp_maximum_paths"]
                  if switch_facts.get("bgp_ecmp"):
                      config["router_bgp"]["ecmp"] = switch_facts["bgp_ecmp"]
              return config


          def set_mlag_config(config, switch_facts):
              if switch_facts.get("mlag"):
                  # Set spanning tree relevant config
                  config["spanning_tree"]["no_spanning_tree_vlan"] = switch_facts["mlag_peer_vlan"]

                  # Set mlag vlan
                  config["vlans"][switch_facts["mlag_peer_vlan"]] = {
                      "tenant": "system",
                      "name": "MLAG_PEER",
                      "trunk_groups": ["MLAG_PEER"]
                  }

                  # Set mlag svi
                  config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])] = {
                      "description": "MLAG PEER",
                      "shutdown": False,
                      "ip_address": "{}/{}".format(switch_facts["mlag_ip"], switch_facts["mlag_subnet_mask"]),
                      "no_autostate": True,
                      "mtu": switch_facts["p2p_uplinks_mtu"]
                  }
                  if switch_facts["mlag_l3"] == True and switch_facts["underlay_routing_protocol"] == "ospf":
                      config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])]\
                          ["ospf_network_point_to_point"] = True
                      config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])]\
                          ["ospf_area"] = switch_facts["underlay_ospf_area"]

                  # Set port-channel interfaces
                  config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])] = {
                      "description": "to {}".format(switch_facts["mlag_peer"]),
                      "type": "switched",
                      "shutdown": False,
                      "mode": "trunk",
                      "trunk_groups": ["MLAG_PEER"]
                  }

                  # Set ethernet interfaces
                  for i, iface in enumerate(switch_facts["mlag_interfaces"]):
                      config["ethernet_interfaces"][iface] = {
                          "peer": switch_facts["mlag_peer"],
                          "peer_interface": switch_facts["mlag_peer_switch_interfaces"][i],
                          "peer_type": "mlag",
                          "description": "MLAG_{}_{}".format(switch_facts["mlag_peer"], switch_facts["mlag_peer_switch_interfaces"][i]),
                          "type": "switched",
                          "shutdown": False,
                          "channel_group": {
                              "id": switch_facts["mlag_port_channel_id"],
                              "mode": switch_facts["mlag_lacp_mode"]
                          }
                      }

                  # Set mlag config
                  config["mlag_configuration"] = {
                      "enabled": True,
                      "domain_id": switch_facts["mlag_group"],
                      "local_interface": "Vlan{}".format(switch_facts["mlag_peer_vlan"]),
                      "peer_address": switch_facts["mlag_peer_ip"],
                      "peer_link": "Port-Channel{}".format(switch_facts["mlag_port_channel_id"]),
                      "reload_delay_mlag": switch_facts["reload_delay_mlag"],
                      "reload_delay_non_mlag": switch_facts["reload_delay_non_mlag"]
                  }

                  # Set route maps
                  # Origin Incomplete for MLAG iBGP learned routes
                  if switch_facts["mlag_l3"] == True and \
                      switch_facts["mlag_ibgp_origin_incomplete"] == True and \
                      switch_facts["underlay_routing_protocol"] == "bgp":
                      config["route_maps"]["RM-MLAG-PEER-IN"] = {
                          "sequence_numbers": {
                              10: {
                                  "type": "permit",
                                  "set": ["origin incomplete"],
                                  "description": "Make routes learned over MLAG Peer-link less preferred on spines to ensure optimal routing"
                              }
                          }
                      }

                  # Set bgp config
                  if switch_facts["mlag_l3"] == True and switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]] = {
                          "type": "ipv4",
                          "remote_as": switch_facts["bgp_as"],
                          "next_hop_self": True,
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["password"] is not None:
                          config["router_bgp"]["peer_groups"] \
                              [fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]]["password"] = \
                              fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["password"]
                      if switch_facts["mlag_ibgp_origin_incomplete"] == True:
                          config["router_bgp"]["peer_groups"] \
                              [fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]]["route_map_in"] = \
                              "RM-MLAG-PEER-IN"
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]] = {
                          "activate": True
                      }
                      config["router_bgp"]["neighbor_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_l3_vlan"])] = {
                          "peer_group": fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"],
                          "remote_as": switch_facts["bgp_as"],
                          "description": switch_facts["mlag_peer"]
                      }
                      config["router_bgp"]["neighbors"][switch_facts["mlag_peer_l3_ip"]] = {
                          "peer_group": fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"],
                          "description": switch_facts["mlag_peer"]
                      }
              return config


          def set_underlay_config(config, switch_facts):
              underlay_data = {}
              underlay_data["links"] = switch_facts["topology"]["links"]
              # First add interface details from devices whose uplink interface neighbors are this switch
              for sn in switch_facts["downlink_switches_ids"]:
                  neighbor_switch_facts = switches_in_my_campus[sn]
                  for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                      if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                          link = {}
                          link["peer_id"] = neighbor_switch_facts["serial_number"]
                          link["peer"] = neighbor_switch_facts["hostname"]
                          link["peer_interface"] = neighbor_link
                          link["peer_type"] = neighbor_switch_facts["type"]
                          link["peer_bgp_as"] = neighbor_switch_facts.get("bgp_as")
                          link["type"] = neighbor_link_info["type"]
                          link["ip_address"] = neighbor_link_info.get("peer_ip_address")
                          link["peer_ip_address"] = neighbor_link_info.get("ip_address")
                          link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                          link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                          link["channel_description"] = neighbor_link_info.get("peer_channel_description")
                          link["pim_enabled"] = neighbor_link_info.get("pim_enabled")
                          interface = neighbor_link_info["peer_interface"]
                          underlay_data["links"][interface] = link

              # Set Ethernet interfaces
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_p2p":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "P2P_LINK_TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "type": "routed",
                          "shutdown": False,
                          "ip_address": "{}/{}".format(link["ip_address"], switch_facts["uplink_ipv4_subnet_mask"])
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["ethernet_interfaces"][iface]["ospf_network_point_to_point"] = True
                          config["ethernet_interfaces"][iface]["ospf_area"] = switch_facts["underlay_ospf_area"]
                      if link.get("pim_enabled"):
                          config["ethernet_interfaces"][iface]["pim"] = {
                              "ipv4": {"sparse_mode": True}
                          }
                  elif link["type"] == "underlay_l2":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "type": "routed",
                          "shutdown": False
                      }
                      if switch_facts.get("boot_vlan"):
                          config["ethernet_interfaces"][iface]["boot_vlan"] = switch_facts["boot_vlan"]

                      if link.get("channel_group_id"):
                          config["ethernet_interfaces"][iface]["channel_group"] = {
                              "id": link["channel_group_id"],
                              "mode": "active"
                          }

              # Set Port-Channel interfaces
              port_channel_list = [] # go through this
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_l2" and \
                     link.get("channel_group_id") and \
                     link.get("channel_group_id") not in port_channel_list:
                      port_channel_list.append(link["channel_group_id"])
                      config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])] = {
                          "description": "{}_Po{}".format(link["peer"].upper(), link.get("peer_channel_group_id")),
                          "type": "switched",
                          "shutdown": False,
                          "mode": "trunk",
                          "mlag": link["channel_group_id"]
                      }
              # L2 and L3
              if switch_facts["network_services"]["l2"] == True and \
                  switch_facts["network_services"]["l3"] == True:
                  # set viritual router mac address
                  config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"]

              # Routing
              if switch_facts["underlay_router"] == True:
                  # Set loopback interfaces
                  if switch_facts.get("router_id"):
                      config["loopback_interfaces"]["Loopback0"] = {
                          "description": "ROUTER_ID",
                          "shutdown": False,
                          "ip_address": "{}/32".format(switch_facts["router_id"]),
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"]["Loopback0"]["ospf_area"] = switch_facts["underlay_ospf_area"]
                  if switch_facts["vtep"] == True:
                      config["loopback_interfaces"][switch_facts["vtep_loopback"]] = {
                         "description": "VTEP_VXLAN_Tunnel_Source",
                         "shutdown": False,
                         "ip_address": "{}/32".format(switch_facts["vtep_ip"])
                      }
                      if switch_facts.get("vtep_vvtep_ip") and switch_facts.get("evpn_services_l2_only") is not None and \
                          switch_facts.get("evpn_services_l2_only") == False:
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]] = [switch_facts["vtep_vvtep_ip"] ]
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]]["ospf_area"] = switch_facts["underlay_ospf_area"]

                  # Set bgp if necessary
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "type": "ipv4",
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"] is not None:
                          config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] \
                              ["password"] = fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"]
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "activate": True,
                      }
                      config["router_bgp"]["redistribute_routes"]["connected"] = {
                          "route_map": "RM-CONN-2-BGP"
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_bgp"]["neighbors"][link["peer_ip_address"]] = {
                                  "peer_group": fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"],
                                  "remote_as": link["peer_bgp_as"],
                                  "description": "{}_{}".format(link["peer"], link["peer_interface"])
                              }
                      # Create prefix lists
                      config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"] = {
                          "sequence_numbers": {
                              10: {
                                  "action": "permit {} eq 32".format(switch_facts["loopback_ipv4_pool"])
                              }
                          }
                      }
                      if switch_facts.get("vtep_ip") is not None:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][20] = {
                              "action": "permit {} eq 32".format(switch_facts["vtep_loopback_ipv4_pool"])
                          }
                      if switch_facts.get("vtep_vvtep_ip") is not None \
                         and switch_facts.get("evpn_services_l2_only") is not None \
                         and switch_facts.get("evpn_services_l2_only") == False:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][30] = {
                              "action": "permit {}".format(switch_facts["vtep_vvtep_ip"])
                          }
                      # Create route-maps
                      config["route_maps"]["RM-CONN-2-BGP"] = {
                          "sequence_numbers": {
                              10: {
                                  "type": "permit",
                                  "match": ["ip address prefix-list PL-LOOPBACKS-EVPN-OVERLAY"]
                              }
                          }
                      }
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      config["router_ospf"]["process_ids"] = {
                          switch_facts["underlay_ospf_process_id"]: {
                              "passive_interface_default": True,
                              "router_id": switch_facts["router_id"],
                              "no_passive_interfaces": [],
                              "max_lsa": switch_facts["underlay_ospf_max_lsa"],
                              "ospf_defaults": switch_facts["ospf_defaults"]
                          }
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append(iface)
                      if switch_facts.get("mlag_l3") is not None and switch_facts.get("mlag_l3") == True:
                          config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append("Vlan{}".format(switch_facts["mlag_peer_l3_vlan"]))
                      if switch_facts["underlay_ospf_bfd_enable"] == True:
                          config["bfd_enable"] = True

              return config


          def set_overlay_config(config, switch_facts):
              if not switch_facts.get("underlay_router"):
                  return config
              if switch_facts["overlay_routing_protocol"] != "bgp":
                  return config

              overlay_data = {}
              # Set evpn route servers
              overlay_data["evpn_route_servers"] = {}
              for rs_id in switch_facts["evpn_route_server_ids"]:
                  rs_switch_facts = switches_in_my_campus[rs_id]
                  if rs_switch_facts["evpn_role"] == "server":
                      server = {
                          "bgp_as": rs_switch_facts["bgp_as"],
                          "ip_address": rs_switch_facts["router_id"]
                      }
                      overlay_data["evpn_route_servers"][rs_switch_facts["hostname"]] = server

              # Set evpn route clients
              overlay_data["evpn_route_clients"] = {}
              if switch_facts["evpn_role"] == "server":
                  for campus_switch_facts in switches_in_my_campus.values():
                      if campus_switch_facts["evpn_role"] is not None and campus_switch_facts["evpn_role"] == "client":
                          if switch_facts['serial_number'] in campus_switch_facts["evpn_route_server_ids"]:
                              client = {
                                  "bgp_as": campus_switch_facts["bgp_as"],
                                  "ip_address": campus_switch_facts["router_id"]
                              }
                              overlay_data["evpn_route_clients"][campus_switch_facts["hostname"]] = client

              # Set ebgp
              config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "type": "evpn",
                  "update_source": "Loopback0",
                  "bfd": True,
                  "ebgp_multihop": str(fabric_variables["evpn_ebgp_multihop"]),
                  "send_community": "all",
                  "maximum_routes": 0,
              }
              if switch_facts["evpn_role"] == "server":
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["next_hop_unchanged"] = True
              if fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"] is not None:
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["password"] = fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"]
              config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": False
              }
              config["router_bgp"]["address_family_evpn"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": True
              }
              if switch_facts.get("vtep_ip") and fabric_variables["evpn_hostflap_detection"]["enabled"] == True:
                  config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"] = {
                      "window": fabric_variables["evpn_hostflap_detection"]["window"],
                      "threshold": fabric_variables["evpn_hostflap_detection"]["threshold"],
                      "enabled": fabric_variables["evpn_hostflap_detection"]["enabled"]
                  }
              # Overlay network peering
              for rs, info in overlay_data["evpn_route_servers"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": rs,
                      "remote_as": info["bgp_as"]
                  }
              for cs, info in overlay_data["evpn_route_clients"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": cs,
                      "remote_as": info["bgp_as"]
                  }
              return config


          def set_vxlan_config(config, switch_facts):
              if switch_facts.get("vtep") == True:
                  config["vxlan_interface"] = {
                      "Vxlan1": {
                          "description": "{}_VTEP".format(switch_facts["hostname"]),
                          "vxlan": {
                              "source_interface": switch_facts["vtep_loopback"],
                              "udp_port": 4789
                          }
                      }
                  }
                  if switch_facts.get("mlag"):
                      config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] = "mlag-system-id"
              return config


          # returns dictionary of device to label value based on workspace tag assignments
          def populate_single_value_dict(workspace_id, label):
              sv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      sv_dict[match.device.device_id] = tag.value
              return sv_dict


          # returns dictionary of device to label values based on workspace tag assignments
          def populate_multi_value_dict(workspace_id, label):
              mv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      mv_dict.setdefault(match.device.device_id, []).append(tag.value)
              return mv_dict


          def set_network_services_config(config, switch_facts):
             # Configure vlans
              if switch_facts["network_services"].get("l2"):
                  # Enable dhcp smart relay
                  config["ip_dhcp_relay"] = {
                     "information_option": True
                  }
                  # Set l3 vlan config
                  for vrf in switch_facts["vrfs"].keys():
                      for svi in switch_facts["vrfs"][vrf]["svis"].keys():  # Refer each vlan assosciated with the VRF
                         #Create L3 vlans
                          config["vlans"][svi] = {
                             "name": switch_facts["vrfs"][vrf]["svis"][svi]["name"]
                          }
                          # Create L3 SVI with helper address pointing towards CVP
                          config["vlan_interfaces"]["Vlan{}".format(svi)] = {}
                          # config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                          #     "127.0.0.1": {}
                          # }
                          # # enable snooping on that vlan
                          # config["ip_dhcp_snooping"]["vlans"].append(svi)

                      # Set vrf ibgp peering vlan params
                      if switch_facts.get("mlag") and switch_facts["network_services"].get("l3") \
                          and switch_facts["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                          config["vlans"][ibgp_vlan] = {
                              "name": "MLAG_iBGP_{}".format(vrf),
                              "trunk_groups": ["MLAG_VRF_PEER"]
                          }

                  # Set l2 vlan config
                  for vlan, info in switch_facts["l2vlans"].items():
                      config["vlans"][vlan] = {
                          "name": info["name"]
                      }
                      # Create L2 SVI with helper address pointing towards CVP
                      # config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                      #     "127.0.0.1": {}
                      # }
                      # enable snooping on the vlan
                      # config["ip_dhcp_snooping"]["vlans"].append(vlan)


                  if switch_facts["allow_all_vlans"] == False:
                      # Get transit port-channels to be set for allowed_vlans
                      underlay_data = {}
                      underlay_data["links"] = switch_facts["topology"]["links"]
                      # First add interface details from devices whose uplink interface neighbors are this switch
                      for sn in switch_facts["downlink_switches_ids"]:
                          neighbor_switch_facts = switches_in_my_campus[sn]
                          for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                              if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                                  link = {}
                                  link["peer_id"] = neighbor_switch_facts["serial_number"]
                                  link["peer"] = neighbor_switch_facts["hostname"]
                                  link["peer_interface"] = neighbor_link
                                  link["type"] = neighbor_link_info["type"]
                                  link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                                  link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                                  link["allowed_vlans"] = neighbor_link_info.get("allowed_vlans")
                                  interface = neighbor_link_info["peer_interface"]
                                  underlay_data["links"][interface] = link
                      # set transit port-channel interfaces
                      port_channel_list=[]
                      for iface in underlay_data["links"]:
                          link = underlay_data["links"][iface]
                          if link["type"] == "underlay_l2" and \
                          link.get("channel_group_id") and \
                          link.get("channel_group_id") not in port_channel_list:
                              port_channel_list.append(link["channel_group_id"])
                              functionadd = {
                                  "mode": "trunk",
                                  "vlans": list_compress(link["allowed_vlans"])
                                  }
                              config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])].update(functionadd)

              # if mlag is enabled
              # if switch_facts.get("mlag"):
              #     # Get mlag_peer_switch facts
              #     mlag_peer_switch_facts = switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
              #     # Initialize mlag port-channel interface for ibgp trunk groups
              #     config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])] = {"trunk_groups": []} # go through this

              if switch_facts["network_services"].get("l3"):
                  for vrf, info in switch_facts["vrfs"].items():
                      if vrf == "default":
                          config["ip_routing"] = True
                      else:
                          # configure vrfs
                          config["vrfs"][vrf] = {
                              "ip_routing": True
                          }
                      # configure static routes
                      if info.get("static_routes") is not None:
                          for static_route in info["static_routes"]:
                              sr = {
                                  "destination_address_prefix": static_route["destination_address_prefix"],
                                  "vrf": vrf
                              }
                              if static_route.get("gateway") and static_route["gateway"].strip() != "":
                                  sr["gateway"] = static_route["gateway"]
                              if static_route.get("distance"):
                                  sr["distance"] = str(static_route["distance"])
                              if static_route.get("tag"):
                                  sr["tag"] = str(static_route["tag"])
                              if static_route.get("name") and static_route["name"].strip() != "":
                                  sr["name"] = static_route["name"]
                              if static_route.get("metric"):
                                  sr["metric"] = str(static_route["metric"])
                              if static_route.get("interface") and static_route["interface"].strip() != "":
                                  sr["interface"] = static_route["interface"]
                              config["static_routes"].append(sr)


                      # configure route maps
                      if info.get("bgp_peers"):
                          for peer, peer_info in info["bgp_peers"].items():
                              if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                  config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)] = {
                                      "sequence_numbers": {
                                          10: {
                                              "type": "permit",
                                              "set": []
                                          }
                                      }
                                  }
                                  if peer_info.get("set_ipv4_next_hop"):
                                      config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                      ["sequence_numbers"][10]["set"].append(f"ip next-hop {peer_info['set_ipv4_next_hop']}")
                                  elif peer_info.get("set_ipv6_next_hop"):
                                      config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                      ["sequence_numbers"][10]["set"].append(f"ipv6 next-hop {peer_info['set_ipv6_next_hop']}")

                      if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3"):
                          # configure svis
                          for svi, svi_info in switch_facts["vrfs"][vrf]["svis"].items():
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["vrf"] = vrf

                              # Configure VIP and IP
                              if svi_info.get("ip_address_virtual"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_address_virtual"] = svi_info["ip_address_virtual"]
                              if svi_info.get("ip_virtual_router_address"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_virtual_router_address"] = svi_info["ip_virtual_router_address"]
                              if svi_info.get("ip_address"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_address"] = svi_info["ip_address"]

                              # Add any ip helper addresses
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {}
                              if svi_info.get("ip_helpers"):
                                  for helper_address, dhcp_info in svi_info["ip_helpers"].items():
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"][helper_address] = {
                                          "source_interface": dhcp_info.get("source_interface")
                                      }
                              # if mtu
                              if svi_info.get("mtu"): # Size of the frames
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["mtu"] = svi_info["mtu"]
                              # if arp aging timeout
                              if svi_info.get("arp"):
                                  if svi_info["arp"].get("aging_timeout"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["arp_aging_timeout"] = svi_info["arp"]["aging_timeout"]
                              # configure eos_cli statements
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["eos_cli"] = svi_info["eos_cli"]

                      # configure vrf ibgp mlag peer interface
                      if switch_facts.get("mlag") \
                          and info.get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = info["mlag_ibgp_peering_vlan"]
                          ibgp_peering_subnet = info["mlag_ibgp_peering_subnet"]
                          ibgp_peering_subnet_mask = info["mlag_ibgp_peering_subnet_mask"]
                          mlag_ip = str(get_mlag_ip(
                                  switch_facts,
                                  ibgp_peering_subnet,
                                  ibgp_peering_subnet_mask,
                                  switch_facts["mlag_role"]
                                  )
                              )
                          config["vlan_interfaces"]["Vlan{}".format(ibgp_vlan)] = {
                              "type": "underlay_peering",
                              "shutdown": False,
                              "description": "MLAG_PEER_L3_iBGP:{}".format(vrf),
                              "vrf": vrf,
                              "ip_address": "{}/{}".format(mlag_ip, ibgp_peering_subnet_mask)
                          }
                          if "MLAG_VRF_PEER" not in config["port_channel_interfaces"]\
                              ["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"]:
                              config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]\
                                  ["trunk_groups"].append("MLAG_VRF_PEER")

              # Set bgp
              if switch_facts["network_services"].get("l3") and switch_facts.get("bgp_as"):
                  config["router_bgp"]["vrfs"] = {}
                  config["router_bgp"]["vlans"] = {}
                  # Set vrfs
                  for vrf, vrf_info in switch_facts["vrfs"].items():
                      if vrf == "default":
                          continue
                      address_family_ipv4_neighbors = []
                      address_family_ipv6_neighbors = []
                      # initialize vrf
                      config["router_bgp"]["vrfs"][vrf] = {
                          "router_id": switch_facts["router_id"],
                          "neighbors": {},
                          "redistribute_routes": {
                              ## "connected": {}
                              # "attached-host": {}
                          },
                          "address_families": {
                              "ipv4": {"neighbors": {}, "networks":{}},
                              "ipv6": {"neighbors": {}, "networks":{}}
                          }
                      }
                      # get and set mlag peer config
                      if switch_facts.get("mlag") \
                      and switch_facts["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                          ibgp_peering_subnet = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet"]
                          ibgp_peering_subnet_mask = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"]
                          mlag_peer_ip = str(get_mlag_ip(
                                  switch_facts,
                                  ibgp_peering_subnet,
                                  ibgp_peering_subnet_mask,
                                  mlag_peer_switch_facts["mlag_role"]
                                  )
                              )
                          # Add mlag_ip to nieghbors and address family
                          config["router_bgp"]["vrfs"][vrf]["neighbors"][mlag_peer_ip] = {
                              "remote_as": switch_facts["bgp_as"],
                              "description": mlag_peer_switch_facts["hostname"]
                          }
                          address_family_ipv4_neighbors.append(mlag_peer_ip)
                      # set external bgp peers
                      if vrf_info.get("bgp_peers"):
                          for peer, peer_info in vrf_info["bgp_peers"].items():
                              if validIPAddress(peer) == True:
                                  address_family_ipv4_neighbors.append(peer)
                              elif validIPAddress(peer) == False:
                                  address_family_ipv6_neighbors.append(peer)
                              else:
                                  continue
                              if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                  peer_info.update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                  if peer_info.get("default_originate"):
                                      if not peer_info["default_originate"].get("route_map"):
                                          peer_info["default_originate"].update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                  if peer_info.get("set_ipv4_next_hop"):
                                      peer_info.pop("set_ipv4_next_hop")
                                  if peer_info.get("set_ipv6_next_hop"):
                                      peer_info.pop("set_ipv6_next_hop")
                              config["router_bgp"]["vrfs"][vrf]["neighbors"][peer] = peer_info
                      # redistribute static routes
                      if vrf_info.get("redistribute_static"):
                          config["router_bgp"]["vrfs"][vrf]["redistribute_routes"]["static"] = {}
                      # activate neighbors for ipv4 address family
                      if len(address_family_ipv4_neighbors) > 0:
                          for neighbor in address_family_ipv4_neighbors:
                              config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"]["neighbors"][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"])
                      # activate neighbors for ipv6 address family
                      if len(address_family_ipv6_neighbors) > 0:
                          for neighbor in address_family_ipv6_neighbors:
                              config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"]["neighbors"][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"])

              return config


          def clean_config(config):
              '''
              Clean up structured config
              '''
              # Clean up bgp config if only vrf present is default vrf
              vrfs_to_delete = []
              for vrf, info in config["router_bgp"].get("vrfs", {}).items():
                  if len(info["neighbors"]) == 0:
                      vrfs_to_delete.append(vrf)
              for vrf in vrfs_to_delete:
                  del(config["router_bgp"]["vrfs"][vrf])

              # Clean up svis
              svis_to_delete = []
              for svi, info in config.get('vlan_interfaces', {}).items():
                  if info == {}:
                      svis_to_delete.append(svi)
              for svi in svis_to_delete:
                  del(config["vlan_interfaces"][svi])

              return config

          def normalize_service_info(switch_facts, vlans, vrfs):
              '''
              vlans is a dictionary of vlan dictionaries
              '''
              switch_facts["vrfs"] = {
                  "default": {
                      "svis": {}
                  }
              }
              for vrf, info in vrfs.items():
                  switch_facts["vrfs"][vrf] = {
                      "svis":{},
                      "static_routes": [],
                      "redistribute_static": None,
                      "bgp_peers": {}
                  }
                  if info.get("ibgp_details") and info["ibgp_details"].get("iBgpSubnet") and switch_facts.get("mlag"):
                      switch_facts["vrfs"][vrf]["enable_mlag_ibgp_peering_vrfs"] = True
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"] = info["ibgp_details"]["iBgpVlanId"]
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet"] = info["ibgp_details"]["iBgpSubnet"]
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"] = info["ibgp_details"]["iBgpSubnetMask"]

                  # normalize static routes
                  for sr in info.get("static_routes"):
                      # if static route is to be configured on switch
                      if device_matches_resolver_query(sr['devices'], switch_facts['serial_number']):
                          static_route = {}
                          static_route["destination_address_prefix"] = sr["routeDetails"].get("destinationAddressPrefix")
                          static_route["gateway"] = sr["routeDetails"].get("gateway")
                          static_route["distance"] = sr["routeDetails"].get("distance")
                          static_route["tag"] = sr["routeDetails"].get("tag")
                          static_route["name"] = sr["description"].replace(" ", "_")
                          static_route["metric"] = sr["routeDetails"].get("metric")
                          static_route["interface"] = sr["routeDetails"].get("interface")
                          static_route["nodes"] = [switch_facts["serial_number"]]
                          switch_facts["vrfs"][vrf]["static_routes"].append(static_route)

                  # normalize redistribute routes
                  switch_facts["vrfs"][vrf]["redistribute_static"] = info.get("redistribute_static_routes")

                  # normalize external bgp peers
                  for bgp_peer in info.get("external_bgp_peers"):
                      # if bgp peer is to be configured on switch
                      if (device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number'])):
                          peer_info = {}
                          peer_info["remote_as"] = bgp_peer["remoteAs"]
                          if bgp_peer.get("description") and bgp_peer["description"].strip() != "":
                              peer_info["description"] = bgp_peer["description"]
                          if bgp_peer.get("password") and bgp_peer["password"].strip() != "":
                              peer_info["password"] = bgp_peer["password"]
                          if bgp_peer.get("sendCommunity") and bgp_peer["sendCommunity"].strip() != "":
                              peer_info["send_community"] = bgp_peer["sendCommunity"]
                          if bgp_peer.get("nextHopSelf") and bgp_peer["nextHopSelf"].strip() != "":
                              peer_info["next_hop_self"] = True if bgp_peer["nextHopSelf"] == 'True' else False
                          if bgp_peer["maxRoutes"].get("maximumRoutes"):
                              peer_info["maximum_routes"] = str(bgp_peer["maxRoutes"]["maximumRoutes"])
                          if bgp_peer["maxRoutes"].get("warningLimit"):
                              peer_info["warning_limit_routes"] = str(bgp_peer["maxRoutes"]["warningLimit"])
                          if bgp_peer["defaultOriginate"].get("always") and bgp_peer["defaultOriginate"]["always"].strip() != "":
                              peer_info["default_originate"] = {
                                  "always": True if bgp_peer["defaultOriginate"].get("always", '') == "True" else False
                              }
                          if bgp_peer.get("updateSource") and bgp_peer["updateSource"].strip() != "":
                              peer_info["update_source"] = bgp_peer["updateSource"]
                          if bgp_peer.get("ebgpMultihop"):
                              peer_info["ebgp_multihop"] = str(bgp_peer["ebgpMultihop"])

                          peer_info["nodes"] = [switch_facts["serial_number"]]

                          if bgp_peer["nextHop"].get("iPv4NextHop") and bgp_peer["nextHop"]["iPv4NextHop"].strip() != "":
                              peer_info["set_ipv4_next_hop"] = bgp_peer["nextHop"]["iPv4NextHop"]
                          if bgp_peer["nextHop"].get("iPv6NextHop") and bgp_peer["nextHop"]["iPv6NextHop"].strip() != "":
                              peer_info["set_ipv6_next_hop"] = bgp_peer["nextHop"]["iPv6NextHop"]
                          if bgp_peer["routeMap"].get("routeMapOut") and bgp_peer["routeMap"]["routeMapOut"].strip() != "":
                              peer_info["route_map_out"] = bgp_peer["routeMap"]["routeMapOut"]
                          if bgp_peer["routeMap"].get("routeMapIn") and bgp_peer["routeMap"]["routeMapIn"].strip() != "":
                              peer_info["route_map_in"] = bgp_peer["routeMap"]["routeMapIn"]
                          if bgp_peer.get("weight"):
                              peer_info["weight"] = str(bgp_peer["weight"])
                          if bgp_peer.get("localAs"):
                              peer_info["local_as"] = str(bgp_peer["localAs"])
                          switch_facts["vrfs"][vrf]["bgp_peers"][bgp_peer["neighborIpAddress"]] = peer_info

              switch_facts["l2vlans"] = {}
              for vlan, vlan_info in vlans.items():
                  vlan_dict = {
                      "dhcp_server_details": vlan_info["dhcp_server_details"],
                      "eos_cli": vlan_info["eos_cli"]
                  }
                  vlan_dict["name"] = vlan_info["name"] if vlan_info.get("name") and vlan_info.get("name").strip() != "" else None

                  if vlan_info["svi_ip_address"] is not None and vlan_info["svi_ip_address"].strip() not in ["", "None"]:
                      # configure ip virtual-router address and real ip address
                      svi_vip = vlan_info["svi_ip_address"]
                      svi_network = ipaddress.ip_interface(svi_vip).network
                      first_host = list(svi_network.hosts())[0]
                      last_host = list(svi_network.hosts())[-1]
                      if str(first_host) == svi_vip.split("/")[0]:
                          position = "start"
                      elif str(last_host) == svi_vip.split("/")[0]:
                          position = "end"
                      else:
                          assert False, "Error: {}'s virtual IP address must be either the " \
                          "first or last host address in the subnet if 'ip virtual-router address'"\
                          " config type is set".format(vlan)
                      if switch_facts.get("mlag_role") and switch_facts["mlag_role"] == "secondary":
                          # take higher host address closest to vip
                          if position == "start":
                              svi_ip = list(svi_network.hosts())[2]
                          else:
                              svi_ip = list(svi_network.hosts())[-2]
                      else:
                          # take lower host address closest to vip
                          if position == "start":
                              svi_ip = list(svi_network.hosts())[1]
                          else:
                              svi_ip = list(svi_network.hosts())[-3]
                      vlan_dict["ip_virtual_router_address"] = svi_vip
                      vlan_dict["ip_address"] = "{}/{}".format(svi_ip, svi_network.prefixlen)
                      if vlan_info.get("vrf") and vlan_info["vrf"].strip() not in ["", "None"]:
                          vrf = vlan_info["vrf"].strip()
                          vlan_dict["vrf"] = vlan_info["vrf"].strip()
                      else:
                          vrf = "default"
                          vlan_dict["vrf"] = "default"
                      switch_facts["vrfs"][vrf]["svis"][vlan] = vlan_dict
                  else:
                      switch_facts["l2vlans"][vlan] = vlan_dict
              return switch_facts

          def get_services_applied_to_switch(switch_facts, campus_resolver):
              '''
              Returns switch facts with 'applied_vlans' and 'applied_vrfs' keys set and values for those keys being a list of vlan IDs and vrfs, respectively
              '''
              campus_resolved = campus_resolver.resolve(device=switch_facts["serial_number"])
              site_resolved = campus_resolved["campusDetails"]["site"].resolve(device=switch_facts["serial_number"])
              vlans_input = site_resolved["siteFacts"]["vlans"]
              vrfs_input = site_resolved["siteFacts"]["vrfs"]

              # format vrfs
              vrfs = {}
              switch_vrfs = {}
              for vrf in vrfs_input:
                  vrfs[vrf["vrfname"]] = {
                      "ibgp_details": vrf["ibgpDetails"],
                      "static_routes": vrf["staticRoutes"],
                      "redistribute_static_routes": vrf["redistributeStaticRoutes"],
                      "external_bgp_peers": vrf["externalBgpPeers"],
                  }
              # format vlans and determine if they should be applied to switch
              switch_vlans = {}
              for vlan in vlans_input:
                  # check if vlan is applied
                  if site_resolved["siteFacts"]['campusPodDetails']['uplinkType'] == "port-channel":
                      if switch_facts['type'] == "Spline":
                          vlan_applied = True
                      else:
                          if vlan["campusPoD"].resolve(device=switch_facts['serial_number']) and \
                                  vlan["campusPoD"].resolve(device=switch_facts['serial_number'])["poDDetails"]:
                              vlan_applied = vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"]["apply"]
                          else:
                              vlan_applied = False
                  else:
                      if vlan["campusPoD"].resolve(device=switch_facts['serial_number']) and \
                              vlan["campusPoD"].resolve(device=switch_facts['serial_number'])["poDDetails"]:
                          vlan_applied = vlan["campusPoD"].resolve(device=switch_facts['serial_number'])["poDDetails"]["apply"]
                      else:
                          vlan_applied = False

                  # if vlan is applied, format and add details to switch_vlans
                  if vlan_applied == True:
                      vlan_info = {
                          "name": vlan["name"],
                          "vrf": vlan["sviDetails"]["vrf"],
                          "dhcp_server_details": vlan["dhcpHelpers"],
                          ## "arp": vlan["arp"],
                          ## "mtu": vlan["mtu"],
                          "eos_cli": vlan["eosCli"]
                      }
                      # Set svi ip address
                      vlan_info["svi_ip_address"] = None
                      if site_resolved["siteFacts"]["campusPodDetails"]["uplinkType"] == "p2p":
                          if vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"]:
                              vlan_info["svi_ip_address"] = vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"].get("sviIpAddress")
                      else:
                          vlan_info["svi_ip_address"] = vlan["sviDetails"]["ipAddress"]

                      # add vlan to switch_vlans
                      switch_vlans[vlan["vlanId"]] = vlan_info

                      # add vrf to switch_vrfs if necessary
                      if vlan_info.get("vrf") and vlan_info["vrf"].strip() not in ["", "None"]:
                          switch_vrfs[vlan_info["vrf"]] = vrfs[vlan_info["vrf"]]

              # Get vrfs that should be configured on the switch
              for vrf, info in vrfs.items():
                  vrf_set = None

                  # check if apply column resolves for any static routes
                  for sr in info.get("static_routes"):
                      if (device_matches_resolver_query(sr['devices'], switch_facts['serial_number'])):
                          switch_vrfs[vrf] = info
                          break
                  if switch_vrfs.get(vrf):
                      continue
                  for bgp_peer in info.get("external_bgp_peers"):
                      if (device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number'])):
                          switch_vrfs[vrf] = info
                          break
                  if switch_vrfs.get(vrf):
                      continue

              # switch_facts["vrfs"] = vrfs
              # switch_facts["vlan"] = switch_vlans

              switch_facts = normalize_service_info(switch_facts, switch_vlans, switch_vrfs)


              return switch_facts



          # Get studio info from ctx
          my_device = ctx.getDevice()
          workspace_id = ctx.studio.workspaceId

          # Initialize variables
          my_switch_facts = {}
          my_config = {}

          # Pre-populate dictionaries used for getting switch facts
          role_dict = populate_multi_value_dict(workspace_id, 'Role')

          campus_dict = populate_single_value_dict(workspace_id, 'Campus')
          site_dict = populate_single_value_dict(workspace_id, 'Site')
          campus_pod_dict = populate_single_value_dict(workspace_id, 'Campus-Pod')
          node_id_dict = populate_single_value_dict(workspace_id, 'NodeId')

          # Get basic switch facts for my_switch
          my_switch_facts = get_switch_basics(my_device.id, campus)


          if my_switch_facts is None:
              return


          # Get basic switch facts for all switches in the same campus as my_switch
          switches_in_my_campus = get_switches_in_my_campus_basics(my_switch_facts)

          # Set asn from studio input (needs to be set for leaf domain level first so reserved asns can be taken out of pool)
          # for switch_facts in switches_in_my_campus.values():
          #     switch_facts = set_bgp_as_from_studio_input(switch_facts, campus)

          # Get my switch's neighbors
          uplink_interfaces, downlink_interfaces, mlag_peer_link_interfaces = get_interfaces_info(my_switch_facts)
          my_switch_facts['uplink_interfaces'] = uplink_interfaces
          my_switch_facts['downlink_interfaces'] = downlink_interfaces
          my_switch_facts['mlag_peer_link_interfaces'] = mlag_peer_link_interfaces


          my_switch_facts['neighbors'] = [iface['neighborId'] for iface in my_switch_facts['uplink_interfaces'].values()] \
                                          + [iface['neighborId'] for iface in my_switch_facts['downlink_interfaces'].values()] \
                                          + [iface['neighborId'] for iface in my_switch_facts['mlag_peer_link_interfaces'].values()]

          # Update my_switch key for switches_in_my_dc
          switches_in_my_campus[my_switch_facts['serial_number']] = my_switch_facts

          # Set interface info for spines and neighbors from studio topology tags
          for switch_facts in switches_in_my_campus.values():
              if switch_facts['serial_number'] in my_switch_facts['neighbors']:
                  uplink_interfaces, downlink_interfaces, mlag_peer_link_interfaces = get_interfaces_info(switch_facts)
                  switch_facts['uplink_interfaces'] = uplink_interfaces
                  switch_facts['downlink_interfaces'] = downlink_interfaces
                  switch_facts['mlag_peer_link_interfaces'] = mlag_peer_link_interfaces

          # Set all switch facts
          for switch_facts in switches_in_my_campus.values():
              if switch_facts['serial_number'] in my_switch_facts['neighbors'] + [my_device.id]:
                  switch_facts = set_switch_facts(switch_facts, campus)

          # Set applied services - Needs to be set before topology facts.
          for switch_facts in switches_in_my_campus.values():
              if switch_facts['serial_number'] in my_switch_facts['neighbors'] + [my_device.id]:
                  switch_facts = get_services_applied_to_switch(switch_facts,campus)

          # Get topology facts ( in order to set transit p2p and port-channel links )
          for switch_facts in switches_in_my_campus.values():
              if switch_facts['serial_number'] in my_switch_facts['neighbors'] + [my_device.id]:
                  switch_facts = set_topology_facts(switch_facts)


          # Update my_switch_facts
          my_switch_facts = switches_in_my_campus[my_device.id]

          # Set structured config
          my_config = {
              "spanning_tree": {},
              "vlans": {},
              "vlan_interfaces": {},
              "port_channel_interfaces": {},
              "ethernet_interfaces": {},
              "loopback_interfaces": {},
              "prefix_lists": {},
              "route_maps": {},
              ## "router_bfd": {},
              "router_bgp": {
                  "peer_groups": {},
                  "address_family_ipv4": {
                      "peer_groups": {}
                  },
                  "address_family_evpn": {
                      "peer_groups": {}
                  },
                  "neighbor_interfaces": {},
                  "neighbors": {},
                  "redistribute_routes": {
                      "connected": {}
                  }
              },
              "router_ospf": {
                  "process_ids": {}
              },
              "vrfs": {},
              "virtual_source_nat_vrfs": {},
              "static_routes": []
          }

          update_tags(my_switch_facts)
          my_config = set_base_config(my_config, my_switch_facts)
          my_config = set_mlag_config(my_config, my_switch_facts)
          my_config = set_underlay_config(my_config, my_switch_facts)
          my_config = set_overlay_config(my_config, my_switch_facts)
          my_config = set_vxlan_config(my_config, my_switch_facts)
          my_config = set_network_services_config(my_config, my_switch_facts)
          my_config = clean_config(my_config)

          ctx.info("Switch Facts")
          ctx.info(json.dumps(my_switch_facts))

          ctx.info("Structured Config:")
          ctx.info(json.dumps(my_config))

          config = my_config
          %>
          ## ${json.dumps(my_switch_facts, indent=2)}
          ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          ## ${json.dumps(config, indent=2)}
          ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - routing model
          % if config.get("service_routing_protocols_model") is not None and config.get("service_routing_protocols_model") == "multi-agent":
          service routing protocols model multi-agent
          !
          % endif
          ## eos - spanning-tree
          % if config.get("spanning_tree") is not None:
          %     if config["spanning_tree"].get("mode") is not None:
          spanning-tree mode ${ config["spanning_tree"].get("mode") }
          %     endif
          %     if config["spanning_tree"].get("no_spanning_tree_vlan") is not None:
          no spanning-tree vlan-id ${ config["spanning_tree"].get("no_spanning_tree_vlan") }
          %     endif
          %     if config["spanning_tree"].get("mode", "") == "mstp":
          %         for mst_instance_id in natural_sort(config["spanning_tree"].get("mst_instances", {}).keys()):
          %             if config["spanning_tree"]["mst_instances"][mst_instance_id].get("priority"):
          spanning-tree mst ${ mst_instance_id } priority ${ config["spanning_tree"]["mst_instances"][mst_instance_id]["priority"] }
          %             endif
          %         endfor
          %     elif  config["spanning_tree"].get("mode", "") == "rapid-pvst":
          %         for vlan_id in natural_sort(config["spanning_tree"].get("rapid_pvst_instances", {}).keys()):
          %             if config["spanning_tree"]["rapid_pvst_instances"][vlan_id].get("priority"):
          spanning-tree vlan-id ${ vlan_id } priority ${ config["spanning_tree"]["rapid_pvst_instances"][vlan_id]["priority"] }
          %             endif
          %         endfor
          %     else:
          %         if config["spanning_tree"].get("rstp_priority"):
          spanning-tree priority ${ config["spanning_tree"]["rstp_priority"] }
          %         endif
          %     endif
          !
          % endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          %   endfor
          %endif
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("vlans") and config["port_channel_interfaces"][port_channel_interface]["mode"] == "trunk":
             switchport trunk allowed vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mlag"):
             mlag ${ config["port_channel_interfaces"][port_channel_interface]["mlag"] }
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface]["description"] is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("boot_vlan"):
             lldp tlv transmit ztp vlan ${config["ethernet_interfaces"][ethernet_interface]["boot_vlan"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
             ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
             ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          %     if config["loopback_interfaces"][loopback_interface].get("ospf_area"):
             ip ospf area ${ config["loopback_interfaces"][loopback_interface]["ospf_area"] }
          %     endif
          !
          %   endfor
          %endif
          ## eos - VLAN Interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface].get("vrf") != 'default':
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
             ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") is not None:
             ip virtual-router address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
             ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_area"):
             ip ospf area ${ config.get("vlan_interfaces")[vlan_interface]["ospf_area"] }
          %      endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["source_interface"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - tcam profile
          % if config.get("tcam_profile") is not None:
          hardware tcam
          %     if config["tcam_profile"].get("system") is not None:
             system profile ${ config["tcam_profile"]["system"] }
          %     endif
          !
          % endif
          ## eos - ip virtual router mac
          % if config.get("ip_virtual_router_mac_address") is not None:
          ip virtual-router mac-address ${ config["ip_virtual_router_mac_address"] }
          !
          % endif
          ## eos - IP Routing
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          ## eos - VRFs
          % if config.get('vrfs'):
          %   for vrf in config["vrfs"]:
          %       if config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % for static_route in config.get("static_routes", []):
          <%    static_route_cli = "ip route" %>
          %     if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%        static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %     endif
          %     if static_route.get("destination_address_prefix"):
          <%        static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %     endif
          %     if static_route.get("interface"):
          <%        static_route_cli = static_route_cli + " " + static_route["interface"] %>
          %     endif
          %     if static_route.get("gateway"):
          <%        static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %     endif
          %     if static_route.get("distance"):
          <%        static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %     endif
          %     if static_route.get("tag"):
          <%        static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %     endif
          %     if static_route.get("name"):
          <%        static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %     endif
          %     if static_route.get("metric"):
          <%        static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %     endif
          ${ static_route_cli }
          !
          %    endfor %}
          ## eos - Router Multicast
          % if config.get("router_multicast"):
          router multicast
          %     if config["router_multicast"].get("ipv4"):
             ipv4
          %         if config["router_multicast"]["ipv4"].get("routing"):
                routing
          %         endif
          %         if config["router_multicast"]["ipv4"].get("multipath"):
                multipath ${ config["router_multicast"]["ipv4"]["multipath"] }
          %         endif
          %         if config["router_multicast"]["ipv4"].get("software_forwarding"):
                software-forwarding ${ config["router_multicast"]["ipv4"]["software_forwarding"] }
          %         endif
          %     endif
          !
          % endif
          ## eos - prefix-lists
          % if config.get("prefix_lists") is not None:
          %    for prefix_list in config["prefix_lists"].keys():
          ip prefix-list ${ prefix_list }
          %       for sequence in config["prefix_lists"][prefix_list]["sequence_numbers"].keys():
          %         if config["prefix_lists"][prefix_list]["sequence_numbers"][sequence].get("action") is not None:
             seq ${ sequence } ${ config["prefix_lists"][prefix_list]["sequence_numbers"][sequence]["action"] }
          %         endif
          %       endfor
          !
          %    endfor
          % endif
          ## eos - mlag configuration
          % if config.get("mlag_configuration") is not None and config["mlag_configuration"].get("enabled") == True:
          mlag configuration
          %     if config["mlag_configuration"].get("domain_id") is not None:
             domain-id ${ config["mlag_configuration"]["domain_id"] }
          %     endif
          %     if config["mlag_configuration"].get("local_interface") is not None:
             local-interface ${ config["mlag_configuration"]["local_interface"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address") is not None:
             peer-address ${ config["mlag_configuration"]["peer_address"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address_heartbeat") is not None:
          %       if config["mlag_configuration"]["peer_address_heartbeat"].get("peer_ip") is not None:
          %           if config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") is not None and config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") != 'default':
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] } vrf ${ config["mlag_configuration"]["peer_address_heartbeat"]["vrf"] }
          ## using the default VRF #}
          %           else:
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] }
          %           endif
          %       endif
          %     endif
          %     if config["mlag_configuration"].get("peer_link") is not None:
             peer-link ${ config["mlag_configuration"]["peer_link"] }
          %     endif
          %     if config["mlag_configuration"].get("dual_primary_detection_delay") is not None:
             dual-primary detection delay ${ config["mlag_configuration"]["dual_primary_detection_delay"] } action errdisable all-interfaces
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_mlag") is not None:
             reload-delay mlag ${ config["mlag_configuration"]["reload_delay_mlag"] }
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_non_mlag") is not None:
             reload-delay non-mlag ${ config["mlag_configuration"]["reload_delay_non_mlag"] }
          %     endif
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in config["route_maps"].keys():
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## eos - peer-filters
          % if config.get("peer_filters") is not None:
          %   for peer_filter in config["peer_filters"].keys():
          peer-filter ${ peer_filter }
          %     for sequence in config["peer_filters"][peer_filter]["sequence_numbers"].keys():
          %         if config["peer_filters"][peer_filter]["sequence_numbers"][sequence].get("match") is not None:
             ${ sequence } match ${ config["peer_filters"][peer_filter]["sequence_numbers"][sequence]["match"] }
          %         endif
          %     endfor
          !
          %   endfor
          % endif
          ## eos - Router bfd
          % if config.get("router_bfd") is not None and config.get("router_bfd") != {}:
          router bfd
          %   if config["router_bfd"].get("multihop") is not None:
          %     if config["router_bfd"]["multihop"].get("interval") is not None and config["router_bfd"]["multihop"].get("min_rx") is not None and config["router_bfd"]["multihop"].get("multiplier") is not None:
             multihop interval ${ config["router_bfd"]["multihop"]["interval"] } min-rx ${ config["router_bfd"]["multihop"]["min_rx"] } multiplier ${ config["router_bfd"]["multihop"]["multiplier"] }
          %     endif
          %   endif
          !
          % endif
          ## eos - Router BGP
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("maximum_paths"):
          <% max_paths_cli = "maximum-paths {} ".format(config["router_bgp"]["maximum_paths"]) %>
          %        if config["router_bgp"].get("ecmp"):
          <% max_paths_cli += "ecmp {}".format(config["router_bgp"]["ecmp"]) %>
                  % endif
             ${max_paths_cli}
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in natural_sort(config["router_bgp"]["neighbors"].keys()):
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
             neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
             neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].rd is not None:
                rd ${ config["router_bgp"]["vlans"][vlan].rd }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
                neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
             !
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          !
          %     endif
          % endif
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## router-ospf
          %if config.get("router_ospf") and config["router_ospf"].get("process_ids"):
          %for process_id in config["router_ospf"]["process_ids"].keys():
          %     if config["router_ospf"]["process_ids"][process_id].get("vrf"):
          router ospf ${ process_id } vrf ${ config["router_ospf"]["process_ids"][process_id]["vrf"] }
          %     else:
          router ospf ${ process_id }
          %     endif
          %     if config["router_ospf"]["process_ids"].get("log_adjacency_changes_detail"):
             log-adjacency-changes detail
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("router_id"):
             router-id ${ config["router_ospf"]["process_ids"][process_id]["router_id"] }
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("passive_interface_default"):
             passive-interface default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("no_passive_interfaces"):
          %         for interface in config["router_ospf"]["process_ids"][process_id]["no_passive_interfaces"]:
             no passive-interface ${ interface }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("network_prefixes"):
          %         for network_prefix in natural_sort(config["router_ospf"]["process_ids"][process_id]["network_prefixes"].keys()):
             network ${ network_prefix } area ${ config["router_ospf"]["process_ids"][process_id]["network_prefixes"][network_prefix]["area"] }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("bfd_enable"):
             bfd default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("ospf_defaults"):
          %         for ospf_default in config["router_ospf"]["process_ids"][process_id]["ospf_defaults"]:
             ${ospf_default}
          %         endfor
          %     endif
          !
          %endfor
          %endif
      input_schema:
        fields:
          values:
            vxlanOverlay:
              id: vxlanOverlay
              name: vxlanOverlay
              label: VXLAN Overlay
              description: Enable or disable a VXLAN overlay for this site.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vtepAddressRange:
              id: vtepAddressRange
              name: vtepAddressRange
              label: VTEP IPv4 Pool
              description: Define an IPv4 Pool in CIDR notation from which to allocate VXLAN tunnel source IP addresses. These IP addresses will be assigned to all VTEP switch's Loopback1 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 172.16.1.0/24
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            overlayDetails:
              id: overlayDetails
              name: overlayDetails
              label: Overlay Details
              description: Configure the VXLAN overlay settings for this Pod.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vxlanOverlay
                    - vtepAddressRange
            mlagPeerIPv4Pool:
              id: mlagPeerIPv4Pool
              name: mlagPeerIPv4Pool
              label: MLAG Peer IPv4 Pool
              description: Define the subnet from which to allocate IP addresses for the MLAG source interfaces.  By setting a subnet with a subnet mask of 30 or 31, you will re-use the same IP addresses for MLAG source interfaces across all leaf MLAG pairs in your network. To use unique IP addresses for every MLAG source interface, enter a subnet with a subnet mask less than 30
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 169.254.0.0/24
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mlagPeerLinkVlan:
              id: mlagPeerLinkVlan
              name: mlagPeerLinkVlan
              label: MLAG Peer Link VLAN
              description: Define the VLAN ID to use for MLAG peer communication
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            mlagPortChannelId:
              id: mlagPortChannelId
              name: mlagPortChannelId
              label: MLAG Port-Channel ID
              description: Define the Port-Channel ID to use for MLAG peer communication
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '2000'
                range: null
                static_options: null
                dynamic_options: null
            mlagSubnetMask:
              id: mlagSubnetMask
              name: mlagSubnetMask
              label: MLAG Subnet Mask
              description: Set the subnet mask for the MLAG interface connections in the fabric
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            virtualRouterMacAddress:
              id: virtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Assign a virtual MAC address for redundant host and switch connections
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            lacpMode:
              id: lacpMode
              name: lacpMode
              label: LACP Mode
              description: Define the LACP mode used for member interfaces of the MLAG peer link port channel
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: active
                static_options:
                  values:
                    - active
                    - passive
                    - on (static)
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mlagPeerL3Vlan:
              id: mlagPeerL3Vlan
              name: mlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: Underlay L3 peering SVI interface ID. If left blank, the MLAG Peer Link VLAN will be used for the L3 peering.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mlagPeerL3IPv4Pool:
              id: mlagPeerL3IPv4Pool
              name: mlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IP address pool used for MLAG underlay L3 peering. If left blank, the MLAG Peer Link Subnet will be used for the L3 peering.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mlagPeerL3SubnetMask:
              id: mlagPeerL3SubnetMask
              name: mlagPeerL3SubnetMask
              label: MLAG Peer L3 Subnet Mask
              description: Set the subnet mask for the MLAG L3 peering IP addresses.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            mlagConfiguration:
              id: mlagConfiguration
              name: mlagConfiguration
              label: MLAG
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - mlagPeerIPv4Pool
                    - mlagPeerLinkVlan
                    - mlagPortChannelId
                    - mlagSubnetMask
                    - virtualRouterMacAddress
                    - lacpMode
                    - mlagPeerL3Vlan
                    - mlagPeerL3IPv4Pool
                    - mlagPeerL3SubnetMask
            uplinkType:
              id: uplinkType
              name: uplinkType
              label: Uplink Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - p2p
                    - port-channel
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpAsRange:
              id: campusPodBgpAsRange
              name: bgpAsRange
              label: BGP AS Range
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodRouterIdPool:
              id: campusPodRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaultsConfigStatement:
              id: campusPodBgpDefaultsConfigStatement
              name: campusPodBgpDefaultsConfigStatement
              label: Config Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaults:
              id: campusPodBgpDefaults
              name: campusPodDefaults
              label: BGP Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodBgpDefaultsConfigStatement
                key: ''
            campusPodUplinkIpv4Pool:
              id: campusPodUplinkIpv4Pool
              name: uplinkIpv4Pool
              label: Uplink Ipv4 Pool
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodDetails:
              id: campusPodDetails
              name: campusPodDetails
              label: Campus Pod Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - uplinkType
                    - campusPodBgpAsRange
                    - campusPodRouterIdPool
                    - campusPodBgpDefaults
                    - campusPodUplinkIpv4Pool
            splineBgpAs:
              id: splineBgpAs
              name: splineBgpAs
              label: BGP AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            splineRouterIdPool:
              id: splineRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each spline switch's Loopback0 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaultsConfigStatement:
              id: splineBgpDefaultsConfigStatement
              name: splineBgpDefaultsConfigStatement
              label: Config Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaults:
              id: splineBgpDefaults
              name: splineDefaults
              label: BGP Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineBgpDefaultsConfigStatement
                key: ''
            splineEvpnRoleDefault:
              id: splineEvpnRoleDefault
              name: splineEvpnRoleDefault
              label: EVPN Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Server
                    - Client
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagSupportDefault:
              id: splineMlagSupportDefault
              name: splineMlagSupportDefault
              label: MLAG Support
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineVtepDefault:
              id: splineVtepDefault
              name: splineVtepDefault
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineConnectedEndpointsDefault:
              id: splineConnectedEndpointsDefault
              name: splineConnectedEndpointsDefault
              label: Connected Endpoints
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL2NetworkServicesDefault:
              id: splineL2NetworkServicesDefault
              name: splineL2NetworkServicesDefault
              label: L2 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL3NetworkServicesDefault:
              id: splineL3NetworkServicesDefault
              name: splineL3NetworkServicesDefault
              label: L3 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultSplineProperties:
              id: defaultSplineProperties
              name: defaultSplineProperties
              label: Default Spline Properties
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineEvpnRoleDefault
                    - splineMlagSupportDefault
                    - splineVtepDefault
                    - splineConnectedEndpointsDefault
                    - splineL2NetworkServicesDefault
                    - splineL3NetworkServicesDefault
            splineDefaults:
              id: splineDefaults
              name: splineDefaults
              label: Spline Defaults
              description: Set parameters which will be used to generate configuration across all spline switches in this site.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineBgpAs
                    - splineRouterIdPool
                    - splineBgpDefaults
                    - defaultSplineProperties
            ospfProcessId:
              id: ospfProcessId
              name: processId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '100'
                range: null
                static_options: null
                dynamic_options: null
            ospfArea:
              id: ospfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            ospfMaxLsa:
              id: ospfMaxLsa
              name: maxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '12000'
                range: null
                static_options: null
                dynamic_options: null
            ospfBfdKnob:
              id: ospfBfdKnob
              name: bfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            ospfConfiguration:
              id: ospfConfiguration
              name: ospfConfiguration
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ospfProcessId
                    - ospfArea
                    - ospfMaxLsa
                    - ospfBfdKnob
            siteUnderlayRoutingProtocol:
              id: siteUnderlayRoutingProtocol
              name: siteUnderlayRoutingProtocol
              label: Underlay Routing Protocol
              description: Set the routing protocol used for underlay connectivity for this site.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: BGP
                static_options:
                  values:
                    - BGP
                    - OSPF
                format: null
                length: null
                pattern: null
                dynamic_options: null
            podId:
              id: podId
              name: podId
              label: Pod ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            campusPodFacts:
              id: campusPodFacts
              name: campusPodFacts
              label: Campus Pod Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - podId
            campusPods:
              id: campusPods
              name: campusPods
              label: Campus Pods
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusPodFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            vrfName:
              id: vrfName
              name: vrfname
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3PeeringVlanId:
              id: vrfMlagL3PeeringVlanId
              name: peeringVlanId
              label: Peering VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfMlagL3PeeringSubnet:
              id: vrfMlagL3PeeringSubnet
              name: peeringSubnet
              label: Peering Subnet
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3PeeringSubnetMask:
              id: vrfMlagL3PeeringSubnetMask
              name: peeringSubnetMask
              label: Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            vrfMlagL3Peering:
              id: vrfMlagL3Peering
              name: ibgpDetails
              label: MLAG L3 Peering
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfMlagL3PeeringVlanId
                    - vrfMlagL3PeeringSubnet
                    - vrfMlagL3PeeringSubnetMask
            vrfStaticRoutesDescription:
              id: vrfStaticRoutesDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesApply:
              id: vrfStaticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfStaticRoutesHostname:
              id: vrfStaticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfStaticRoutesDevicesGroup:
              id: vrfStaticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesHostname
            vrfStaticRoutesDevicesResolver:
              id: vrfStaticRoutesDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfStaticRoutesDestinationAddressPrefix:
              id: vrfStaticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesGateway:
              id: vrfStaticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesInterface:
              id: vrfStaticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesDistance:
              id: vrfStaticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesTag:
              id: vrfStaticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesMetric:
              id: vrfStaticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesDetails:
              id: vrfStaticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDestinationAddressPrefix
                    - vrfStaticRoutesGateway
                    - vrfStaticRoutesInterface
                    - vrfStaticRoutesDistance
                    - vrfStaticRoutesTag
                    - vrfStaticRoutesMetric
            vrfStaticRoutesGroup:
              id: vrfStaticRoutesGroup
              name: staticRoutesGroup
              label: Static Routes Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDescription
                    - vrfStaticRoutesDevicesResolver
                    - vrfStaticRoutesDetails
            vrfStaticRoutes:
              id: vrfStaticRoutes
              name: staticRoutes
              label: Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfStaticRoutesGroup
                key: vrfStaticRoutesDescription
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersNeighborIpAddress:
              id: vrfExternalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersApply:
              id: vrfExternalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersHostname:
              id: vrfExternalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfExternalBgpPeersDevicesGroup:
              id: vrfExternalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersHostname
            vrfExternalBgpPeersDevicesResolver:
              id: vrfExternalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfExternalBgpPeersRemoteAs:
              id: vrfExternalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersDescription:
              id: vrfExternalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersPassword:
              id: vrfExternalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersSendCommunity:
              id: vrfExternalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopSelf:
              id: vrfExternalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersMaximumRoutes:
              id: vrfExternalBgpPeersMaximumRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesWarningLimit:
              id: vrfExternalBgpPeersMaxRoutesWarningLimit
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesGroup:
              id: vrfExternalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersMaximumRoutes
                    - vrfExternalBgpPeersMaxRoutesWarningLimit
            vrfExternalBgpPeersUpdateSource:
              id: vrfExternalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersEbgpMultihop:
              id: vrfExternalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersWeight:
              id: vrfExternalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersIpv4NextHop:
              id: vrfExternalBgpPeersIpv4NextHop
              name: iPv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersIpv6NextHop:
              id: vrfExternalBgpPeersIpv6NextHop
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopGroup:
              id: vrfExternalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersIpv4NextHop
                    - vrfExternalBgpPeersIpv6NextHop
            vrfExternalBgpPeersRouteMapIn:
              id: vrfExternalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapOut:
              id: vrfExternalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapGroup:
              id: vrfExternalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersRouteMapIn
                    - vrfExternalBgpPeersRouteMapOut
            vrfExternalBgpPeersDefaultOriginateAlwaysToggle:
              id: vrfExternalBgpPeersDefaultOriginateAlwaysToggle
              name: always
              label: Always
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersDefaultOriginateGroup:
              id: vrfExternalBgpPeersDefaultOriginateGroup
              name: defaultOriginate
              label: Default Originate
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersDefaultOriginateAlwaysToggle
            vrfExternalBgpPeersLocalAs:
              id: vrfExternalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersGroup:
              id: vrfExternalBgpPeersGroup
              name: value
              label: External BGP Peers Group
              description: Group of members for External BGP Peers
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersNeighborIpAddress
                    - vrfExternalBgpPeersDevicesResolver
                    - vrfExternalBgpPeersRemoteAs
                    - vrfExternalBgpPeersDescription
                    - vrfExternalBgpPeersPassword
                    - vrfExternalBgpPeersSendCommunity
                    - vrfExternalBgpPeersNextHopSelf
                    - vrfExternalBgpPeersMaxRoutesGroup
                    - vrfExternalBgpPeersUpdateSource
                    - vrfExternalBgpPeersEbgpMultihop
                    - vrfExternalBgpPeersWeight
                    - vrfExternalBgpPeersNextHopGroup
                    - vrfExternalBgpPeersRouteMapGroup
                    - vrfExternalBgpPeersDefaultOriginateGroup
                    - vrfExternalBgpPeersLocalAs
            vrfExternalBgpPeers:
              id: vrfExternalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfExternalBgpPeersGroup
                key: vrfExternalBgpPeersDescription
            vrfDetails:
              id: vrfDetails
              name: value
              label: VRF Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - vrfMlagL3Peering
                    - vrfStaticRoutes
                    - vrfRedistributeStaticRoutesToggle
                    - vrfExternalBgpPeers
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: VRFs configured only on all gateway switches at this site
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfDetails
                key: vrfName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanL2CampusSviIpAddress:
              id: vlanL2CampusSviIpAddress
              name: ipAddress
              label: IP Address
              description: This will be IP Address configured on the SVI on the Spline switches.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviVrf:
              id: vlanCampusSviVrf
              name: vrf
              label: VRF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            vlanCampusSviGroup:
              id: vlanCampusSviGroup
              name: sviDetails
              label: SVI Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanL2CampusSviIpAddress
                    - vlanCampusSviVrf
            vlanDhcpHelpersServer:
              id: vlanDhcpHelpersServer
              name: dhcpServer
              label: DHCP Server
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersSourceInterface:
              id: vlanDhcpHelpersSourceInterface
              name: dhcpSourceInterface
              label: DHCP Source Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersGroup:
              id: vlanDhcpHelpersGroup
              name: dhcpHelperDetails
              label: DHCP Helper Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpHelpersServer
                    - vlanDhcpHelpersSourceInterface
            vlanDhcpHelpers:
              id: vlanDhcpHelpers
              name: dhcpHelpers
              label: DHCP Helpers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpHelpersGroup
                key: ''
            vlanName:
              id: vlanName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodSviIpAddress:
              id: vlansCampusPodSviIpAddress
              name: sviIpAddress
              label: SVI IP Address
              description: This will be IP Address configured on the SVI on the Aggregation Campus Pod switches.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodApply:
              id: vlansCampusPodApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vlansCampusPodGroup:
              id: vlansCampusPodGroup
              name: poDDetails
              label: PoD Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlansCampusPodSviIpAddress
                    - vlansCampusPodApply
            vlansCampusPodResolver:
              id: vlansCampusPodResolver
              name: campusPoD
              label: Campus PoDs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlansCampusPodGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            vlanSviEosCliStatement:
              id: vlanSviEosCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCli:
              id: vlanSviEosCli
              name: eosCli
              label: EOS CLI
              description: Raw CLI to be applied on SVI
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviEosCliStatement
                key: ''
            # vlanSpanningTreePriority:
            #   id: vlanSpanningTreePriority
            #   name: vlanSpanningTreePriority
            #   label: VLAN Spanning Tree Priority
            #   description: Defaults to the default SPT priority if no value is entered. If MST is the selected STP mode, this will set the STP priority for the instance this VLAN is a member of.
            #   required: false
            #   type: INPUT_FIELD_TYPE_INTEGER
            #   integer_props:
            #     default_value: null
            #     range: null
            #     static_options: null
            #     dynamic_options: null
            # vlanMstInstance:
            #   id: vlanMstInstance
            #   name: vlanMstInstance
            #   label: MST Instance
            #   description: MST instance this VLAN belongs to. If left blank, VLAN will be a member of the default instance.
            #   required: false
            #   type: INPUT_FIELD_TYPE_INTEGER
            #   integer_props:
            #     default_value: null
            #     range: null
            #     static_options: null
            #     dynamic_options: null
            # vlanSpanningTreeDetails:
            #   id: vlanSpanningTreeDetails
            #   name: vlanSpanningTreeDetails
            #   label: VLAN Spanning Tree Details
            #   description: ''
            #   required: false
            #   type: INPUT_FIELD_TYPE_GROUP
            #   group_props:
            #     members:
            #       values:
            #         - vlanSpanningTreePriority
            #         - vlanMstInstance
            vlansDetails:
              id: vlansDetails
              name: vlanDetails
              label: VLAN Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanCampusSviGroup
                    - vlanDhcpHelpers
                    - vlanName
                    - vlansCampusPodResolver
                    - vlanSviEosCli
                    # - vlanSpanningTreeDetails
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: VLANs configured only on all switches at this site.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlansDetails
                key: vlanId
            allowAllVlansOnTrunkToggle:
              id: allowAllVlansOnTrunkToggle
              name: allowAllVLANs
              label: Allow All VLANs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            spanningTreeMode:
              id: spanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - MSTP
                    - Rapid-PVST
                    - RSTP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultSpanningTreePriority:
              id: defaultSpanningTreePriority
              name: defaultSpanningTreePriority
              label: Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            defaultSpanningTreeDetails:
              id: defaultSpanningTreeDetails
              name: defaultSpanningTreeDetails
              label: Spanning Tree
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - spanningTreeMode
                    - defaultSpanningTreePriority
            siteFacts:
              id: siteFacts
              name: siteFacts
              label: Site Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - overlayDetails
                    - mlagConfiguration
                    - campusPodDetails
                    - splineDefaults
                    - ospfConfiguration
                    - siteUnderlayRoutingProtocol
                    - campusPods
                    - vrfs
                    - vlans
                    - allowAllVlansOnTrunkToggle
                    - defaultSpanningTreeDetails
            siteResolver:
              id: siteResolver
              name: site
              label: Site
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: siteFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            campusDetails:
              id: campusDetails
              name: campusDetails
              label: Campus Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - siteResolver
            campus:
              id: campus
              name: campus
              label: Campus
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campus
        layout:
          value: |
            {
              "siteFacts":{
                "key":"siteFacts",
                "type":"INPUT",
                "order":[
                  "siteUnderlayRoutingProtocol",
                  "overlayDetails",
                  "splineTagger",
                  "splineDefaults",
                  "campusPods",
                  "campusPodDetails",
                  "defaultSpanningTreeDetails",
                  "mlagConfiguration",
                  "ospfConfiguration",
                  "vrfs",
                  "vlans",
                  "allowAllVlansOnTrunkToggle"
                ]
              },
              "fabricSubnet":{
                "key":"fabricSubnet",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "fabricChildSubnetsMask":{
                "key":"fabricChildSubnetsMask",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vxlanOverlay":{
                "key":"vxlanOverlay",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vtepAddressRange":{
                "key":"vtepAddressRange",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafBgpAS":{
                "key":"leafBgpAS",
                "dependency":{
                  "campusPodUnderlayRoutingProtocol":{
                    "value":[
                      "bgp"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "campusPodFacts":{
                "key":"campusPodFacts",
                "type":"INPUT",
                "order":[
                  "podId",
                  "leafTagger",
                  "memberLeafTagger"
                ]
              },
              "campusPodBgpDefaultsConfigStatement":{
                "key":"campusPodBgpDefaultsConfigStatement",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "campusPodDetails":{
                "key":"campusPodDetails",
                "type":"INPUT",
                "order":[
                  "uplinkType",
                  "campusPodUplinkIpv4Pool",
                  "campusPodRouterIdPool",
                  "campusPodBgpAsRange",
                  "campusPodBgpDefaults"
                ]
              },
              "splineDefaults":{
                "key":"splineDefaults",
                "type":"INPUT",
                "order":[
                  "splineRouterIdPool",
                  "splineBgpAs",
                  "splineBgpDefaults",
                  "defaultSplineProperties"
                ]
              },
              "campusPodUnderlayRoutingProtocol":{
                "key":"campusPodUnderlayRoutingProtocol",
                "type":"INPUT",
                "dependency":{
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodRouterIdPool":{
                "key":"campusPodRouterIdPool",
                "type":"INPUT",
                "dependency":{
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodBgpAsRange":{
                "key":"campusPodBgpAsRange",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "splineBgpAs":{
                "key":"splineBgpAs",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "splineBgpDefaultsConfigStatement":{
                "key":"splineBgpDefaultsConfigStatement",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "ospfProcessId":{
                "key":"ospfProcessId",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfArea":{
                "key":"ospfArea",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfMaxLsa":{
                "key":"ospfMaxLsa",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfBfdKnob":{
                "key":"ospfBfdKnob",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "campusPodUplinkIpv4Pool":{
                "key":"campusPodUplinkIpv4Pool",
                "type":"INPUT",
                "dependency":{
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineVtepKnob":{
                "key":"splineVtepKnob",
                "type":"INPUT",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mlagConfiguration":{
                "key":"mlagConfiguration",
                "type":"INPUT",
                "order":[
                  "mlagPeerLinkVlan",
                  "mlagPeerIPv4Pool",
                  "mlagSubnetMask",
                  "mlagPeerL3Vlan",
                  "mlagPeerL3IPv4Pool",
                  "mlagPeerL3SubnetMask",
                  "mlagPortChannelId",
                  "virtualRouterMacAddress",
                  "lacpMode"
                ]
              },
              "splineTagger":{
                "type":"TAGGER",
                "parentKey":"siteFacts",
                "key":"splineTagger",
                "name":"Splines",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Spline",
                "tagType":"DEVICE",
                "description":"Splines are often the switch at the MDF layer which sit between the core and IDF layers.  Each spline at this site should have a unique NodeId value starting from 1.",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "roleTagger":{
                "type":"TAGGER",
                "parentKey":"campusDetails",
                "key":"roleTagger",
                "name":"Role",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Assign a role to each switch in this campus.",
                "columns":[
                  {
                    "tagLabel":"Role",
                    "suggestedValues":[
                      "Spline",
                      "Leaf",
                      "Member-Leaf"
                    ]
                  }
                ]
              },
              "campusDetails":{
                "key":"campusDetails",
                "type":"INPUT",
                "order":[
                  "siteResolver",
                  "roleTagger"
                ]
              },
              "leafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"leafTagger",
                "name":"Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "memberLeafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"memberLeafTagger",
                "name":"Member Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Member-Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[

                    ]
                  }
                ]
              },
              "campusPodResolver":{
                "key":"campusPodResolver",
                "type":"INPUT",
                "isPageLayout":true,
                "showDefaultRow":false
              },
              "overlayDetails":{
                "key":"overlayDetails",
                "type":"INPUT",
                "order":[
                  "vxlanOverlay",
                  "vtepAddressRange"
                ]
              },
              "campusPods":{
                "key":"campusPods",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "siteResolver":{
                "key":"siteResolver",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "campus":{
                "key":"campus",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlansCampusPodResolver":{
                "key":"vlansCampusPodResolver",
                "type":"INPUT"
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlansCampusPodSviIpAddress":{
                "key":"vlansCampusPodSviIpAddress",
                "dependency":{
                  "uplinkType":{
                    "value":[
                      "p2p"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vlansDetails":{
                "key":"vlansDetails",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlansCampusPodResolver",
                  "vlanName",
                  "vlanCampusSviGroup",
                  "vlanDhcpHelpers",
                  # "vlanSpanningTreeDetails",
                  "vlanSviEosCli"
                ]
              },
              "vlanCampusSviGroup":{
                "key":"vlanCampusSviGroup",
                "type":"INPUT",
                "order":[
                  "vlanCampusSviVrf",
                  "vlanL2CampusSviIpAddress"
                ]
              },
              "vlanL2CampusSviIpAddress":{
                "key":"vlanL2CampusSviIpAddress",
                "dependency":{
                  "uplinkType":{
                    "value":[
                      "port-channel"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfStaticRoutes":{
                "key":"vrfStaticRoutes",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfExternalBgpPeers":{
                "key":"vrfExternalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              # },
              # "vlanSpanningTreePriority":{
              #   "key":"vlanSpanningTreePriority",
              #   "dependency":{
              #     "spanningTreeMode":{
              #       "value":[
              #         "Rapid-PVST",
              #         "MSTP"
              #       ],
              #       "mode":"SHOW"
              #     }
              #   },
              #   "dependencyType":"OR",
              #   "type":"INPUT"
              # },
              # "vlanMstInstance":{
              #   "key":"vlanMstInstance",
              #   "type":"INPUT",
              #   "dependencyType":"AND",
              #   "dependency":{
              #     "spanningTreeMode":{
              #       "value":[
              #         "MSTP"
              #       ],
              #       "mode":"SHOW"
              #     }
              #   }
              }
            }
