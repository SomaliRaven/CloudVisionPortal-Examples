- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: campus-fabric-advanced
        workspace_id: ''
      display_name: Campus Fabric v2
      description: 'Provision the fabric of an L2 or L3 campus network.'
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |-
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          from collections import Counter, OrderedDict
          ## from packaging import version
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.services import TagServiceStub, \
              TagAssignmentServiceStub, \
              TagConfigServiceStub,\
              TagAssignmentConfigServiceStub
          from arista.tag.v2.services.gen_pb2 import TagRequest, \
              TagConfigSetRequest, \
              TagStreamRequest, \
              TagConfigStreamRequest, \
              TagAssignmentStreamRequest, \
              TagAssignmentConfigSetRequest, \
              TagAssignmentConfigStreamRequest
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          fabric_variables  = {
              "bgp_peer_groups": {
                  "IPv4_UNDERLAY_PEERS": {
                      "name": "IPv4_UNDERLAY_PEERS",
                      "password": None
                  },
                  "MLAG_IPv4_UNDERLAY_PEER": {
                      "name": "MLAG-IPv4-UNDERLAY-PEER",
                      "password": None,
                  },
                  "EVPN_OVERLAY_PEERS": {
                      "name": "EVPN_OVERLAY_PEERS",
                      "password": None
                  }
              },
              "bfd_multihop": {
                  "interval": 300,
                  "min_rx": 300,
                  "multiplier": 3
              },
              "evpn_ebgp_multihop": 3,
              "evpn_hostflap_detection": {
                  "enabled": True,
                  "threshold": 5,
                  "window": 180
              }
          }

          jericho_platform_regexes = [
              r'7048T',
              r'7280',
              r'75\d\d',
              r'780\d'
          ]

          veos_regex = r'(v|c)EOS(-)*(Lab)*'

          def convert(text):
              return int(text) if text.isdigit() else text.lower()

          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]

          def natural_sort(iterable):
              if iterable is None:
                  return list()
              return sorted(iterable, key=alphanum_key)

          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",") if segment.strip() != ""]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          if i not in numbers:
                              numbers.append(i)
                  else:
                      if int(segment) not in numbers:
                          numbers.append(int(segment))
              return numbers

          def get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=True):
              '''
              Returns all tags applied to a device that match the label of the input tag_assignment_key

              Args:
                  tag_assignment_key: TagAssignmentKey object with the label field set
              '''
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              # Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              # Create TagValueSearchRequest
              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
                  tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags

          def get_tag_value(device_id=None, label=None, workspace_id=None, topology_studio_request=True):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=topology_studio_request)
              if len(tag_values) > 0:
                  return tag_values[0].value

          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [ tag_value.value for tag_value in tag_values ]

          def create_tag(tag_key):
              '''
              tag_key is a TagKey
              '''
              tcsr = TagConfigSetRequest()
              tcsr.value.key.workspace_id.value = tag_key.workspace_id.value
              tcsr.value.key.element_type = tag_key.element_type
              tcsr.value.key.label.value = tag_key.label.value
              tcsr.value.key.value.value = tag_key.value.value
              client = ctx.getApiClient(TagConfigServiceStub)
              client.Set(tcsr)

          def apply_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = False
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = True
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_all_tag_values(tag_label, device_id, workspace_id, value=None):
              '''
              Removes all tags with the input tag label matchiing the input device_id
              If a value is supplied, only tags matching the label and value will be removed from the device
              '''
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = tag_label
              # tag_assignment_key.value.value = None
              matching_tags = get_tag_values_applied_to_device(tag_assignment_key)
              # If there are any mlag_configuration.peer_link tags applied
              if len(matching_tags) > 0:
                  # Remove tags
                  for tag in matching_tags:
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      if value is None:
                          remove_tag(tak_to_remove)
                      else:
                          if tag.value == value:
                              remove_tag(tak_to_remove)
          def update_device_tag(tag_assignment_key, multiple_values=False):
              """
              tag_assignment_key is a TagAssignmentKey that you want to update the device with
              """
              applied_tags = get_tag_values_applied_to_device(tag_assignment_key)
              already_assigned = False
              for tag in applied_tags:
                  if tag.value != tag_assignment_key.value.value:
                      if multiple_values == True:
                          continue
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      remove_tag(tak_to_remove)
                  else:
                      already_assigned = True

              if already_assigned:
                  return

              #Create desired tag
              tag_key = TagKey()
              tag_key.workspace_id.value = workspace_id
              tag_key.element_type = 1
              tag_key.label.value = tag_assignment_key.label.value
              tag_key.value.value = tag_assignment_key.value.value
              create_tag(tag_key)

              # Apply desired tag
              apply_tag(tag_assignment_key)

          def update_tags(switch_facts):
              device_id = switch_facts["serial_number"]
              # node_id tag
              # Create/Update/Apply the node_id tag
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = "node_id"
              tag_assignment_key.value.value = str(switch_facts["id"])
              update_device_tag(tag_assignment_key)
              # Update campus-pod tag
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "Campus-Pod"
                  tag_assignment_key.value.value = str(switch_facts["group"])
                  update_device_tag(tag_assignment_key)
              # Update network services tags
              if switch_facts["network_services"].get("l2"):
                  # Create/Apply the following tag 'network_services:L2'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "network_services"
                  tag_assignment_key.value.value = "L2"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L2'
                  remove_all_tag_values("network_services", device_id, workspace_id, value="L2")
              if switch_facts["network_services"].get("l3"):
                  # Create/Apply the following tag 'network_services:L3'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "network_services"
                  tag_assignment_key.value.value = "L3"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L3'
                  remove_all_tag_values("network_services", device_id, workspace_id, value="L3")
              # Update mlag_configuration.peer_link
              if switch_facts.get("mlag"):
                  mlag_peer_link = "Port-Channel{}".format(switch_facts["mlag_port_channel_id"])
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "mlag_configuration.peer_link"
                  tag_assignment_key.value.value = str(mlag_peer_link)
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("mlag_configuration.peer_link", device_id, workspace_id)
                  
              # Update routing tags
              bgp_tags = {"router_bgp.as": switch_facts.get("bgp_as"), "router_bgp.router_id": switch_facts.get("router_id")}
              if switch_facts.get("underlay_router") \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  # Set bgp as and router id tags
                  for label, value in bgp_tags.items():
                      tag_assignment_key = TagAssignmentKey()
                      tag_assignment_key.workspace_id.value = workspace_id
                      tag_assignment_key.element_type = 1
                      tag_assignment_key.device_id.value =  device_id
                      tag_assignment_key.label.value = str(label)
                      tag_assignment_key.value.value = str(value)
                      update_device_tag(tag_assignment_key)
              else:
                  # Remove possible bgp tags
                  for label, value in bgp_tags.items():
                      #Remove tags with same label that don't match proper value
                      if value is None:
                          remove_all_tag_values(str(label), device_id, workspace_id)
              # Update VTEP tag
              if switch_facts.get("vtep"):
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "vtep"
                  tag_assignment_key.value.value = "True"
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("vtep", device_id, workspace_id)
              return

          def get_interfaces_info(switch_facts):
              device_id = switch_facts["serial_number"]
              uplink_interfaces = {}
              downlink_interfaces = {}
              mlag_peer_link_interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None:
                      if switches_in_my_campus.get(peer_device.id):
                          neighbor = switches_in_my_campus.get(peer_device.id)
                          if switch_facts["type"] == "spline":
                              if neighbor["type"] == "spline":
                                  mlag_peer_link_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] in ["leaf", "memberleaf"]:
                                  downlink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                          elif switch_facts["type"] == "leaf":
                              if neighbor["type"] == "spline":
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] == "memberleaf":
                                  downlink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif neighbor["type"] == "leaf":
                                  mlag_peer_link_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                          elif switch_facts["type"] == "memberleaf":
                              if neighbor["type"] in ["leaf", "spline"]:
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}

              return OrderedDict(natural_sort(uplink_interfaces.items())), \
                      OrderedDict(natural_sort(downlink_interfaces.items())), \
                      OrderedDict(natural_sort(mlag_peer_link_interfaces.items()))

          def get_highest_spline_node_id_in_my_site(switch_facts):
              highest_spline_node_id = 0
              for switch_facts in switches_in_my_campus.values():
                  if switch_facts["site"] == switch_facts["site"] and \
                      switch_facts["type"] == "spline" and switch_facts["id"] > highest_spline_node_id:
                      highest_spline_node_id = switch_facts["id"]
              return highest_spline_node_id

          def get_highest_leaf_node_id_in_my_site(switch_facts):
              highest_leaf_node_id = 0
              for switch_facts in switches_in_my_campus.values():
                  if switch_facts["site"] == switch_facts["site"] and \
                     switch_facts["type"] == "leaf" and switch_facts["id"] > highest_leaf_node_id:
                      highest_leaf_node_id = switch_facts["id"]
              return highest_leaf_node_id

          def get_inband_management_ip(switch_facts):
              if switch_facts["type"] == "spline":
                  return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())[switch_facts["id"]]
              else:
                  spline_offset = get_highest_spline_node_id_in_my_site(switch_facts)
                  leaf_offset = get_highest_leaf_node_id_in_my_site(switch_facts)
                  if site_details["campusPodDetails"]["uplinkType"] == "port-channel":    
                      if switch_facts["type"] == "leaf":
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                                  [switch_facts["id"] + spline_offset]
                      else:
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                                  [switch_facts["id"] + spline_offset + leaf_offset]
                  else:
                      if switch_facts["type"] == "leaf":
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                              [switch_facts["id"]]
                      else:
                          return list(ipaddress.ip_network(switch_facts["inband_management_ip"]).hosts())\
                              [switch_facts["id"] + leaf_offset]

          def get_router_id(switch_facts):
              router_id_subnet = switch_facts["loopback_ipv4_pool"]
              switch_id = switch_facts["id"]
              offset = switch_facts["loopback_ipv4_offset"]
              return list(ipaddress.ip_network(router_id_subnet).hosts())[(switch_id - 1) + offset]

          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_subnet_mask, "MLAG Subnet mask length must be longer than the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[int(switch_facts["mlag_primary_id"]) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return

          def get_vtep_loopback(switch_facts, offset=None):
              if switch_facts["type"] == "spline" or offset is None:
                  offset = 0
              vtep_loopback_subnet = switch_facts["vtep_loopback_ipv4_pool"]
              if switch_facts.get("mlag_primary_id"):
                  switch_id = switch_facts["mlag_primary_id"] - 1 + offset
                  switch_id = switch_facts["group_index"] + offset
              else:
                  switch_id = switch_facts["id"] - 1 + offset
                  switch_id = switch_facts["group_index"] + offset
              return list(ipaddress.ip_network(vtep_loopback_subnet).hosts())[switch_id]

          def get_p2p_uplinks_ip(switch_facts, uplink_switch_facts):
              if switch_facts.get("type") != "leaf":
                  return
              uplink_ipv4_pool = switch_facts["uplink_ipv4_pool"]
              uplink_subnet_mask = switch_facts["uplink_ipv4_subnet_mask"]
              switch_id = switch_facts["id"]
              uplink_switch_id = uplink_switch_facts["id"]
              max_uplink_switches = get_highest_spline_node_id_in_my_site(switch_facts)
              max_parallel_uplinks = 1
              child_subnet = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask)) \
                  [ (switch_id - 1) * max_uplink_switches * max_parallel_uplinks + (uplink_switch_id - 1) ]
              return list(child_subnet.hosts())[1]

          def get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts):
              if switch_facts.get("type") != "leaf":
                  return
              uplink_ipv4_pool = switch_facts["uplink_ipv4_pool"]
              uplink_subnet_mask = switch_facts["uplink_ipv4_subnet_mask"]
              switch_id = switch_facts["id"]
              uplink_switch_id = uplink_switch_facts["id"]
              max_uplink_switches = get_highest_spline_node_id_in_my_site(switch_facts)
              max_parallel_uplinks = 1
              child_subnet = list(ipaddress.ip_network(uplink_ipv4_pool).subnets(new_prefix=uplink_subnet_mask)) \
                  [ (switch_id - 1) * max_uplink_switches * max_parallel_uplinks + (uplink_switch_id - 1) ]
              return list(child_subnet.hosts())[0]

          def set_bgp_as_from_studio_input(switch_facts, campus_resolver):
              if switch_facts["type"] not in ["leaf"]:
                  return switch_facts
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=switch_facts["serial_number"])
              site_facts = campus_resolved["campusDetails"]["site"].resolve(device=switch_facts["serial_number"])["siteFacts"]
              ## assert site_facts is not None, "{} resolves site_facts to None".format(switch_facts["hostname"])
              ## assert site_facts["campusPods"] is not None, "{} does not have value for 'campusPods' key".format(switch_facts["hostname"])
              ## assert site_facts["campusPods"].resolve(device=switch_facts["serial_number"]) is not None, "{} resolves 'campusPods' to None".format(switch_facts["hostname"])
              pod_facts = site_facts["campusPods"].resolve(device=switch_facts["serial_number"])["campusPodFacts"]
              if pod_facts.get("leafBgpConfiguration") and \
                  pod_facts["leafBgpConfiguration"].get("leafBgpAs") and \
                  pod_facts["leafBgpConfiguration"]["leafBgpAs"] != 0:
                  switch_facts["bgp_as"] = pod_facts["leafBgpConfiguration"]["leafBgpAs"]

              return switch_facts

          def set_topology_facts(switch_facts):
              topology_facts = {
                  "links": {}
              }
              if switch_facts["uplink_type"] == "p2p":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      link_facts["peer_bgp_as"] = uplink_switch_facts.get("bgp_as")
                      link_facts["type"] = "underlay_p2p"
                      link_facts["ip_address"] = str(get_p2p_uplinks_ip(switch_facts, uplink_switch_facts))
                      link_facts["peer_ip_address"] = str(get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts))
                      if switch_facts.get("underlay_multicast"):
                          link_facts["pim_enabled"] = True
                      else:
                          link_facts["pim_enabled"] = False
                      topology_facts["links"][uplink_interface] = link_facts

              elif switch_facts["uplink_type"] == "port-channel":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      link_facts["type"] = "underlay_l2"
                      if uplink_switch_facts.get("mlag") is not None and uplink_switch_facts.get("mlag") == True:
                          link_facts["channel_description"] = uplink_switch_facts["group"]
                      if switch_facts.get("mlag") is not None and switch_facts.get("mlag") == True:
                          link_facts["peer_channel_description"] = switch_facts["group"]
                      if switch_facts.get("mlag_role") is not None and switch_facts["mlag_role"] == "secondary":
                          mlag_peer_switch_facts =  switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_switch_interfaces"][0]))
                      else:
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_switch_interfaces"][0]))
                      topology_facts["links"][uplink_interface] = link_facts

              switch_facts["topology"] = topology_facts
              return switch_facts

          def get_switch_basics(device_id, campus_resolver):
              # Process Studio inputs
              campus_resolved = campus.resolve(device=device_id)
              site_details = campus_resolved["campusDetails"]["site"].resolve(device=device_id)["siteFacts"]
              switch_facts = {}
              switch_facts = {"serial_number": device_id}
              ## switch_facts["fabric_type"] = "L3" if site_details["campusPodDetails"]["uplinkType"] == "p2p" else "L2"
              # Get facts from tags
              switch_facts["hostname"] = [ dev.hostName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["platform"] = [ dev.modelName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["campus"] = get_tag_value(device_id=device_id, label="Campus", workspace_id=workspace_id)
              switch_facts["site"] = get_tag_value(device_id=device_id, label="Site", workspace_id=workspace_id)
              switch_facts["eos_version"] = get_tag_value(device_id=device_id, label="eos", workspace_id=workspace_id, topology_studio_request=False)

              # First attempt to set switch role
              switch_role = None
              potential_roles = {"Leaf": "leaf", "Spline": "spline", "Member-Leaf": "memberleaf"}
              roles_applied_to_switch = get_tag_values(device_id=device_id, label="Role", workspace_id=workspace_id)
              if roles_applied_to_switch is not None:
                  for role in potential_roles.keys():
                      if role in roles_applied_to_switch:
                          switch_role = role
                          break
              ## assert False, "{}'s role: {}".format(switch_facts["hostname"], switch_role)
              if assert_tag_error:
                  assert switch_role != None, "Make sure {} is tagged with a valid switch role. Valid switch roles are 'Leaf', 'Spine', 'Super-Spine', and 'L2-Leaf'.".format(switch_facts["hostname"])
              switch_facts["type"] = potential_roles.get(switch_role)

              # Set switch id based on mini-tagger values

              switch_facts["id"] = int(get_tag_value(device_id=device_id, label="node_id", workspace_id=workspace_id)) if get_tag_value(device_id=device_id, label="node_id", workspace_id=workspace_id) is not None else None
              ## assert False, "{}'s id: {}".format(switch_facts["hostname"], switch_facts["id"])
             
              # Check to see that a type is set
              if not switch_facts.get("id") or not switch_facts.get("type"):
                  return

              
              # Check to see if my_device is a spline
              if switch_facts["type"] == "spline":
                  ## switch_facts["type"] = "spline"
                  switch_facts["group"] = "{}_{}_Splines".format(switch_facts["campus"], switch_facts["site"])
                  switch_facts["group_index"] = 0
                  switch_facts["underlay_router"] = True
                  switch_facts["uplink_type"] = "p2p"
                  if site_details["campusPodDetails"]["uplinkType"] == "port-channel":
                      switch_facts["vtep"] = True
                      switch_facts["mlag_support"] = True
                      switch_facts["evpn_role"] = "client"
                      switch_facts["network_services"] = {
                          "l2": True,
                          "l3": True
                      }
                  elif site_details["campusPodDetails"]["uplinkType"] == "p2p":
                      switch_facts["vtep"] = True if site_details["splineDefaults"].get("vtep") else False
                      switch_facts["mlag_support"] = False
                      switch_facts["evpn_role"] = "server"
                      switch_facts["network_services"] = {
                          "l2": False,
                          "l3": True
                      }
              # If switch still hasn't been found, check to see if it is a leaf
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  pod = site_details["campusPods"]
                  switch_facts["pod"] = pod.resolve(device=device_id)
                  # Get Campus-Pod tag
                  campus_pod_id = get_tag_value(device_id=device_id, label="Campus-Pod", workspace_id=workspace_id)
                  if campus_pod_id is None:
                      return
                  switch_facts["group"] = campus_pod_id
                  switch_facts["group_index"] = int(switch_facts["group"]) - 1
                  if switch_facts["type"] == "leaf":
                      ## switch_facts["type"] = "leaf"
                      if site_details["campusPodDetails"]["uplinkType"] == "port-channel":
                          switch_facts["vtep"] = False
                          switch_facts["mlag_support"] = True
                          switch_facts["evpn_role"] = None
                          switch_facts["underlay_router"] = False
                          switch_facts["uplink_type"] = "port-channel"
                          switch_facts["network_services"] = {
                              "l2": True,
                              "l3": False
                          }
                      elif site_details["campusPodDetails"]["uplinkType"] == "p2p":
                          switch_facts["vtep"] = True
                          switch_facts["mlag_support"] = True
                          switch_facts["underlay_router"] = True
                          switch_facts["evpn_role"] = "client"
                          switch_facts["uplink_type"] = "p2p"
                          switch_facts["network_services"] = {
                              "l2": True,
                              "l3": True
                          }
                  else:
                      ## switch_facts["type"] = "memberleaf"
                      switch_facts["vtep"] = False
                      switch_facts["mlag_support"] = False
                      switch_facts["underlay_router"] = False
                      switch_facts["evpn_role"] = None
                      switch_facts["uplink_type"] = "port-channel"
                      switch_facts["network_services"] = {
                          "l2": True,
                          "l3": False
                      }

              # Return switch_facts if switch was found in studios input
              if switch_facts.get("type") is not None:
                  return switch_facts

          def get_switches_in_my_campus_basics(switch_facts):
              # Dictionary of switches that will be returned
              switches_in_my_campus = {}

              #Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              #Get switches in same Campus
              query= "{}:\"{}\"".format("Campus", switch_facts["campus"])
              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
              for match in tagmresp.matches:
                  switch_in_my_campus_facts = get_switch_basics(match.device.device_id, campus)
                  if switch_in_my_campus_facts is None:
                      continue
                  if match.device.device_id not in switches_in_my_campus:
                      switches_in_my_campus[match.device.device_id] = switch_in_my_campus_facts
              return switches_in_my_campus

          def set_switch_facts(switch_facts, campus_resolver):
              device_id = switch_facts["serial_number"]
              campus_resolved = campus.resolve(device=device_id)
              site_details = campus_resolved["campusDetails"]["site"].resolve(device=device_id)["siteFacts"]
              # Get interface info from studio topology tags
              uplink_interfaces, downlink_interfaces, mlag_peer_link_interfaces = get_interfaces_info(switch_facts)

              # Get fabric details
              if switch_facts["underlay_router"] == True:
                  if switch_facts["type"] == "spline":
                      switch_facts["underlay_routing_protocol"] = site_details["splineDefaults"]["underlayRoutingProtocol"]
                  else:
                      switch_facts["underlay_routing_protocol"] = site_details["campusPodDetails"]["underlayRoutingProtocol"]
                  if site_details["overlayDetails"].get("vxlanOverlay") == True:
                      switch_facts["overlay_routing_protocol"] = "bgp"
                  else:
                      switch_facts["overlay_routing_protocol"] = ""
                  if site_details.get("multicast"):
                      switch_facts["underlay_multicast"] = True
                  else:
                      switch_facts["underlay_multicast"] = False

              # Get spanning tree details
              if switch_facts["type"] == "memberleaf":
                  # Member switches shouldn't need to run spanning tree since all uplink ports to other switches will be forwarding in a port-channel and all access ports should not be connected to switches and have proper bpdu guards enabled
                  # Set spanning_tree_mode to none to take advantage of hitless upgrade capability.
                  switch_facts["spanning_tree_mode"] = "mstp"
              elif switch_facts["network_services"].get("l2"):
                  switch_facts["spanning_tree_mode"] = site_details["spanningTreeMode"].lower()


              # Get virtual router mac 
              if switch_facts["network_services"]["l2"] == True and \
                  switch_facts["network_services"]["l3"] == True:
                  switch_facts["virtual_router_mac_address"] = site_details["mlagConfiguration"]["virtualRouterMacAddress"]

              # Define switch uplink info
              switch_facts["uplink_switches_ids"] = [ info["neighborId"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switches"] = [ info["neighborHostname"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switch_interfaces"] = [ info["neighborInterface"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_interfaces"] = [ iface for iface in uplink_interfaces.keys() ]

              # Define switch downlink neighbor ids
              switch_facts["downlink_switches_ids"] = [ info["neighborId"] for info in downlink_interfaces.values() ]

              # Get mlag settings
              if switch_facts["mlag_support"] == True:
                  if len(mlag_peer_link_interfaces) > 0:
                      switch_facts["mlag"] = True
                  else:
                      switch_facts["mlag"] = False
                  
                  if switch_facts["mlag"] == True:
                      if switch_facts["type"] == "spline":
                          switch_facts["mlag_group"] = "Splines"
                      elif switch_facts["type"] == "leaf":
                          switch_facts["mlag_group"] = switch_facts["group"]
                      if switch_facts["underlay_router"] == True:
                          switch_facts["mlag_l3"] = True
                      else:
                          switch_facts["mlag_l3"] = False
                      switch_facts["mlag_peer_vlan"] =  site_details["mlagConfiguration"]["mlagPeerLinkVlan"]
                      switch_facts["mlag_peer_l3_vlan"] = switch_facts["mlag_peer_vlan"]
                      switch_facts["mlag_port_channel_id"] = site_details["mlagConfiguration"]["mlagPortChannelId"]
                      switch_facts["mlag_peer_ipv4_pool"] = site_details["mlagConfiguration"]["mlagPeerLinkSubnet"]
                      switch_facts["mlag_subnet_mask"] = site_details["mlagConfiguration"]["mlagSubnetMask"]
                      switch_facts["mlag_lacp_mode"] = site_details["mlagConfiguration"]["lacpMode"]
                      switch_facts["reload_delay_mlag"] = 300
                      switch_facts["reload_delay_non_mlag"] = 330
                      switch_facts["mlag_ibgp_origin_incomplete"] = True
                      switch_facts["mlag_peer_serial_number"] = [ info["neighborId"] for info in mlag_peer_link_interfaces.values() ][0]
                      mlag_peer_switch_facts = switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
                      switch_facts["mlag_peer"] = mlag_peer_switch_facts["hostname"]
                      switch_facts["mlag_peer_switch_interfaces"] = [ info["neighborInterface"] for info in mlag_peer_link_interfaces.values() ]
                      switch_facts["mlag_interfaces"] = [ iface for iface in mlag_peer_link_interfaces.keys() ]
                      if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                          switch_facts["mlag_primary_id"] = int(switch_facts["id"])
                          switch_facts["mlag_role"] = "primary"
                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts, 
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "primary"))
                          switch_facts["mlag_l3_ip"] = switch_facts["mlag_ip"]
                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, 
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "secondary"))
                          switch_facts["mlag_peer_l3_ip"] = switch_facts["mlag_peer_ip"]
                      else:
                          switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])
                          switch_facts["mlag_role"] = "secondary"
                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts, 
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "secondary"))
                          switch_facts["mlag_l3_ip"] = switch_facts["mlag_ip"]
                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, 
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_subnet_mask"], "primary"))
                          switch_facts["mlag_peer_l3_ip"] = switch_facts["mlag_peer_ip"]

              if switch_facts["underlay_router"] == True:
                  # Parse user inputs to get transit ips and router ids
                  switch_facts["uplink_ipv4_pool"] = site_details["campusPodDetails"]["uplinkIpv4Pool"]
                  switch_facts["uplink_ipv4_subnet_mask"] = 31  # site_details["routingDetails"]["fabricChildSubnetsMask"]
                  if switch_facts["type"] == "spline":
                      switch_facts["loopback_ipv4_pool"] = site_details["splineDefaults"]["routerIdPool"]
                      switch_facts["loopback_ipv4_offset"] = 0
                  elif switch_facts["type"] == "leaf":
                      switch_facts["loopback_ipv4_pool"] = site_details["campusPodDetails"]["routerIdPool"]
                      if site_details["splineDefaults"]["routerIdPool"] == site_details["campusPodDetails"]["routerIdPool"]:
                          # Calculate offset
                          switch_facts["loopback_ipv4_offset"] = get_highest_spline_node_id_in_my_site(switch_facts)
                      else:
                          # Offset is 0
                          switch_facts["loopback_ipv4_offset"] = 0
                  # Get Router ID
                  switch_facts["router_id"] = str(get_router_id(switch_facts))
                  # Set BGP parameters
                  if switch_facts["underlay_routing_protocol"] == "bgp" or switch_facts["overlay_routing_protocol"] == "bgp":
                      if switch_facts["type"] == "spline":
                          asns = string_to_list(str(site_details["splineDefaults"]["splineBgpAs"]))
                          if len(asns) > 1:
                              switch_facts["bgp_as"] = asns[switch_facts["group_index"]]
                          else:
                              switch_facts["bgp_as"] = asns[0]
                          switch_facts["bgp_defaults"] = site_details["splineDefaults"]["splineDefaults"]
                          switch_facts["bgp_maximum_paths"] = 4
                          switch_facts["bgp_ecmp"] = 4
                      elif switch_facts["type"] == "leaf":
                          if switch_facts.get("bgp_as") is None:
                              asns = string_to_list(str(site_details["campusPodDetails"]["bgpAsRange"]))
                              if len(asns) > 1:
                                  # remove any manually set bgp_as numbers
                                  manually_set_leaf_domains = {}
                                  for switch_in_my_campus_facts in switches_in_my_campus.values():
                                      if manually_set_leaf_domains.get(switch_facts["group_index"]):
                                          switch_facts["bgp_as"] = manually_set_leaf_domains[switch_facts["group_index"]]
                                          break
                                      if switch_in_my_campus_facts.get("bgp_as") is not None and switch_in_my_campus_facts["bgp_as"] in asns:
                                          if int(switch_in_my_campus_facts["group_index"]) not in manually_set_leaf_domains:
                                              manually_set_leaf_domains[int(switch_in_my_campus_facts["group_index"])] = switch_in_my_campus_facts["bgp_as"]
                                              asns.remove(switch_in_my_campus_facts["bgp_as"])

                                  # check to see if this switch's leaf_domain is already set
                                  if not switch_facts.get("bgp_as"):    
                                      # get leaf_domain shift
                                      leaf_domain_shift = len([ld for ld in manually_set_leaf_domains.keys() if ld < int(switch_facts["group_index"])])
                                      # set bgp_as
                                      switch_facts["bgp_as"] = asns[int(switch_facts["group_index"]) - leaf_domain_shift]
                              else:
                                  switch_facts["bgp_as"] = asns[0]
                          switch_facts["bgp_defaults"] = site_details["campusPodDetails"]["campusPodDefaults"]
                          switch_facts["bgp_maximum_paths"] = get_highest_spline_node_id_in_my_site(switch_facts)
                          switch_facts["bgp_ecmp"] = get_highest_spline_node_id_in_my_site(switch_facts)
                      switch_facts["evpn_route_servers"] = switch_facts["uplink_switches"]
                      switch_facts["evpn_route_server_ids"] = switch_facts["uplink_switches_ids"]
                  # Set ospf parameters
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      switch_facts["underlay_ospf_process_id"] = site_details["ospfConfiguration"]["processId"]
                      switch_facts["underlay_ospf_area"] = site_details["ospfConfiguration"]["area"]
                      switch_facts["underlay_ospf_max_lsa"] = site_details["ospfConfiguration"]["maxLsa"]
                      switch_facts["underlay_ospf_bfd_enable"] = site_details["ospfConfiguration"]["bfd"]
                      if switch_facts["type"] == "spline":
                          switch_facts["ospf_defaults"] = site_details["splineDefaults"]["splinesOspfDefaults"]
                      elif switch_facts["type"] == "leaf":
                          switch_facts["ospf_defaults"] = site_details["campusPodDetails"]["leafsOspfDefaults"]
                  if switch_facts["vtep"] and site_details["overlayDetails"]["vxlanOverlay"] == True:
                      switch_facts["vtep_loopback_ipv4_pool"] = site_details["overlayDetails"]["vtepAddressRange"]
                      switch_facts["vtep_loopback"] = "Loopback1"
                      if site_details["splineDefaults"].get("vtep"):
                          vtep_offset = 1
                      else:
                          vtep_offset = 0
                      switch_facts["vtep_ip"] =  str(get_vtep_loopback(switch_facts, offset=vtep_offset))
                  else:
                      # Turn off the vtep setting since there are no VTEPs in this network
                      switch_facts["vtep"] = False

              # Get inband management details
              if site_details.get("inbandManagement"):
                  switch_facts["inband_management_subnet"] = site_details["inbandManagement"].get("managementSubnet")
                  switch_facts["inband_management_vlan"] = site_details["inbandManagement"].get("vlanId")
              if switch_facts.get("inband_management_subnet") and switch_facts.get("inband_management_vlan"):
                  switch_facts["inband_management_interface"] = "Vlan{}".format(switch_facts["inband_management_vlan"])
                  switch_facts["inband_management_ip"] = "{}/{}".format(
                      str(get_inband_management_ip(switch_facts)),
                      str(ipaddress.ip_network(switch_facts["inband_management_subnet"]).prefixlen)
                  )
                  switch_facts["inband_management_gateway"] = str(list(ipaddress.ip_network(switch_facts["inband_management_subnet"])).hosts(0))

              ## if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3") and \
              ##     version.parse(switch_facts["eos_version"]) >= version.parse("4.27.1F"):
              ##     switch_facts["boot_vlan"] = switch_facts.get("inband_management_vlan")

              if re.match(veos_regex, switch_facts["platform"]):
                  switch_facts["p2p_uplinks_mtu"] = 1500
              else:
                  switch_facts["p2p_uplinks_mtu"] = 9214

              for regex in jericho_platform_regexes:
                  if re.search(regex, switch_facts["platform"]):
                      switch_facts["reload_delay_mlag"] = 780
                      switch_facts["reload_delay_non_mlag"] = 1020
                      break

              return switch_facts

          def set_base_config(config, switch_facts):
              # Set spanning tree
              if switch_facts.get("spanning_tree_mode"):
                  config["spanning_tree"]["mode"] = switch_facts["spanning_tree_mode"]
              # Set tcam profile
              for regex in jericho_platform_regexes:
                  if re.search(regex, switch_facts["platform"]):
                      config["tcam_profile"] = {
                          "system": "vxlan-routing"
                      }
                      break
              # Set routing
              config["service_routing_protocols_model"] = "multi-agent"
              if switch_facts["underlay_router"] == True:
                  config["ip_routing"] = True
                  if switch_facts.get("underlay_multicast"):
                      config["router_multicast"] = {
                          "ipv4": {
                              "routing": True
                          }
                      }
              # Set router-bgp
              if switch_facts["underlay_router"] == True \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  config["router_bgp"]["as"] = switch_facts["bgp_as"]
                  config["router_bgp"]["router_id"] = switch_facts["router_id"]
                  config["router_bgp"]["bgp_defaults"] = switch_facts["bgp_defaults"]
                  if switch_facts.get("bgp_maximum_paths") and switch_facts.get("bgp_ecmp"):
                      config["router_bgp"]["bgp_defaults"].append(
                          "maximum-paths {} ecmp {}".format(switch_facts["bgp_maximum_paths"], switch_facts["bgp_ecmp"])
                      )
                  elif switch_facts.get("bgp_maximum_paths"):
                      config["router_bgp"]["bgp_defaults"].append(
                          "maximum-paths {}".format(switch_facts["bgp_maximum_paths"])
                      )
              return config

          def set_mlag_config(config, switch_facts):
              if switch_facts.get("mlag"):
                  # Set spanning tree relevant config
                  config["spanning_tree"]["no_spanning_tree_vlan"] = switch_facts["mlag_peer_vlan"]

                  # Set mlag vlan
                  config["vlans"][switch_facts["mlag_peer_vlan"]] = {
                      "tenant": "system",
                      "name": "MLAG_PEER",
                      "trunk_groups": ["MLAG_PEER"]
                  }

                  # Set mlag svi
                  config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])] = {
                      "description": "MLAG PEER",
                      "shutdown": False,
                      "ip_address": "{}/{}".format(switch_facts["mlag_ip"], switch_facts["mlag_subnet_mask"]),
                      "no_autostate": True,
                      "mtu": switch_facts["p2p_uplinks_mtu"]
                  }
                  if switch_facts["mlag_l3"] == True and switch_facts["underlay_routing_protocol"] == "ospf":
                      config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])]\
                          ["ospf_network_point_to_point"] = True
                      config["vlan_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_vlan"])]\
                          ["ospf_area"] = switch_facts["underlay_ospf_area"]

                  # Set port-channel interfaces
                  config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])] = {
                      "description": "to {}".format(switch_facts["mlag_peer"]),
                      "type": "switched",
                      "shutdown": False,
                      "mode": "trunk",
                      "trunk_groups": ["MLAG_PEER"]
                  }

                  # Set ethernet interfaces
                  for i, iface in enumerate(switch_facts["mlag_interfaces"]):
                      config["ethernet_interfaces"][iface] = {
                          "peer": switch_facts["mlag_peer"],
                          "peer_interface": switch_facts["mlag_peer_switch_interfaces"][i],
                          "peer_type": "mlag",
                          "description": "MLAG_{}_{}".format(switch_facts["mlag_peer"], switch_facts["mlag_peer_switch_interfaces"][i]),
                          "type": "switched",
                          "shutdown": False,
                          "channel_group": {
                              "id": switch_facts["mlag_port_channel_id"],
                              "mode": switch_facts["mlag_lacp_mode"]
                          }
                      }

                  # Set mlag config
                  config["mlag_configuration"] = {
                      "enabled": True,
                      "domain_id": switch_facts["group"],
                      "local_interface": "Vlan{}".format(switch_facts["mlag_peer_vlan"]),
                      "peer_address": switch_facts["mlag_peer_ip"],
                      "peer_link": "Port-Channel{}".format(switch_facts["mlag_port_channel_id"]),
                      "reload_delay_mlag": switch_facts["reload_delay_mlag"],
                      "reload_delay_non_mlag": switch_facts["reload_delay_non_mlag"]
                  }

                  # Set route maps
                  # Origin Incomplete for MLAG iBGP learned routes
                  if switch_facts["mlag_l3"] == True and \
                      switch_facts["mlag_ibgp_origin_incomplete"] == True and \
                      switch_facts["underlay_routing_protocol"] == "bgp":
                      config["route_maps"]["RM-MLAG-PEER-IN"] = {
                          "sequence_numbers": {
                              10: {
                                  "type": "permit",
                                  "set": ["origin incomplete"],
                                  "description": "Make routes learned over MLAG Peer-link less preferred on spines to ensure optimal routing"
                              }
                          }
                      }
                  
                  # Set bgp config
                  if switch_facts["mlag_l3"] == True and switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]] = {
                          "type": "ipv4",
                          "remote_as": switch_facts["bgp_as"],
                          "next_hop_self": True,
                          "maximum_routes": 12000,
                          "send_community": "all" 
                      }
                      if fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["password"] is not None:
                          config["router_bgp"]["peer_groups"] \
                              [fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]]["password"] = \
                              fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["password"]
                      if switch_facts["mlag_ibgp_origin_incomplete"] == True:
                          config["router_bgp"]["peer_groups"] \
                              [fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]]["route_map_in"] = \
                              "RM-MLAG-PEER-IN"
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"]] = {
                          "activate": True
                      }
                      config["router_bgp"]["neighbor_interfaces"]["Vlan{}".format(switch_facts["mlag_peer_l3_vlan"])] = {
                          "peer_group": fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"],
                          "remote_as": switch_facts["bgp_as"],
                          "description": switch_facts["mlag_peer"]
                      }
                      config["router_bgp"]["neighbors"][switch_facts["mlag_peer_l3_ip"]] = {
                          "peer_group": fabric_variables["bgp_peer_groups"]["MLAG_IPv4_UNDERLAY_PEER"]["name"],
                          "description": switch_facts["mlag_peer"]
                      }

              return config

          def set_underlay_config(config, switch_facts):
              underlay_data = {}
              underlay_data["links"] = switch_facts["topology"]["links"]
              # First add interface details from devices whose uplink interface neighbors are this switch
              for sn in switch_facts["downlink_switches_ids"]:
                  neighbor_switch_facts = switches_in_my_campus[sn]
                  for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                      if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                          link = {}
                          link["peer_id"] = neighbor_switch_facts["serial_number"]
                          link["peer"] = neighbor_switch_facts["hostname"]
                          link["peer_interface"] = neighbor_link
                          link["peer_type"] = neighbor_switch_facts["type"]
                          link["peer_bgp_as"] = neighbor_switch_facts.get("bgp_as")
                          link["type"] = neighbor_link_info["type"]
                          link["ip_address"] = neighbor_link_info.get("peer_ip_address")
                          link["peer_ip_address"] = neighbor_link_info.get("ip_address")
                          link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                          link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                          link["channel_description"] = neighbor_link_info.get("peer_channel_description")
                          link["pim_enabled"] = neighbor_link_info.get("pim_enabled")
                          interface = neighbor_link_info["peer_interface"]
                          underlay_data["links"][interface] = link

              # Set Ethernet interfaces
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_p2p":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "P2P_LINK_TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "type": "routed",
                          "shutdown": False,
                          "ip_address": "{}/{}".format(link["ip_address"], switch_facts["uplink_ipv4_subnet_mask"])
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["ethernet_interfaces"][iface]["ospf_network_point_to_point"] = True
                          config["ethernet_interfaces"][iface]["ospf_area"] = switch_facts["underlay_ospf_area"]
                      if link.get("pim_enabled"):
                          config["ethernet_interfaces"][iface]["pim"] = {
                              "ipv4": {"sparse_mode": True}
                          }
                  elif link["type"] == "underlay_l2":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "type": "routed",
                          "shutdown": False
                      }
                      if switch_facts.get("boot_vlan"):
                          config["ethernet_interfaces"][iface]["boot_vlan"] = switch_facts["boot_vlan"]
                          
                      if link.get("channel_group_id"):
                          config["ethernet_interfaces"][iface]["channel_group"] = {
                              "id": link["channel_group_id"],
                              "mode": "active"
                          }

              # Set Port-Channel interfaces
              port_channel_list = []
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_l2" and \
                     link.get("channel_group_id") and \
                     link.get("channel_group_id") not in port_channel_list:
                      port_channel_list.append(link["channel_group_id"])
                      config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])] = {
                          "description": "{}_Po{}".format(link["peer"].upper(), link.get("peer_channel_group_id")),
                          "type": "switched",
                          "shutdown": False,
                          "mode": "trunk",
                          "mlag": link["channel_group_id"]
                      }
              # L2 and L3
              if switch_facts["network_services"]["l2"] == True and \
                  switch_facts["network_services"]["l3"] == True:
                  # set viritual router mac address
                  config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"]

              # Routing
              if switch_facts["underlay_router"] == True:
                  # Set loopback interfaces
                  if switch_facts.get("router_id"):
                      config["loopback_interfaces"]["Loopback0"] = {
                          "description": "ROUTER_ID",
                          "shutdown": False,
                          "ip_address": "{}/32".format(switch_facts["router_id"]),
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"]["Loopback0"]["ospf_area"] = switch_facts["underlay_ospf_area"]
                  if switch_facts["vtep"] == True:
                      config["loopback_interfaces"][switch_facts["vtep_loopback"]] = {
                         "description": "VTEP_VXLAN_Tunnel_Source",
                         "shutdown": False,
                         "ip_address": "{}/32".format(switch_facts["vtep_ip"])
                      }
                      if switch_facts.get("vtep_vvtep_ip") and switch_facts.get("evpn_services_l2_only") is not None and \
                          switch_facts.get("evpn_services_l2_only") == False:
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]] = [switch_facts["vtep_vvtep_ip"] ]
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]]["ospf_area"] = switch_facts["underlay_ospf_area"]
                  
                  # Set bgp if necessary
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "type": "ipv4",
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"] is not None:
                          config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] \
                              ["password"] = fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"]
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "activate": True,
                      }
                      config["router_bgp"]["redistribute_routes"]["connected"] = {
                          "route_map": "RM-CONN-2-BGP"
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_bgp"]["neighbors"][link["peer_ip_address"]] = {
                                  "peer_group": fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"],
                                  "remote_as": link["peer_bgp_as"],
                                  "description": "{}_{}".format(link["peer"], link["peer_interface"])
                              }
                      # Create prefix lists
                      config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"] = {
                          "sequence_numbers": {
                              10: {
                                  "action": "permit {} eq 32".format(switch_facts["loopback_ipv4_pool"])
                              }
                          }
                      }
                      if switch_facts.get("vtep_ip") is not None:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][20] = {
                              "action": "permit {} eq 32".format(switch_facts["vtep_loopback_ipv4_pool"])
                          }
                      if switch_facts.get("vtep_vvtep_ip") is not None \
                         and switch_facts.get("evpn_services_l2_only") is not None \
                         and switch_facts.get("evpn_services_l2_only") == False:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][30] = {
                              "action": "permit {}".format(switch_facts["vtep_vvtep_ip"])
                          }
                      # Create route-maps
                      config["route_maps"]["RM-CONN-2-BGP"] = {
                          "sequence_numbers": {
                              10: {
                                  "type": "permit",
                                  "match": ["ip address prefix-list PL-LOOPBACKS-EVPN-OVERLAY"]
                              }
                          }
                      }
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      config["router_ospf"]["process_ids"] = {
                          switch_facts["underlay_ospf_process_id"]: {
                              "passive_interface_default": True,
                              "router_id": switch_facts["router_id"],
                              "no_passive_interfaces": [],
                              "max_lsa": switch_facts["underlay_ospf_max_lsa"],
                              "ospf_defaults": switch_facts["ospf_defaults"]
                          }
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append(iface)
                      if switch_facts.get("mlag_l3") is not None and switch_facts.get("mlag_l3") == True:
                          config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append("Vlan{}".format(switch_facts["mlag_peer_l3_vlan"]))
                      if switch_facts["underlay_ospf_bfd_enable"] == True:
                          config["bfd_enable"] = True

              return config

          def set_overlay_config(config, switch_facts):
              if not switch_facts.get("underlay_router"):
                  return config
              if switch_facts["overlay_routing_protocol"] != "bgp":
                  return config

              overlay_data = {}
              # Set evpn route servers
              overlay_data["evpn_route_servers"] = {}
              for rs_id in switch_facts["evpn_route_server_ids"]:
                  rs_switch_facts = switches_in_my_campus[rs_id]
                  if rs_switch_facts["evpn_role"] == "server":
                      server = {
                          "bgp_as": rs_switch_facts["bgp_as"],
                          "ip_address": rs_switch_facts["router_id"]
                      }
                      overlay_data["evpn_route_servers"][rs_switch_facts["hostname"]] = server

              # Set evpn route clients
              overlay_data["evpn_route_clients"] = {}
              if switch_facts["evpn_role"] == "server":
                  for campus_switch_facts in switches_in_my_campus.values():
                      if campus_switch_facts["evpn_role"] is not None and campus_switch_facts["evpn_role"] == "client":
                          if switch_facts['serial_number'] in campus_switch_facts["evpn_route_server_ids"]:
                              client = {
                                  "bgp_as": campus_switch_facts["bgp_as"],
                                  "ip_address": campus_switch_facts["router_id"]
                              }
                              overlay_data["evpn_route_clients"][campus_switch_facts["hostname"]] = client

              
              # Set ebgp
              config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "type": "evpn",
                  "update_source": "Loopback0",
                  "bfd": True,
                  "ebgp_multihop": str(fabric_variables["evpn_ebgp_multihop"]),
                  "send_community": "all",
                  "maximum_routes": 0,
              }
              if switch_facts["evpn_role"] == "server":
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["next_hop_unchanged"] = True
              if fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"] is not None:
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["password"] = fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"]
              config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": False
              }
              config["router_bgp"]["address_family_evpn"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": True
              }
              if switch_facts.get("vtep_ip") and fabric_variables["evpn_hostflap_detection"]["enabled"] == True:
                  config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"] = {
                      "window": fabric_variables["evpn_hostflap_detection"]["window"],
                      "threshold": fabric_variables["evpn_hostflap_detection"]["threshold"],
                      "enabled": fabric_variables["evpn_hostflap_detection"]["enabled"]
                  }
              # Overlay network peering
              for rs, info in overlay_data["evpn_route_servers"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": rs,
                      "remote_as": info["bgp_as"]
                  }
              for cs, info in overlay_data["evpn_route_clients"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": cs,
                      "remote_as": info["bgp_as"]
                  }
              return config

          def set_vxlan_config(config, switch_facts):
              if switch_facts.get("vtep") == True:
                  config["vxlan_interface"] = {
                      "Vxlan1": {
                          "description": "{}_VTEP".format(switch_facts["hostname"]),
                          "vxlan": {
                              "source_interface": switch_facts["vtep_loopback"],
                              "udp_port": 4789
                          }
                      }
                  }
                  if switch_facts.get("mlag"):
                      config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] = "mlag-system-id"
              return config

          # Get studio info from ctx
          my_device = ctx.getDevice()
          workspace_id = ctx.studio.workspaceId

          # Initialize variables
          my_switch_facts = {}
          my_config = {}

          # Get basic switch facts for my_switch
          my_switch_facts = get_switch_basics(my_device.id, campus)

          if my_switch_facts is not None:
              # Get basic switch facts for all switches in the same campus as my_switch
              switches_in_my_campus = get_switches_in_my_campus_basics(my_switch_facts)

              # Set asn from studio input (needs to be set for leaf domain level first so reserved asns can be taken out of pool)
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = set_bgp_as_from_studio_input(switch_facts, campus)

              # Set all switch facts
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = set_switch_facts(switch_facts, campus)

              # Get topology facts ( in order to set transit p2p and port-channel links )
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = set_topology_facts(switch_facts)

              # Reset my_switch_facts
              my_switch_facts = switches_in_my_campus[my_device.id]

              # Set structured config
              my_config = {
                  "spanning_tree": {},
                  "vlans": {},
                  "vlan_interfaces": {},
                  "port_channel_interfaces": {},
                  "ethernet_interfaces": {},
                  "loopback_interfaces": {},
                  "prefix_lists": {},
                  "route_maps": {},
                  ## "router_bfd": {},
                  "router_bgp": {
                      "peer_groups": {},
                      "address_family_ipv4": {
                          "peer_groups": {}
                      },
                      "address_family_evpn": {
                          "peer_groups": {}
                      },
                      "neighbor_interfaces": {},
                      "neighbors": {},
                      "redistribute_routes": {
                          "connected": {}
                      }
                  },
                  "router_ospf": {
                      "process_ids": {}
                  }
              }

              update_tags(my_switch_facts)
              my_config = set_base_config(my_config, my_switch_facts)
              my_config = set_mlag_config(my_config, my_switch_facts)
              my_config = set_underlay_config(my_config, my_switch_facts)
              my_config = set_overlay_config(my_config, my_switch_facts)
              my_config = set_vxlan_config(my_config, my_switch_facts)

          config = my_config
          %>
          ## ${json.dumps(my_switch_facts, indent=2)}
          ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          ## ${json.dumps(config, indent=2)}
          ## !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
          ## eos - routing model
          % if config.get("service_routing_protocols_model") is not None and config.get("service_routing_protocols_model") == "multi-agent":
          service routing protocols model multi-agent
          !
          % endif
          ## eos - spanning-tree
          % if config.get("spanning_tree") is not None:
          %     if config["spanning_tree"].get("mode") is not None:
          spanning-tree mode ${ config["spanning_tree"].get("mode") }
          %     endif
          %     if config["spanning_tree"].get("no_spanning_tree_vlan") is not None:
          no spanning-tree vlan-id ${ config["spanning_tree"].get("no_spanning_tree_vlan") }
          %     endif
          !
          % endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
          name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
          state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
          trunk group ${ trunk_group }
          %               endfor
          %          endif
          !   
          %    endfor %}
          %endif
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
          description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
          shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
          mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
          no switchport
          %     else:
          switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
          switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
          switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
          switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mlag"):
          mlag ${ config["port_channel_interfaces"][port_channel_interface]["mlag"] }
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface]["description"] is not None:
          description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("boot_vlan"):
          lldp tlv transmit ztp vlan ${config["ethernet_interfaces"][ethernet_interface]["boot_vlan"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
          channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
          mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
          no switchport
          %         else:
          switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
          switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
          switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
          switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
          vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
          ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
          description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
          shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
          no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
          vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
          ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          %     if config["loopback_interfaces"][loopback_interface].get("ospf_area"):
             ip ospf area ${ config["loopback_interfaces"][loopback_interface]["ospf_area"] }
          %     endif
          !
          %   endfor
          %endif
          ## eos - VLAN Interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
          description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
          shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
          mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
          no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None:
          vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
          ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") is not None:
          ip virtual-router address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_virtual_router_address") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
          ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
          ${ ip_helper_cli }
          %       endfor
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_area"):
             ip ospf area ${ config.get("vlan_interfaces")[vlan_interface]["ospf_area"] }
          %      endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
          vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("source_interface"):
          vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["source_interface"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
          vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
          vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
          vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - tcam profile
          % if config.get("tcam_profile") is not None:
          hardware tcam
          %     if config["tcam_profile"].get("profiles") is not None:
          %         for profile in config["tcam_profile"]["profiles"].keys():
          profile ${ profile }
          ${ config["tcam_profile"]["profiles"][profile] }
          !
          %         endfor
          %     endif
          %     if config["tcam_profile"].get("system") is not None:
          system profile ${ config["tcam_profile"]["system"] }
          %     endif
          !
          % endif
          ## eos - ip virtual router mac
          % if config.get("ip_virtual_router_mac_address") is not None:
          ip virtual-router mac-address ${ config["ip_virtual_router_mac_address"] }
          !
          % endif
          ## eos - IP Routing 
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          ## eos - Router Multicast
          % if config.get("router_multicast"):
          router multicast
          %     if config["router_multicast"].get("ipv4"):
             ipv4
          %         if config["router_multicast"]["ipv4"].get("routing"):
                routing
          %         endif
          %         if config["router_multicast"]["ipv4"].get("multipath"):
                multipath ${ config["router_multicast"]["ipv4"]["multipath"] }
          %         endif
          %         if config["router_multicast"]["ipv4"].get("software_forwarding"):
                software-forwarding ${ config["router_multicast"]["ipv4"]["software_forwarding"] }
          %         endif
          %     endif
          !
          % endif
          ## eos - VRFs
          % if config.get("vrfs") is not None:
          %   for vrf in config.get("vrfs"):
          %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## eos - prefix-lists
          % if config.get("prefix_lists") is not None:
          %    for prefix_list in config["prefix_lists"].keys():
          ip prefix-list ${ prefix_list }
          %       for sequence in config["prefix_lists"][prefix_list]["sequence_numbers"].keys():
          %         if config["prefix_lists"][prefix_list]["sequence_numbers"][sequence].get("action") is not None:
          seq ${ sequence } ${ config["prefix_lists"][prefix_list]["sequence_numbers"][sequence]["action"] }
          %         endif
          %       endfor
          !
          %    endfor
          % endif
          ## eos - mlag configuration
          % if config.get("mlag_configuration") is not None and config["mlag_configuration"].get("enabled") == True:
          mlag configuration
          %     if config["mlag_configuration"].get("domain_id") is not None:
          domain-id ${ config["mlag_configuration"]["domain_id"] }
          %     endif
          %     if config["mlag_configuration"].get("local_interface") is not None:
          local-interface ${ config["mlag_configuration"]["local_interface"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address") is not None:
          peer-address ${ config["mlag_configuration"]["peer_address"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address_heartbeat") is not None:
          %       if config["mlag_configuration"]["peer_address_heartbeat"].get("peer_ip") is not None:
          %           if config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") is not None and config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") != 'default':
          peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] } vrf ${ config["mlag_configuration"]["peer_address_heartbeat"]["vrf"] }
          ## using the default VRF #}
          %           else:
          peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] }
          %           endif
          %       endif
          %     endif
          %     if config["mlag_configuration"].get("peer_link") is not None:
          peer-link ${ config["mlag_configuration"]["peer_link"] }
          %     endif
          %     if config["mlag_configuration"].get("dual_primary_detection_delay") is not None:
          dual-primary detection delay ${ config["mlag_configuration"]["dual_primary_detection_delay"] } action errdisable all-interfaces
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_mlag") is not None:
          reload-delay mlag ${ config["mlag_configuration"]["reload_delay_mlag"] }
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_non_mlag") is not None:
          reload-delay non-mlag ${ config["mlag_configuration"]["reload_delay_non_mlag"] }
          %     endif
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in config["route_maps"].keys():
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
          description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
          match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
          set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## eos - peer-filters
          % if config.get("peer_filters") is not None:
          %   for peer_filter in config["peer_filters"].keys():
          peer-filter ${ peer_filter }
          %     for sequence in config["peer_filters"][peer_filter]["sequence_numbers"].keys():
          %         if config["peer_filters"][peer_filter]["sequence_numbers"][sequence].get("match") is not None:
          ${ sequence } match ${ config["peer_filters"][peer_filter]["sequence_numbers"][sequence]["match"] }
          %         endif
          %     endfor
          !
          %   endfor
          % endif
          ## eos - Router bfd
          % if config.get("router_bfd") is not None and config.get("router_bfd") != {}:
          router bfd
          %   if config["router_bfd"].get("multihop") is not None:
          %     if config["router_bfd"]["multihop"].get("interval") is not None and config["router_bfd"]["multihop"].get("min_rx") is not None and config["router_bfd"]["multihop"].get("multiplier") is not None:
          multihop interval ${ config["router_bfd"]["multihop"]["interval"] } min-rx ${ config["router_bfd"]["multihop"]["min_rx"] } multiplier ${ config["router_bfd"]["multihop"]["multiplier"] }
          %     endif
          %   endif
          !
          % endif
          ## eos - Router BGP
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
          router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("maximum_paths"):
          <% max_paths_cli = "maximum-paths {} ".format(config["router_bgp"]["maximum_paths"]) %>
          %        if config["router_bgp"].get("ecmp"):
          <% max_paths_cli += "ecmp {}".format(config["router_bgp"]["ecmp"]) %>
                  % endif
          ${max_paths_cli}
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
          ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
          bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
          neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
          neighbor ${ peer_group } shutdown
          %         endif
          neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
          neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
          neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
          neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
          neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
          neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
          neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
          neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
          neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
          neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
          neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
          neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
          neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
          neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in natural_sort(config["router_bgp"]["neighbors"].keys()):
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
          neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
          neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
          neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
          neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
          neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
          neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
          neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
          neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
          neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
          neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
          neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
          ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
          vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].rd is not None:
              rd ${ config["router_bgp"]["vlans"][vlan].rd }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
          !
          vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
              rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
              vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
          !
          address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
              no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
              host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
              host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
              domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
          !
          address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
              neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
              no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
          !
          vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
              rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
              route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
              route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
              router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
              timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
              neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
              neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
              neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
              neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
              neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
              ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
              neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
              neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
              neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
              neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
              neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
              neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
              ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
              ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                  neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                  ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
          ## router-ospf
          %if config.get("router_ospf") and config["router_ospf"].get("process_ids"):
          %for process_id in config["router_ospf"]["process_ids"].keys():
          %     if config["router_ospf"]["process_ids"][process_id].get("vrf"):
          router ospf ${ process_id } vrf ${ config["router_ospf"]["process_ids"][process_id]["vrf"] }
          %     else:
          router ospf ${ process_id }
          %     endif
          %     if config["router_ospf"]["process_ids"].get("log_adjacency_changes_detail"):
             log-adjacency-changes detail
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("router_id"):
             router-id ${ config["router_ospf"]["process_ids"][process_id]["router_id"] }
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("passive_interface_default"):
             passive-interface default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("no_passive_interfaces"):
          %         for interface in config["router_ospf"]["process_ids"][process_id]["no_passive_interfaces"]:
             no passive-interface ${ interface }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("network_prefixes"):
          %         for network_prefix in natural_sort(config["router_ospf"]["process_ids"][process_id]["network_prefixes"].keys()):
             network ${ network_prefix } area ${ config["router_ospf"]["process_ids"][process_id]["network_prefixes"][network_prefix]["area"] }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("bfd_enable"):
             bfd default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("ospf_defaults"):
          %         for ospf_default in config["router_ospf"]["process_ids"][process_id]["ospf_defaults"]:
             ${ospf_default}
          %         endfor
          %     endif
          !
          %endfor
          %endif
      input_schema:
        fields:
          values:
            vxlanOverlay:
              id: vxlanOverlay
              name: vxlanOverlay
              label: VXLAN Overlay
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vtepAddressRange:
              id: vtepAddressRange
              name: vtepAddressRange
              label: VTEP Address Range
              description: Define a subnet in CIDR notation from which to allocate VXLAN tunnel source IP addresses. These IP addresses will be assigned to the leaf switch's Loopback1 interface
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 172.16.1.0/24
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            overlayDetails:
              id: overlayDetails
              name: overlayDetails
              label: Overlay Details
              description: Configure the VXLAN overlay settings for this Pod.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vxlanOverlay
                    - vtepAddressRange
            mlagPeerLinkSubnet:
              id: mlagPeerLinkSubnet
              name: mlagPeerLinkSubnet
              label: MLAG Peer Link Subnet
              description: Define the subnet from which to allocate IP addresses for the MLAG source interfaces.  By setting a subnet with a subnet mask of 30 or 31, you will re-use the same IP addresses for MLAG source interfaces across all leaf MLAG pairs in your network. To use unique IP addresses for every MLAG source interface, enter a subnet with a subnet mask less than 30
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 169.254.0.0/24
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mlagPeerLinkVlan:
              id: mlagPeerLinkVlan
              name: mlagPeerLinkVlan
              label: MLAG Peer Link VLAN
              description: Define the VLAN ID to use for MLAG peer communication
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            mlagPortChannelId:
              id: mlagPortChannelId
              name: mlagPortChannelId
              label: MLAG Port-Channel ID
              description: Define the Port-Channel ID to use for MLAG peer communication
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '2000'
                range: null
                static_options: null
                dynamic_options: null
            mlagSubnetMask:
              id: mlagSubnetMask
              name: mlagSubnetMask
              label: MLAG Subnet Mask
              description: Set the subnet mask for the MLAG interface connections in the fabric
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            virtualRouterMacAddress:
              id: virtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Assign a virtual MAC address for redundant host and switch connections
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            lacpMode:
              id: lacpMode
              name: lacpMode
              label: LACP Mode
              description: Define the LACP mode used for member interfaces of the MLAG peer link port channel
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: active
                static_options:
                  values:
                    - active
                    - passive
                    - on (static)
                format: null
                length: null
                pattern: null
                dynamic_options: null
            mlagConfiguration:
              id: mlagConfiguration
              name: mlagConfiguration
              label: MLAG Configuration
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - mlagPeerLinkSubnet
                    - mlagPeerLinkVlan
                    - mlagPortChannelId
                    - mlagSubnetMask
                    - virtualRouterMacAddress
                    - lacpMode
            spanningTreeMode:
              id: spanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - MSTP
                    - Rapid-PVST
                    - RSTP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            uplinkType:
              id: uplinkType
              name: uplinkType
              label: Uplink Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - p2p
                    - port-channel
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodUnderlayRoutingProtocol:
              id: campusPodUnderlayRoutingProtocol
              name: underlayRoutingProtocol
              label: Underlay Routing Protocol
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - bgp
                    - ospf
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpAsRange:
              id: campusPodBgpAsRange
              name: bgpAsRange
              label: BGP AS Range
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodRouterIdPool:
              id: campusPodRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaultsConfigStatement:
              id: campusPodBgpDefaultsConfigStatement
              name: campusPodBgpDefaultsConfigStatement
              label: Config Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaults:
              id: campusPodBgpDefaults
              name: campusPodDefaults
              label: BGP Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodBgpDefaultsConfigStatement
                key: ''
            campusPodUplinkIpv4Pool:
              id: campusPodUplinkIpv4Pool
              name: uplinkIpv4Pool
              label: Uplink Ipv4 Pool
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodDetails:
              id: campusPodDetails
              name: campusPodDetails
              label: Campus Pod Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - uplinkType
                    - campusPodUnderlayRoutingProtocol
                    - campusPodBgpAsRange
                    - campusPodRouterIdPool
                    - campusPodBgpDefaults
                    - campusPodUplinkIpv4Pool
            splineBgpAs:
              id: splineBgpAs
              name: splineBgpAs
              label: BGP AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            splineUnderlayRoutingProtocol:
              id: splineUnderlayRoutingProtocol
              name: underlayRoutingProtocol
              label: Underlay Routing Protocol
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - bgp
                    - ospf
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineRouterIdPool:
              id: splineRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaultsConfigStatement:
              id: splineBgpDefaultsConfigStatement
              name: splineBgpDefaultsConfigStatement
              label: Config Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaults:
              id: splineBgpDefaults
              name: splineDefaults
              label: BGP Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineBgpDefaultsConfigStatement
                key: ''
            splineVtepKnob:
              id: splineVtepKnob
              name: vtep
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            splineDefaults:
              id: splineDefaults
              name: splineDefaults
              label: Spline Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineBgpAs
                    - splineUnderlayRoutingProtocol
                    - splineRouterIdPool
                    - splineBgpDefaults
                    - splineVtepKnob
            ospfProcessId:
              id: ospfProcessId
              name: processId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '100'
                range: null
                static_options: null
                dynamic_options: null
            ospfArea:
              id: ospfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            ospfMaxLsa:
              id: ospfMaxLsa
              name: maxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '12000'
                range: null
                static_options: null
                dynamic_options: null
            ospfBfdKnob:
              id: ospfBfdKnob
              name: bfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            ospfConfiguration:
              id: ospfConfiguration
              name: ospfConfiguration
              label: OSPF Configuration
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ospfProcessId
                    - ospfArea
                    - ospfMaxLsa
                    - ospfBfdKnob
            # inbandManagementVlanId:
            #   id: inbandManagementVlanId
            #   name: vlanId
            #   label: VLAN ID
            #   description: ''
            #   required: false
            #   type: INPUT_FIELD_TYPE_INTEGER
            #   integer_props:
            #     default_value: null
            #     range: null
            #     static_options: null
            #     dynamic_options: null
            # inbandManagementSubnet:
            #   id: inbandManagementSubnet
            #   name: managementSubnet
            #   label: Management Subnet
            #   description: ''
            #   required: false
            #   type: INPUT_FIELD_TYPE_STRING
            #   string_props:
            #     default_value: null
            #     static_options: null
            #     format: null
            #     length: null
            #     pattern: null
            #     dynamic_options: null
            # inbandManagementGateway:
            #   id: inbandManagementGateway
            #   name: managementGateway
            #   label: Management Gateway
            #   description: ''
            #   required: false
            #   type: INPUT_FIELD_TYPE_STRING
            #   string_props:
            #     default_value: null
            #     static_options: null
            #     format: null
            #     length: null
            #     pattern: null
            #     dynamic_options: null
            # inbandManagement:
            #   id: inbandManagement
            #   name: inbandManagement
            #   label: Inband Management
            #   description: ''
            #   required: false
            #   type: INPUT_FIELD_TYPE_GROUP
            #   group_props:
            #     members:
            #       values:
            #         - inbandManagementVlanId
            #         - inbandManagementSubnet
            #         - inbandManagementGateway
            multicastKnob:
              id: multicastKnob
              name: multicast
              label: Multicast
              description: Enables PIM IPv4 sparse-mode on transit interfaces.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            leafBgpAS:
              id: leafBgpAS
              name: leafBgpAs
              label: BGP AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            leafBgpConfiguration:
              id: leafBgpConfiguration
              name: leafBgpConfiguration
              label: BGP Configuration
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafBgpAS
            campusPodFacts:
              id: campusPodFacts
              name: campusPodFacts
              label: Campus Pod Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafBgpConfiguration
            campusPodResolver:
              id: campusPodResolver
              name: campusPods
              label: Campus Pods
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusPodFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            siteFacts:
              id: siteFacts
              name: siteFacts
              label: Site Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - overlayDetails
                    - mlagConfiguration
                    - spanningTreeMode
                    - campusPodDetails
                    - splineDefaults
                    - ospfConfiguration
                    - inbandManagement
                    - multicastKnob
                    - campusPodResolver
            siteResolver:
              id: siteResolver
              name: site
              label: Site
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: siteFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            campusDetails:
              id: campusDetails
              name: campusDetails
              label: Campus Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - siteResolver
            campus:
              id: campus
              name: campus
              label: Campus
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campus
        layout:
          value: |
            {
                "siteFacts":{
                    "key":"siteFacts",
                    "type":"INPUT",
                    "order":[
                        "splineDefaults",
                        "splineTagger",
                        "campusPodDetails",
                        "campusPodResolver",
                        "overlayDetails",
                        "spanningTreeMode",
                        "mlagConfiguration",
                        "ospfConfiguration",
                        "inbandManagement",
                        "multicastKnob"
                    ]
                },
                "fabricSubnet":{
                    "key":"fabricSubnet",
                    "type":"INPUT",
                    "dependency":{
                        "fabricType":{
                            "value":[
                                "L3"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "fabricChildSubnetsMask":{
                    "key":"fabricChildSubnetsMask",
                    "type":"INPUT",
                    "dependency":{
                        "fabricType":{
                            "value":[
                                "L3"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "vxlanOverlay":{
                    "key":"vxlanOverlay",
                    "type":"INPUT",
                    "dependency":{
                        "fabricType":{
                            "value":[
                                "L3"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "vtepAddressRange":{
                    "key":"vtepAddressRange",
                    "type":"INPUT",
                    "dependency":{
                        "vxlanOverlay":{
                            "value":[
                                true
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "leafBgpAS":{
                    "key":"leafBgpAS",
                    "dependency":{
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "bgp"
                            ],
                            "mode":"SHOW"
                        }
                    },
                    "type":"INPUT"
                },
                "campusPodFacts":{
                    "key":"campusPodFacts",
                    "type":"INPUT",
                    "order":[
                        "leafTagger",
                        "memberLeafTagger",
                        "leafBgpConfiguration"
                    ]
                },
                "campusPodBgpDefaultsConfigStatement":{
                    "key":"campusPodBgpDefaultsConfigStatement",
                    "dependency":{
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "bgp"
                            ],
                            "mode":"SHOW"
                        }
                    },
                    "type":"INPUT"
                },
                "campusPodDetails":{
                    "key":"campusPodDetails",
                    "type":"INPUT",
                    "order":[
                        "uplinkType",
                        "campusPodUnderlayRoutingProtocol",
                        "campusPodUplinkIpv4Pool",
                        "campusPodRouterIdPool",
                        "campusPodBgpAsRange",
                        "campusPodBgpDefaults"
                    ]
                },
                "splineDefaults":{
                    "key":"splineDefaults",
                    "type":"INPUT",
                    "order":[
                        "splineUnderlayRoutingProtocol",
                        "splineRouterIdPool",
                        "splineBgpAs",
                        "splineBgpDefaults",
                        "splineVtepKnob"
                    ]
                },
                "campusPodUnderlayRoutingProtocol":{
                    "key":"campusPodUnderlayRoutingProtocol",
                    "type":"INPUT",
                    "dependency":{
                        "uplinkType":{
                            "value":[
                                "p2p"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "campusPodRouterIdPool":{
                    "key":"campusPodRouterIdPool",
                    "type":"INPUT",
                    "dependency":{
                        "uplinkType":{
                            "value":[
                                "p2p"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "campusPodBgpAsRange":{
                    "key":"campusPodBgpAsRange",
                    "type":"INPUT",
                    "dependency":{
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "bgp"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "splineBgpAs":{
                    "key":"splineBgpAs",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "bgp"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "splineBgpDefaultsConfigStatement":{
                    "key":"splineBgpDefaultsConfigStatement",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "bgp"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "ospfProcessId":{
                    "key":"ospfProcessId",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        },
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "ospfArea":{
                    "key":"ospfArea",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        },
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "ospfMaxLsa":{
                    "key":"ospfMaxLsa",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        },
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "ospfBfdKnob":{
                    "key":"ospfBfdKnob",
                    "type":"INPUT",
                    "dependency":{
                        "splineUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        },
                        "campusPodUnderlayRoutingProtocol":{
                            "value":[
                                "ospf"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "campusPodUplinkIpv4Pool":{
                    "key":"campusPodUplinkIpv4Pool",
                    "type":"INPUT",
                    "dependency":{
                        "uplinkType":{
                            "value":[
                                "p2p"
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "splineVtepKnob":{
                    "key":"splineVtepKnob",
                    "type":"INPUT",
                    "dependency":{
                        "vxlanOverlay":{
                            "value":[
                                true
                            ],
                            "mode":"SHOW"
                        }
                    }
                },
                "mlagConfiguration":{
                    "key":"mlagConfiguration",
                    "type":"INPUT",
                    "order":[
                        "mlagPeerLinkSubnet",
                        "mlagSubnetMask",
                        "mlagPeerLinkVlan",
                        "mlagPortChannelId",
                        "virtualRouterMacAddress",
                        "lacpMode"
                    ]
                },
                "splineTagger":{
                    "type":"TAGGER",
                    "parentKey":"siteFacts",
                    "key":"splineTagger",
                    "name":"Splines",
                    "assignmentType":"SINGLE",
                    "prepopulate":true,
                    "tagFilterQuery":"Role:Spline",
                    "tagType":"DEVICE",
                    "description":"Assign Spline Node ID",
                    "columns":[
                        {
                            "tagLabel":"node_id",
                            "suggestedValues":[
                                
                            ]
                        }
                    ]
                },
                "roleTagger":{
                    "type":"TAGGER",
                    "parentKey":"campusDetails",
                    "key":"roleTagger",
                    "name":"Role",
                    "assignmentType":"SINGLE",
                    "prepopulate":true,
                    "tagType":"DEVICE",
                    "description":"Assign a role to each switch in this campus.",
                    "columns":[
                        {
                            "tagLabel":"Role",
                            "suggestedValues":[
                                "Spline",
                                "Leaf",
                                "Member-Leaf"
                            ]
                        }
                    ]
                },
                "campusDetails":{
                    "key":"campusDetails",
                    "type":"INPUT",
                    "order":[
                        "siteResolver",
                        "roleTagger"
                    ]
                },
                "leafTagger":{
                    "type":"TAGGER",
                    "parentKey":"campusPodFacts",
                    "key":"leafTagger",
                    "name":"Leafs",
                    "assignmentType":"SINGLE",
                    "prepopulate":true,
                    "tagFilterQuery":"Role:Leaf ",
                    "tagType":"DEVICE",
                    "description":"Assign Leaf Node ID",
                    "columns":[
                        {
                            "tagLabel":"node_id",
                            "suggestedValues":[
                                
                            ]
                        }
                    ]
                },
                "memberLeafTagger":{
                    "type":"TAGGER",
                    "parentKey":"campusPodFacts",
                    "key":"memberLeafTagger",
                    "name":"Member Leafs",
                    "assignmentType":"SINGLE",
                    "prepopulate":true,
                    "tagFilterQuery":"Role:Member-Leaf ",
                    "tagType":"DEVICE",
                    "description":"Assign Leaf Node ID",
                    "columns":[
                        {
                            "tagLabel":"node_id",
                            "suggestedValues":[
                                
                            ]
                        }
                    ]
                },
                "campusPodResolver":{
                    "key":"campusPodResolver",
                    "type":"INPUT",
                    "isPageLayout":true,
                    "showDefaultRow":false
                }
            }
