-
    service: arista.studio.v1.StudioConfigService
    method: Set
    body:
        value:
            key:
                studio_id: f5238432-9ff5-4428-b446-cc67fc6df3bc
                workspace_id: ""
            display_name: 'L3 Leaf-Spine Fabric (NO BFD)'
            description: 'Deploy and manage an Arista validated L3 leaf-spine fabric, including support for a multi-tenant BGP EVPN overlay.'
            template:
                type: TEMPLATE_TYPE_MAKO
                body: "<%\nimport sys, os, json, ipaddress, re\nfrom collections import OrderedDict\nimport tagsearch_python.tagsearch_pb2_grpc as tsgr\nimport tagsearch_python.tagsearch_pb2 as tspb\nfrom arista.tag.v2.services import TagServiceStub, TagAssignmentServiceStub, TagConfigServiceStub, TagAssignmentConfigServiceStub\nfrom arista.tag.v2.services.gen_pb2 import TagRequest, TagConfigSetRequest, TagStreamRequest, TagConfigStreamRequest, TagAssignmentStreamRequest, TagAssignmentConfigSetRequest, TagAssignmentConfigStreamRequest\nfrom arista.tag.v2.tag_pb2 import Tag, TagKey, TagAssignment, TagAssignmentKey, TagAssignmentConfig\n\nstudio_input_data = dataCenters.resolve()\nworkspace_id = ctx.studio.workspaceId\nmy_device = ctx.getDevice()\nmy_device_id = my_device.id\n\njericho_platform_regexes = [\n    r'7048T',\n    r'7280',\n    r'75\\d\\d',\n    r'780\\d'\n]\n\ndef convert(text):\n    return int(text) if text.isdigit() else text.lower()\n\ndef alphanum_key(key):\n    return [convert(c) for c in re.split('([0-9]+)', str(key))]\n\ndef natural_sort(iterable):\n    if iterable is None:\n        return list()\n    return sorted(iterable, key=alphanum_key)\n\ndef string_to_list(string_to_convert):\n    numbers = []\n    segments = [ segment.strip() for segment in string_to_convert.split(\",\") ]\n    for segment in segments:\n        if \"-\" in segment:\n            for i in range(int(segment.split(\"-\")[0]), int(segment.split(\"-\")[1]) + 1):\n                if i not in numbers:\n                    numbers.append(i)\n        else:\n            if i not in numbers:\n                numbers.append(int(segment))\n    return numbers\n\ndef get_tag_values_applied_to_device(tag_assignment_key):\n    label = tag_assignment_key.label.value\n    value = tag_assignment_key.value.value\n    device_id = tag_assignment_key.device_id.value\n    workspace_id = tag_assignment_key.workspace_id.value\n    #Create tagstub\n    tsclient = ctx.getApiClient(tsgr.TagSearchStub)\n\n    matching_tags = []\n\n    #Create TagValueSearchRequest\n    tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)\n    for tag in tsclient.GetTagValueSuggestions(tvsr).tags:\n        query= \"{}:\\\"{}\\\" AND device:{}\".format(tag.label, tag.value, device_id)\n        tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)\n        tagmresp =  tsclient.GetTagMatchesV2(tagmr)\n        for match in tagmresp.matches:\n            if match.device.device_id == device_id:\n                matching_tags.append(tag)\n\n    return matching_tags\n\ndef create_tag(tag_key):\n    '''\n    tag_key is a TagKey\n    '''\n    tcsr = TagConfigSetRequest()\n    tcsr.value.key.workspace_id.value = tag_key.workspace_id.value\n    tcsr.value.key.element_type = tag_key.element_type\n    tcsr.value.key.label.value = tag_key.label.value\n    tcsr.value.key.value.value = tag_key.value.value\n    client = ctx.getApiClient(TagConfigServiceStub)\n    client.Set(tcsr)\n\ndef apply_tag(tag_assignment_key):\n    '''\n    tag_assignment_key is a TagAssignmentKey\n    '''\n    tacsr = TagAssignmentConfigSetRequest()\n    tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value\n    tacsr.value.key.element_type = tag_assignment_key.element_type\n    tacsr.value.key.label.value = tag_assignment_key.label.value\n    tacsr.value.key.value.value = tag_assignment_key.value.value\n    tacsr.value.key.device_id.value = tag_assignment_key.device_id.value\n    tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value\n    tacsr.value.remove.value = False\n    client = ctx.getApiClient(TagAssignmentConfigServiceStub)\n    client.Set(tacsr)\n\ndef remove_tag(tag_assignment_key):\n    '''\n    tag_assignment_key is a TagAssignmentKey\n    '''\n    tacsr = TagAssignmentConfigSetRequest()\n    tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value\n    tacsr.value.key.element_type = tag_assignment_key.element_type\n    tacsr.value.key.label.value = tag_assignment_key.label.value\n    tacsr.value.key.value.value = tag_assignment_key.value.value\n    tacsr.value.key.device_id.value = tag_assignment_key.device_id.value\n    tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value\n    tacsr.value.remove.value = True\n    client = ctx.getApiClient(TagAssignmentConfigServiceStub)\n    client.Set(tacsr)\n\nclass Pod:\n    def __init__(self):\n        self.id = None\n        self.dc = None\n        self.underlay_routing_protocol = \"bgp\" #< BGP or OSPF* or ISIS* | Default -> BGP >\n        self.overlay_routing_protocol = \"bgp\" #<EBGP or IBGP | default -> EBGP >\n        self.p2p_uplinks_mtu = 9214 #< 0-9214 | default -> 9214 >\n        self.underlay_p2p_network_summaries = [] # IP Summary subnets for Point to Point interfaces between L3 leafs and spines/superspines used for underlay peering | Required\n        self.underlay_p2p_subnet_mask = 31  # 30 or 31 | Default -> 31\n        self.max_spines = None\n        self.overlay_loopback_network_summary_super_spines = None # IP address summary for BGP evpn overlay peering loopback for supeer spines\n        self.overlay_loopback_network_summary_spines = None # IP address summary for BGP evpn overlay peering loopback for spines\n        self.overlay_loopback_network_summary_leafs = None # IP address summary for BGP evpn overlay peering loopback for L3 leafs  \n        self.vxlan_overlay = False\n        self.vtep_loopback_network_summary = None # IP address summary VTEP VXLAN Tunnel source loopback1 IP for L3 leafs | Required\n        self.vtep_vvtep_ip = None # IP Address used as Virtual VTEP. Will be configured as secondary IP on loopback1 | Optional\n        self.manually_allocated_leaf_asns = {}\n        self.mlag = {\n            \"mlag_ip_subnet\": None, # Subnet to pull mlag svi addresses from\n            \"mlag_subnet_mask\": 31, # 30 or 31 | Default -> 31\n            \"mlag_peer_link_id\": None, # port-channel interface used for MLAG peer link | Default -> \"Port-Channel2000\"\n            \"mlag_peer_vlan\": 4094, # VLAN used for MLAG control plane traffic | Default -> 4094\n            \"ip_virtual_router_mac_address\": \"00:1c:73:00:00:99\", # virtual router mac address | Default -> \"00:1c:73:00:00:99\"\n            \"mlag_vlan_name\": \"MLAG-PEER-VLAN\",\n            \"mlag_vlan_trunk_group_name\": \"MLAG-PEER\",\n            \"mlag_peer_link_description\": \"MLAG Peer Link\",\n            \"mlag_peer_link_member_iface_description\": \"MLAG peer link to {}:{}\",\n            \"mlag_domain_id\": \"MLAG\",\n            \"lacp_mode\": \"active\",\n            \"reload_delay_mlag\": 300,\n            \"reload_delay_non_mlag\": 330\n        }\n        self.bgp = {\n            \"super_spines_asn\": None,\n            \"spines_asn\": None,\n            \"leafs_asn_range\": None,\n            \"ecmp\": 4,  #< number_of_ecmp_paths | default -> 4 >\n            \"maximum_paths\": 4,  #< number_of_max_paths | default -> 4 >\n            \"peer_groups\": {\n                \"leaf\": {\n                    \"IPv4_UNDERLAY_PEERS\": {\n                        \"name\": \"IPv4_UNDERLAY_PEERS\",\n                        \"description\": \"ipv4 peering\",\n                        \"send_community\": \"all\",\n                        \"password\": None,\n                        ## \"bfd\": True,\n                        \"maximum_routes\": 12000\n                    },\n                    \"MLAG_IPv4_UNDERLAY_PEER\":{\n                        \"name\": \"MLAG_IPv4_UNDERLAY_PEER\",\n                        \"description\": \"ipv4 with mlag neighbor\",\n                        \"send_community\": \"all\",\n                        \"password\": None,\n                        \"next_hop_self\": True,\n                        ## \"bfd\": True,\n                        \"maximum_routes\": 12000\n                    },\n                    \"EVPN_OVERLAY_PEERS\": {\n                        \"name\": \"EVPN_OVERLAY_PEERS\",\n                        \"description\": \"evpn overlay peering\",\n                        \"update_source\": \"Loopback0\",\n                        \"send_community\": \"all\",\n                        ##\"bfd\": True,\n                        \"password\": None,\n                        \"ebgp_multihop\": 3, #< ebgp_multihop | default -> 3 >\n                        \"maximum_routes\": 0,\n                        \"maximum_routes_warning_limit\": 12000\n                    }\n                },\n                \"spine\": {\n                    \"IPv4_UNDERLAY_PEERS\": {\n                        \"name\": \"IPv4_UNDERLAY_PEERS\",\n                        \"description\": \"ipv4 peering\",\n                        \"send_community\": \"all\",\n                        \"password\": None,\n                        ## \"bfd\": True,\n                        \"maximum_routes\": 12000\n                    },\n                    \"EVPN_OVERLAY_PEERS\": {\n                        \"name\": \"EVPN_OVERLAY_PEERS\",\n                        \"description\": \"evpn overlay peering\",\n                        \"update_source\": \"Loopback0\",\n                        \"next_hop_unchanged\": True,\n                        \"send_community\": \"all\",\n                        ##\"bfd\": True,\n                        \"password\": None,\n                        \"ebgp_multihop\": 3, #< ebgp_multihop | default -> 3 >\n                        \"maximum_routes\": 0,\n                        \"maximum_routes_warning_limit\": 12000\n                    }\n                }\n            },\n            \"spine_defaults\": [\n                \"update wait-for-convergence\",\n                \"update wait-install\",\n                \"no bgp default ipv4-unicast\",\n                \"distance bgp 20 200 200\",\n                \"graceful-restart restart-time 300\",\n                \"graceful-restart\"\n            ],\n            \"leaf_defaults\": [\n                \"update wait-install\",\n                \"no bgp default ipv4-unicast\",\n                \"distance bgp 20 200 200\",\n                \"graceful-restart restart-time 300\",\n                \"graceful-restart\"\n            ],\n            \"dynamic_peering\": True,\n            \"evpn_enabled\": True\n        }\n        self.spanning_tree_mode = None\n        self.filters = {\n            \"route_maps\": {\n                \"connected_to_bgp\":{\n                    \"name\": \"RM-CONN-2-BGP\"\n                }\n            },\n            \"prefix_lists\": {\n                \"loopbacks\":{\n                    \"name\": \"PL_LOOPBACKS\"\n                },\n                \"transit\":{\n                    \"name\": \"PL_P2P_UNDERLAY\"\n                }\n            },\n            \"peer_filters\": {\n                \"bgp_range_accept\" : {\n                    \"name\": \"LEAF-AS-Range\"\n                }\n            }\n        }\n\ndef get_pod_details(studios_schema_input):\n    pod = Pod()\n    dc = studios_schema_input[\"dataCenter\"]\n    dcPods = dc[\"pods\"].resolve()\n    if dcPods is None or dcPods['pod'] is None:\n        return None\n    lacp_mode_mapper = {\n        \"active\": \"active\",\n        \"passive\": \"passive\",\n        \"on (static)\": \"on\"\n    }\n    pod.underlay_routing_protocol = dcPods[\"pod\"][\"underlayRouting\"][\"underlayRoutingProtocol\"].lower()\n    pod.overlay_routing_protocol = \"bgp\"\n    pod.underlay_p2p_network_summaries = [ subnet.strip() for subnet in dcPods[\"pod\"][\"underlayRouting\"][\"underlayFabricSubnet\"].split(\",\") ]\n    pod.underlay_p2p_subnet_mask = int(dcPods[\"pod\"][\"underlayRouting\"][\"underlayFabricSubnetMask\"])\n    try:\n        pod.max_spines = dcPods[\"pod\"][\"maximums\"][\"maxSpines\"]\n    except (KeyError, ValueError, TypeError):\n        pod.max_spines = None\n    pod.overlay_loopback_network_summary_spines = dcPods[\"pod\"][\"commonBGPConfig\"][\"spineLoopback0Subnet\"]\n    pod.overlay_loopback_network_summary_leafs = dcPods[\"pod\"][\"commonBGPConfig\"][\"leafLoopback0Subnet\"]\n    pod.vxlan_overlay = dcPods[\"pod\"][\"overlayDetails\"][\"vxlanOverlay\"]\n    pod.vtep_loopback_network_summary =  dcPods[\"pod\"][\"overlayDetails\"][\"leafLoopback1Subnet\"]\n    pod.vtep_vvtep_ip = dcPods[\"pod\"][\"overlayDetails\"][\"vVtepAddress\"] if dcPods[\"pod\"][\"overlayDetails\"][\"vVtepAddress\"].strip() != \"\" else None\n    pod.spanning_tree_mode = dcPods[\"pod\"][\"spanningTreeMode\"].lower()\n    pod.mlag[\"mlag_ip_subnet\"] = dcPods[\"pod\"][\"commonMlagConfig\"][\"mlagPeerLinkSubnet\"]\n    pod.mlag[\"mlag_subnet_mask\"] = int(dcPods[\"pod\"][\"commonMlagConfig\"][\"mlagSubnetMask\"])\n    pod.mlag[\"mlag_peer_link_id\"] = int(dcPods[\"pod\"][\"commonMlagConfig\"][\"mlagPortChannelId\"])\n    pod.mlag[\"mlag_peer_vlan\"] = int(dcPods[\"pod\"][\"commonMlagConfig\"][\"mlagVlan\"])\n    pod.mlag[\"lacp_mode\"] = lacp_mode_mapper[ dcPods[\"pod\"][\"commonMlagConfig\"][\"lacpMode\"] ]\n    pod.mlag[\"ip_virtual_router_mac_address\"] = dcPods[\"pod\"][\"commonMlagConfig\"][\"virtualRouterMacAddress\"]\n    pod.bgp[\"spines_asn\"] = dcPods[\"pod\"][\"commonBGPConfig\"][\"spineAsn\"]\n    pod.bgp[\"leafs_asn_range\"] = dcPods[\"pod\"][\"commonBGPConfig\"][\"leafAsnRange\"]\n    pod.bgp[\"dynamic_peering\"] = dcPods[\"pod\"][\"commonBGPConfig\"][\"spineBGPDynamicNeighbors\"]\n    pod.bgp[\"evpn_enabled\"] = dcPods[\"pod\"][\"commonBGPConfig\"][\"evpnEnabled\"]\n    return pod\n\nclass SwitchDetails:\n    def __init__(self):\n        self.id = None\n        self.model = None #Model tag\n        self.eos_version = None #Eos version tag\n        self.role= None #Role tag\n        self.hostname = None #hostname tag\n        self.dc = None #DC tag\n        self.dc_pod = None #DC-Pod tag\n        self.uplink_interfaces = {}\n        self.downlink_interfaces = {}\n        self.mlag_peer_link_interfaces = {}\n        self.config = {\n            \"ip_routing\": False,\n            \"service_routing_protocols_model\": None,\n            \"ip_virtual_router_mac_address\": None,\n            \"vlans\": {},\n            \"spanning_tree\":{\n                \"mode\": None,\n                \"no_spanning_tree_vlan\": None\n            },\n            \"ethernet_interfaces\": {},\n            \"port_channel_interfaces\": {},\n            \"loopback_interfaces\": {},\n            \"vlan_interfaces\": {},\n            \"vxlan_tunnel_interface\": None,\n            \"mlag_configuration\":{\n                \"enabled\": False,\n                \"domain_id\": None,\n                \"local_interace\": None,\n                \"peer_address\": None,\n                \"peer_link\": None,\n                \"reload_delay_mlag\": 300,\n                \"reload_delay_non_mlag\": 330\n            },\n            \"prefix_lists\": {},\n            \"route_maps\": {},\n            \"router_bgp\":{\n                \"as\": None,\n                \"router_id\": None,\n                \"ecmp\": None,\n                \"maximum_paths\": None,\n                \"bgp_defaults\": [],\n                \"peer_groups\": {},\n                \"neighbors\": {},\n                \"redistribute_routes\":{\n                    \"connected\": {\n\n                    }\n                }\n            }\n        }\n\n    def set_bgp_tags(self):\n        #Set ASN and Router_ID Tags\n        tag_labels = {\"router_bgp.as\": self.config[\"router_bgp\"][\"as\"], \"router_bgp.router_id\":self.config[\"router_bgp\"][\"router_id\"]}\n        for label, config_path in tag_labels.items():\n            #Create desired tag (will not create tag if it already exists):\n            tag_key = TagKey()\n            tag_key.workspace_id.value = workspace_id\n            tag_key.element_type = 1\n            tag_key.label.value = label\n            tag_key.value.value = str(config_path)\n            create_tag(tag_key)\n\n            #Apply desired tag\n            tag_assignment_key = TagAssignmentKey()\n            tag_assignment_key.workspace_id.value = workspace_id\n            tag_assignment_key.element_type = 1\n            tag_assignment_key.label.value = label\n            tag_assignment_key.value.value = str(config_path)\n            tag_assignment_key.device_id.value = self.id\n            apply_tag(tag_assignment_key)\n\n            #Remove other tags with same label that don't match proper value\n            tag_assignment_key = TagAssignmentKey()\n            tag_assignment_key.workspace_id.value = workspace_id\n            tag_assignment_key.element_type = 1\n            tag_assignment_key.label.value = label\n            tag_assignment_key.device_id.value =  self.id\n            applied_tags = get_tag_values_applied_to_device(tag_assignment_key)\n            for tag in applied_tags:\n                if tag.value != str(config_path):\n                    tag_assignment_key.value.value = tag.value\n                    remove_tag(tag_assignment_key)\n\n    def get_highest_role_number(self, role):\n        '''\n        role ( str ) -> Options are ether \"Leaf\", \"Spine\", or \"Super-Spine\"\n\n        Returns ( int ) -> Highest role index number within dc or pod\n        '''\n        role_to_attr = {\n            \"Leaf\": \"leaf_number\",\n            \"Spine\": \"spine_number\",\n            \"Super-Spine\": \"super_spine_number\"\n        }\n        highest_index = 0\n        device_ids_in_same_pod_or_dc = []\n\n        #Get devices in same pod or DC\n        for switch, switch_object in switches_in_dc.items():\n            if switch_object.role == role:\n                if role != \"Super-Spine\":\n                    if switch_object.dc_pod == self.dc_pod and int(getattr(switch_object, role_to_attr[role])) > highest_index:\n                        highest_index = int(getattr(switch_object, role_to_attr[role]))\n                else:\n                    if switch_object.dc == self.dc and int(getattr(switch_object, role_to_attr[role])) > highest_index:\n                        highest_index = int(getattr(switch_object, role_to_attr[role]))\n\n        return highest_index\n\n    def set_spanning_tree(self, pod):\n        self.config[\"spanning_tree\"][\"mode\"] = pod.spanning_tree_mode\n\n    def merge_multilane_interfaces(self):\n        '''\n        Combines ethernet interface lanes that share common LLDP neighbor\n        self.x_interfaces looks like { \"EthernetX\": {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name} }\n        '''\n        #If we see the same neighbor on multiple lanes of an interface - merge the interface lanes\n        interface_attrs = {\n                \"mlag_peer_link_interfaces\": self.mlag_peer_link_interfaces,\n                \"uplink_interfaces\": self.uplink_interfaces,\n                \"downlink_interfaces\": self.downlink_interfaces\n            }\n        for attr, ifaces in interface_attrs.items():\n            member_interfaces_to_remove = []\n            sorted_ifaces = natural_sort(ifaces.keys())\n            for iface in sorted_ifaces:\n                if not ifaces.get(iface):\n                    continue\n                slash_count = alphanum_key(iface).count(\"/\")\n                if slash_count == 0:\n                    continue\n                iface_group = \"\".join( [ str(i) for i in alphanum_key(iface)[ : slash_count * 2 ] ] )\n                #Compare rest of the interfaces in that group to see if they have the same neighbor\n                interfaces_in_group = []\n                for member_iface in sorted_ifaces:\n                    if \"\".join( [ str(i) for i in alphanum_key(member_iface)[ : slash_count * 2 ] ] ) == iface_group and iface != member_iface:\n                        try:\n                            if ifaces[iface][\"neighborHostname\"] == ifaces[member_iface][\"neighborHostname\"]:\n                                del ifaces[member_iface]\n                        except KeyError:\n                            continue\n            setattr(self, attr, ifaces)\n\nclass LeafDetails(SwitchDetails):\n    def __init__(self):\n        super().__init__()\n        self.role = \"Leaf\"\n        self.leaf_number = None #Leaf-Number tag\n        self.leaf_domain = None #Leaf-Domain tag\n\n    def __str__(self):\n        return \"{} - {}\\n   role: {}\\n   leaf number: {}\\n   leaf domain: {}\".format(self.hostname, self.id, self.role, self.leaf_number, self.leaf_domain)\n\n    def check_tags(self):\n        tags = {\n            \"dc\" : {\"label\": \"DC\", \"type\": str},\n            \"dc_pod\" : {\"label\": \"DC-Pod\", \"type\": str},\n            \"leaf_number\" : {\"label\": \"Leaf-Number\", \"type\": int},\n            \"leaf_domain\" : {\"label\": \"Leaf-Domain\", \"type\": int},\n        }\n        for tag in tags.keys():\n            assert getattr(self, tag) is not None, \"{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected\".format(\n                tags[tag][\"label\"], tags[tag][\"label\"], self.hostname\n            )\n            try:\n                value_type = tags[tag][\"type\"](getattr(self, tag))\n            except ValueError:\n                assert False, \"'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}\".format(\n                    tags[tag][\"label\"], self.hostname, getattr(self, tag), tags[tag][\"type\"]\n                    )\n\n    def get_interfaces(self):\n        '''\n        Gets and sets the physical ethernet interfaces for connections from switch\n        Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:\n        {\n            \"neighborHostname\": str,\n            \"neighborInterface\": str\n        }\n\n        '''\n        uplink_interfaces = {}\n        downlink_interfaces = {}\n        mlag_peer_link_interfaces = {}\n        for i in my_device.getInterfaces():\n            peer_device, peer_interface = i.getPeerInfo()\n            if peer_device is not None:\n                if switches_in_dc.get(peer_device.hostName):\n                    neighbor = switches_in_dc.get(peer_device.hostName)\n                    if neighbor.role == \"Leaf\" and self.leaf_domain == neighbor.leaf_domain:\n                        mlag_peer_link_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n                    elif neighbor.role == \"Spine\":\n                        uplink_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n                    elif neighbor.role == \"L2-Leaf\":\n                        downlink_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n        self.uplink_interfaces = uplink_interfaces\n        self.downlink_interfaces = downlink_interfaces\n        self.mlag_peer_link_interfaces = mlag_peer_link_interfaces\n        return\n\n    def check_mlag_role(self):\n        '''\n        Returns 'Primary', 'Secondary', or None if no MLAG neighbor present\n        '''\n        for switch_object in switches_in_dc.values():\n            #Skip over self and non leaf switches\n            if switch_object.id == self.id or switch_object.role != \"Leaf\":\n                continue\n            if switch_object.dc_pod == self.dc_pod and switch_object.leaf_domain == self.leaf_domain:\n                if int(self.leaf_number) < int(switch_object.leaf_number):\n                    return \"Primary\"\n                else:\n                    return \"Secondary\"\n        return None\n\n    def get_asn_from_input(self, studios_input):\n        try:\n            asn = int( studios_input[\"dataCenter\"][\"pods\"].resolve()[\"pod\"][\"LeafDomains\"].resolve(device=self.id)[\"l3LeafDomain\"][\"asn\"] )\n        except:\n            return\n        if asn != 0:\n            self.config[\"router_bgp\"][\"as\"] = asn\n\n    def set_mlag(self, pod):\n        # check if switch is primary or secondary based on leaf_number\n        mlag_role = self.check_mlag_role()\n        if mlag_role is None:\n            self.config[\"mlag_configuration\"][\"enabled\"] = False\n            return\n        else:\n            self.config[\"mlag_configuration\"][\"enabled\"] = True\n        #Set Spanning Tree No Vlan\n        self.config[\"spanning_tree\"][\"no_spanning_tree_vlan\"] = pod.mlag[\"mlag_peer_vlan\"]\n\n        #Set Vlans\n        self.config[\"vlans\"][ pod.mlag[\"mlag_peer_vlan\"] ] = {\n            \"name\": pod.mlag[\"mlag_vlan_name\"],\n            \"trunk_groups\": [\n                pod.mlag[\"mlag_vlan_trunk_group_name\"]\n            ]\n        }\n        #Set Port-Channel\n        self.config[\"port_channel_interfaces\"][ \"Port-Channel{}\".format(pod.mlag[\"mlag_peer_link_id\"]) ] = {\n            \"description\": pod.mlag[\"mlag_peer_link_description\"],\n            \"mode\": \"trunk\",\n            \"trunk_groups\": [\n                pod.mlag[\"mlag_vlan_trunk_group_name\"]\n                ]\n            }\n        #Set Ethernet interfaces\n        for iface, details in self.mlag_peer_link_interfaces.items():\n            self.config[\"ethernet_interfaces\"][iface] = {\n                #\"description\": pod.mlag[\"mlag_peer_link_member_iface_description\"].format(info[\"neighborHostname\"], info[\"neighborInterface\"]),\n                \"description\": \"MLAG peer link member interface\",\n                \"channel_group\":{\n                    \"id\" : pod.mlag[\"mlag_peer_link_id\"],\n                    \"mode\" : pod.mlag[\"lacp_mode\"]\n                }\n            }\n        #Get MLAG IP info\n        # check MLAG subnet and size of MLAG Subnet mask\n        mlag_subnet = ipaddress.ip_network(pod.mlag[\"mlag_ip_subnet\"])\n        mlag_subnet_mask = pod.mlag[\"mlag_subnet_mask\"]\n        if mlag_subnet_mask != mlag_subnet.prefixlen:\n            mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_subnet_mask))[ int(self.leaf_domain) - 1 ]\n\n        if mlag_role == \"Primary\":\n            mlag_ip = str(list(mlag_subnet.hosts())[0])\n            mlag_peer_ip = str(list(mlag_subnet.hosts())[1])\n        else:\n            mlag_ip = str(list(mlag_subnet.hosts())[1])\n            mlag_peer_ip = str(list(mlag_subnet.hosts())[0])\n\n        #Set SVI\n        self.config[\"vlan_interfaces\"][ \"Vlan{}\".format(pod.mlag[\"mlag_peer_vlan\"]) ] = {\n            \"description\": \"MLAG peering source\",\n            \"mtu\": 9214,\n            \"no_autostate\": True,\n            \"ip_address\": \"{}/{}\".format(mlag_ip, mlag_subnet_mask)\n        }\n        if self.model in [\"vEOS\", \"veos\", \"cEOS\", \"ceos\"]:\n            self.config[\"vlan_interfaces\"][ \"Vlan{}\".format(pod.mlag[\"mlag_peer_vlan\"]) ][\"mtu\"] = 1500\n        # Set virtual_router_mac_address\n        self.config[\"ip_virtual_router_mac_address\"] = pod.mlag[\"ip_virtual_router_mac_address\"]\n\n        #Set MLAG config\n        self.config[\"mlag_configuration\"][\"domain_id\"] = pod.mlag[\"mlag_domain_id\"]\n        self.config[\"mlag_configuration\"][\"local_interface\"] = \"Vlan{}\".format(pod.mlag[\"mlag_peer_vlan\"])\n        self.config[\"mlag_configuration\"][\"peer_address\"] = mlag_peer_ip\n        self.config[\"mlag_configuration\"][\"peer_link\"] = \"Port-Channel{}\".format(pod.mlag[\"mlag_peer_link_id\"])\n\n        #Change MLAG reload delay timers if Jericho platform\n        for regex in jericho_platform_regexes:\n            if re.search(regex, self.model):\n                self.config[\"mlag_configuration\"][\"reload_delay_mlag\"] = 780\n                self.config[\"mlag_configuration\"][\"reload_delay_non_mlag\"] = 1020\n                break\n\n        #Set BGP peer group parameters\n        if self.config[\"router_bgp\"][\"as\"] is None:\n            assert  self.config[\"router_bgp\"][\"as\"] is not None, \"{} does not have a BGP AS set\".format(self.hostname)\n\n        self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] ] = {}\n        for k, v in pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"].items():\n            self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] ][k] = v\n    \n        # Set remote as\n        self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] ][\"remote_as\"] = int(self.config[\"router_bgp\"][\"as\"])\n\n        self.config[\"router_bgp\"][\"neighbors\"][mlag_peer_ip] = {\"peer_group\": pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] }\n\n        # Activate ipv4 address family for peer group\n        if self.config[\"router_bgp\"].get(\"address_family_ipv4\") is not None and self.config[\"router_bgp\"][\"address_family_ipv4\"].get(\"peer_groups\") is not None:\n            self.config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] ] = {\"activate\": True}\n        else:\n            self.config[\"router_bgp\"][\"address_family_ipv4\"] = { \n                \"peer_groups\" : {\n                    pod.bgp[\"peer_groups\"][\"leaf\"][\"MLAG_IPv4_UNDERLAY_PEER\"][\"name\"] : {\"activate\": True}\n                }\n            }     \n        label = \"mlag_configuration.peer_link\"\n        value = self.config[\"mlag_configuration\"][\"peer_link\"]\n        #Create desired tag (will not create tag if it already exists):\n        tag_key = TagKey()\n        tag_key.workspace_id.value = workspace_id\n        tag_key.element_type = 1\n        tag_key.label.value = label\n        tag_key.value.value = str(value)\n        create_tag(tag_key)\n        \n        #Apply desired tag\n        tag_assignment_key = TagAssignmentKey()\n        tag_assignment_key.workspace_id.value = workspace_id\n        tag_assignment_key.element_type = 1\n        tag_assignment_key.label.value = label\n        tag_assignment_key.value.value = str(value)\n        tag_assignment_key.device_id.value = self.id\n        apply_tag(tag_assignment_key)\n\n        #Remove other tags with same label that don't match proper value\n        tag_assignment_key = TagAssignmentKey()\n        tag_assignment_key.workspace_id.value = workspace_id\n        tag_assignment_key.element_type = 1\n        tag_assignment_key.label.value = label\n        tag_assignment_key.device_id.value =  self.id\n        applied_tags = get_tag_values_applied_to_device(tag_assignment_key)\n        for tag in applied_tags:\n            if tag.value != str(value):\n                tag_assignment_key.value.value = tag.value\n                remove_tag(tag_assignment_key)\n\n    def set_bgp(self, pod):\n        #Set routing protocol model to multi-agent\n        self.config[\"service_routing_protocols_model\"] = \"multi-agent\"\n\n        # Function call for number of spines\n        highest_spine_number = self.get_highest_role_number(\"Spine\")\n        \n        #Make pod.underlay_p2p_network_summaries IPv4 Network objects\n        for i, network in enumerate(pod.underlay_p2p_network_summaries):\n            pod.underlay_p2p_network_summaries[i] = ipaddress.ip_network(network)\n\n        # If we have a mismatch of spines and link subnets, then we split the first item in the list by a number that is a power of 2\n        if len(pod.underlay_p2p_network_summaries) > 1 and len(pod.underlay_p2p_network_summaries) != highest_spine_number:\n            assert False, \"Please enter a single underlay subnet or an underlay subnet for each spine in the Pod.\"\n\n        max_spines = pod.max_spines if pod.max_spines is not None else highest_spine_number\n        for i, iface in enumerate(natural_sort(self.uplink_interfaces.keys())):\n            uplink_subnet_mask = pod.underlay_p2p_subnet_mask\n            if len(pod.underlay_p2p_network_summaries) > 1:\n                spine_index = int(switches_in_dc[self.uplink_interfaces[iface][\"neighborHostname\"]].spine_number)\n                uplink_subnet = ipaddress.ip_network(pod.underlay_p2p_network_summaries[ spine_index - 1 ])\n                uplink__child_subnet = list(uplink_subnet.subnets(new_prefix=uplink_subnet_mask))[ (int(self.leaf_number) - 1) ]\n            else:\n                uplink_subnet = ipaddress.ip_network(pod.underlay_p2p_network_summaries[0])\n                uplink__child_subnet = list(uplink_subnet.subnets(new_prefix=uplink_subnet_mask))[ ( int(self.leaf_number) - 1) * max_spines + i ]\n            \n            local_ip = None\n            neighbor_ip = None\n\n            local_ip = str(list(uplink__child_subnet.hosts())[1]) + '/' + str(uplink_subnet_mask)\n            neighbor_ip = str(list(uplink__child_subnet.hosts())[0])\n            \n            #Update uplink interface details\n            self.uplink_interfaces[iface][\"ip_address\"] = local_ip\n            self.uplink_interfaces[iface][\"neighbor_ip_address\"] = neighbor_ip\n\n            if self.config['ethernet_interfaces'] is None:\n                self.config['ethernet_interfaces'] = {}\n\n            self.config['ethernet_interfaces'][iface] = {\n                \"ip_address\": local_ip, \n                \"neighbor_ip_address\": neighbor_ip,\n                \"mtu\": pod.p2p_uplinks_mtu,\n                \"description\": \"to {}:{}\".format(self.uplink_interfaces[iface][\"neighborHostname\"], self.uplink_interfaces[iface][\"neighborInterface\"]),\n                \"type\": \"routed\"\n            }\n            if self.model in [\"vEOS\", \"veos\", \"cEOS\", \"ceos\"]:\n                self.config['ethernet_interfaces'][iface][\"mtu\"] = 1500\n\n        # Loopback\n        #Set Loopback0 parameters\n        if self.config['loopback_interfaces'] is None:\n            self.config['loopback_interfaces'] = {}\n        \n        if pod.overlay_loopback_network_summary_leafs == pod.overlay_loopback_network_summary_spines:\n            loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_leafs ).hosts() )[ int(self.leaf_number) + int(max_spines) - 1 ])\n        else:\n            loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_leafs ).hosts() )[ int(self.leaf_number) - 1 ])\n\n        self.config['loopback_interfaces']['Loopback0'] = {\n            \"ip_address\": loopback0_ip_address + \"/32\",\n            \"description\": \"BGP Router ID\"\n            }\n        # Set Loopback1 parameters\n        if pod.vxlan_overlay == True:\n            self.config['loopback_interfaces']['Loopback1'] = {\n                \"ip_address\": str(list( ipaddress.IPv4Network( pod.vtep_loopback_network_summary ).hosts() )[ int(self.leaf_domain) - 1 ]) + \"/32\",\n                \"description\": \"VXLAN Tunnel Source\"\n            }\n            if pod.vtep_vvtep_ip is not None:\n                self.config['loopback_interfaces']['Loopback1'][\"ip_address_secondaries\"] = [ str(pod.vtep_vvtep_ip) ]\n\n            self.config[\"vxlan_tunnel_interface\"] = {\n                \"Vxlan1\": {\n                    \"source_interface\": \"Loopback1\",\n                    \"vxlan_udp_port\": \"4789\",\n                }\n            }\n            if self.check_mlag_role() is not None:\n                self.config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"virtual_router\"] = {\"encapsulation_mac_address\": \"mlag-system-id\"}\n        # Enable IP Routing\n        self.config['ip_routing'] = True\n\n        # IP Prefix Lists\n        #    P2P Underlay\n        self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"transit\"][\"name\"] ] = { \"sequence_numbers\": {} }\n        for i, network in enumerate(pod.underlay_p2p_network_summaries):\n            self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"transit\"][\"name\"] ][\"sequence_numbers\"][ (i+1) * 10 ] = {\n                \"action\": \"permit {} le {}\".format(network, pod.underlay_p2p_subnet_mask)\n            }\n        #    Loopbacks\n        self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"loopbacks\"][\"name\"] ] = {\n            \"sequence_numbers\": {\n                10 : {\n                    \"action\": \"permit {} eq 32\".format(pod.overlay_loopback_network_summary_leafs)\n                }\n            }\n        }\n        if pod.vxlan_overlay == True:            \n            self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"loopbacks\"][\"name\"] ][\"sequence_numbers\"][20] = {\n                \"action\": \"permit {} eq 32\".format(pod.vtep_loopback_network_summary)    \n            }\n        # Routemaps\n        self.config[\"route_maps\"][ pod.filters[\"route_maps\"][\"connected_to_bgp\"][\"name\"] ] = {\n            \"sequence_numbers\":{\n                10: {\n                    \"type\": \"permit\",\n                    \"match\": [ \"ip address prefix-list {}\".format(pod.filters[\"prefix_lists\"][\"transit\"][\"name\"]) ]\n                },\n                20: {\n                    \"type\": \"permit\",\n                    \"match\": [ \"ip address prefix-list {}\".format(pod.filters[\"prefix_lists\"][\"loopbacks\"][\"name\"]) ]\n                }\n            }\n        }\n        # BGP Config\n        # Set BGP ASN\n        if self.config[\"router_bgp\"][\"as\"] is None:\n            assert  self.config[\"router_bgp\"][\"as\"] is not None, \"{} does not have a BGP AS set\".format(self.hostname)\n        # Set Router ID\n        self.config[\"router_bgp\"][\"router_id\"] = loopback0_ip_address\n        # Set ECMP and Max Paths\n        self.config[\"router_bgp\"][\"ecmp\"] = pod.bgp[\"ecmp\"]\n        self.config[\"router_bgp\"][\"maximum_paths\"] = pod.bgp[\"maximum_paths\"]\n        # Set defaults\n        self.config[\"router_bgp\"][\"bgp_defaults\"] = pod.bgp[\"leaf_defaults\"]\n        if self.model in [\"vEOS\", \"veos\", \"cEOS\", \"ceos\"]:\n            try:\n                self.config[\"router_bgp\"][\"bgp_defaults\"].remove(\"update wait-for-convergence\")\n            except ValueError:\n                pass\n            try:\n                self.config[\"router_bgp\"][\"bgp_defaults\"].remove(\"update wait-install\")\n            except ValueError:\n                pass\n\n        # Set up IPv4 peer groups\n        self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ] = {}\n        for k, v in pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"].items():\n            self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][k] = v\n        # Set remote as\n        self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][\"remote_as\"] = int(pod.bgp[\"spines_asn\"])\n\n        # Set up IPv4 neighbors\n        for iface, details in self.uplink_interfaces.items():\n            if \"neighbor_ip_address\" in details.keys():\n                self.config[\"router_bgp\"][\"neighbors\"][ str(details[\"neighbor_ip_address\"]) ] = {\n                    \"peer_group\": pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"]\n                }\n\n        # Enable IPv4 address family\n        #  if mlagipv4 peer group is alreeady in address_family_ipv4 peer_group dictionary\n        if ( \"address_family_ipv4\" in self.config[\"router_bgp\"].keys() ) and ( \"peer_groups\" in self.config[\"router_bgp\"][\"address_family_ipv4\"].keys() ):\n            self.config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ] = {\n                \"activate\": True\n            }\n        else:\n            self.config[\"router_bgp\"][\"address_family_ipv4\"] = {\n                \"peer_groups\":{\n                    pod.bgp[\"peer_groups\"][\"leaf\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] :{\n                        \"activate\": True\n                    }\n                }\n            }\n\n        # If EVPN is enabled\n        if pod.bgp[\"evpn_enabled\"] == True:\n            # Set up EVPN peer groups and neighbors\n            self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ] = {}\n            for k, v in pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"].items():\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][k] = v\n\n            # Set up EVPN neighbors\n            #Get hosts from max spine/superspine number and pod.overlay_loopback_network_summary_spines/superspines\n            if pod.bgp[\"super_spines_asn\"] is not None and int(pod.bgp[\"super_spines_asn\"]) != 0:\n                #Add Remote ASN to peer-group\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][\"remote_as\"] = int(pod.bgp[\"super_spines_asn\"])\n                \n                #Configure super spines is EVPN peers\n                highest_evpn_peer_node_index = self.get_highest_role_number(\"Super-Spine\") # get highest superspine tag\n                evpn_peering_subnet = ipaddress.ip_network(pod.overlay_loopback_network_summary_super_spines)\n            else:\n                #Add Remote ASN to peer-group\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][\"remote_as\"] = int(pod.bgp[\"spines_asn\"])\n\n                #Configure spines as EVPN peers\n                highest_evpn_peer_node_index = self.get_highest_role_number(\"Spine\") # get highest spine tag\n                evpn_peering_subnet = ipaddress.ip_network(pod.overlay_loopback_network_summary_spines)\n            evpn_peer_addresses = [ str( list( evpn_peering_subnet.hosts() )[i] ) for i in range(0, highest_evpn_peer_node_index) ]\n            for peer_address in evpn_peer_addresses:\n                self.config[\"router_bgp\"][\"neighbors\"][ str(peer_address) ] = {\n                    \"peer_group\": pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"]\n                }\n            #Enable EVPN address family\n            self.config[\"router_bgp\"][\"address_family_evpn\"] = {\n                \"peer_groups\":{\n                    pod.bgp[\"peer_groups\"][\"leaf\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] :{\n                        \"activate\": True\n                    }\n                }\n            }\n\n        # Set up redistributed connected parameters\n        self.config[\"router_bgp\"][\"redistribute_routes\"][\"connected\"] = {\n            \"route_map\": pod.filters[\"route_maps\"][\"connected_to_bgp\"][\"name\"]\n        }\n\n        # Enabke Vxlan profile in tcam if necessary\n        if pod.vxlan_overlay == True:\n            for regex in jericho_platform_regexes:\n                if re.search(regex, self.model):\n                    self.config[\"tcam_profile\"] = {\n                        \"system\": \"vxlan-routing\"\n                    }\n                    break\n\n        #Set BGP Tags\n        self.set_bgp_tags()\n\n\n    def create_config_parameters(self, pod):\n        '''\n        Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template \n        '''\n        self.set_spanning_tree(pod)\n        self.set_mlag(pod)\n        self.set_bgp(pod)\n        return self.config\n\nclass SpineDetails(SwitchDetails):\n    def __init__(self):\n        super().__init__()\n        self.role = \"Spine\"\n        self.spine_number = None\n\n    def __str__(self):\n        return \"{} - {}\\n   role: {}\\n   spine number: {}\".format(self.hostname, self.id, self.role, self.spine_number)\n\n    def check_tags(self):\n        tags = {\n            \"dc\" : {\"label\": \"DC\", \"type\": str},\n            \"dc_pod\" : {\"label\": \"DC-Pod\", \"type\": str},\n            \"spine_number\" : {\"label\": \"Spine-Number\", \"type\": int}\n        }\n        for tag in tags.keys():\n            assert getattr(self, tag) is not None, \"{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected\".format(\n                tags[tag][\"label\"], tags[tag][\"label\"], self.hostname\n            )\n            try:\n                value_type = tags[tag][\"type\"](getattr(self, tag))\n            except ValueError:\n                assert False, \"'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}\".format(\n                    tags[tag][\"label\"], self.hostname, getattr(self, tag), tags[tag][\"type\"]\n                    )\n\n    def get_interfaces(self):\n        '''\n        Gets and sets the physical ethernet interfaces for connections from switch\n        Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:\n        {\n            \"neighborHostname\": str,\n            \"neighborInterface\": str\n        }\n\n        '''\n        uplink_interfaces = {}\n        downlink_interfaces = {}\n        for i in my_device.getInterfaces():\n            peer_device, peer_interface = i.getPeerInfo()\n            if peer_device is not None:\n                #Check to see if switch name in switches_in_dc\n                if switches_in_dc.get(peer_device.hostName):\n                    neighbor = switches_in_dc.get(peer_device.hostName)\n                    if neighbor.role == \"Super-Spine\":\n                        uplink_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n                    elif neighbor.role == \"Leaf\":\n                        downlink_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n        self.uplink_interfaces = uplink_interfaces\n        self.downlink_interfaces = downlink_interfaces\n        return\n        \n    def set_bgp(self, pod):\n        #Set routing protocol model to multi-agent\n        self.config[\"service_routing_protocols_model\"] = \"multi-agent\"\n        \n        # Function call for number of spines\n        highest_spine_number = self.get_highest_role_number(\"Spine\")\n        \n        #Make pod.underlay_p2p_network_summaries IPv4 Network objects\n        for i, network in enumerate(pod.underlay_p2p_network_summaries):\n            pod.underlay_p2p_network_summaries[i] = ipaddress.ip_network(network)\n\n        # If we have a mismatch of spines and link subnets, then we split the first item in the list by a number that is a power of 2\n        if len(pod.underlay_p2p_network_summaries) > 1 and len(pod.underlay_p2p_network_summaries) != highest_spine_number:\n            assert False, \"Please enter a single underlay subnet or an underlay subnet for each spine in the Pod.\"\n\n        downlink_subnet_mask = pod.underlay_p2p_subnet_mask\n        if len(pod.underlay_p2p_network_summaries) > 1:\n            downlink_subnet = pod.underlay_p2p_network_summaries[ int(self.spine_number) - 1 ]\n        else:\n            downlink_subnet = pod.underlay_p2p_network_summaries[ 0 ]\n\n        max_spines = pod.max_spines if pod.max_spines is not None else highest_spine_number\n        for i, iface in enumerate(natural_sort(self.downlink_interfaces.keys())):\n            leaf_index = int(switches_in_dc[self.downlink_interfaces[iface][\"neighborHostname\"]].leaf_number)\n            \n            if len(pod.underlay_p2p_network_summaries) > 1:\n                downlink_child_subnet = list(downlink_subnet.subnets(new_prefix=downlink_subnet_mask))[ leaf_index - 1 ]\n            else:\n                downlink_child_subnet = list(downlink_subnet.subnets(new_prefix=downlink_subnet_mask))[ (leaf_index - 1) * max_spines + (int(self.spine_number) - 1) ]\n\n            local_ip = str(list(downlink_child_subnet.hosts())[0]) + '/' + str(downlink_subnet_mask)\n            neighbor_ip = str(list(downlink_child_subnet.hosts())[1])\n\n            #Set BGP peer group parameters\n            #Update neighbor asn\n            if switches_in_dc[self.downlink_interfaces[iface][\"neighborHostname\"]].config[\"router_bgp\"][\"as\"] is None:\n                assert  switches_in_dc[self.downlink_interfaces[iface][\"neighborHostname\"]].config[\"router_bgp\"][\"as\"] is not None, \"{} does not have a BGP AS set\".format(self.hostname)\n            else:\n                neighbor_asn = switches_in_dc[self.downlink_interfaces[iface][\"neighborHostname\"]].config[\"router_bgp\"][\"as\"]\n            \n            self.downlink_interfaces[iface][\"ip_address\"] = local_ip\n            self.downlink_interfaces[iface][\"neighbor_ip_address\"] = neighbor_ip\n            self.downlink_interfaces[iface][\"neighbor_asn\"] = neighbor_asn\n\n            if self.config['ethernet_interfaces'] is None:\n                self.config['ethernet_interfaces'] = {}\n\n            self.config['ethernet_interfaces'][iface] = {\n                \"ip_address\": local_ip, \n                \"neighbor_ip_address\": neighbor_ip,\n                \"mtu\": pod.p2p_uplinks_mtu,\n                \"description\": \"to {}:{}\".format(self.downlink_interfaces[iface][\"neighborHostname\"], self.downlink_interfaces[iface][\"neighborInterface\"]),\n                \"type\": \"routed\"\n                }\n            if self.model in [\"vEOS\", \"veos\", \"cEOS\", \"ceos\"]:\n                self.config['ethernet_interfaces'][iface][\"mtu\"] = 1500\n        # Loopback\n        if self.config['loopback_interfaces'] is None:\n            self.config['loopback_interfaces'] = {}\n        \n        loopback0_ip_address = str(list( ipaddress.IPv4Network( pod.overlay_loopback_network_summary_spines ).hosts() )[ int(self.spine_number) - 1 ])\n        self.config['loopback_interfaces']['Loopback0'] = {\n            \"ip_address\": loopback0_ip_address + \"/32\",\n            \"description\": \"BGP Router ID\"}\n\n        # Enable IP Routing\n        self.config['ip_routing'] = True\n\n        # IP Prefix Lists\n        #P2P Underlay\n        self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"transit\"][\"name\"] ] = { \"sequence_numbers\": {} }\n        for i, network in enumerate(pod.underlay_p2p_network_summaries):\n            self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"transit\"][\"name\"] ][\"sequence_numbers\"][ (i+1) * 10 ] = {\n                \"action\": \"permit {} le {}\".format(network, pod.underlay_p2p_subnet_mask)\n            }\n        # Loopbacks\n        self.config[\"prefix_lists\"][ pod.filters[\"prefix_lists\"][\"loopbacks\"][\"name\"] ] = {\n            \"sequence_numbers\": {\n                10 : {\n                    \"action\": \"permit {} eq 32\".format(pod.overlay_loopback_network_summary_spines)\n                }\n            }\n        }\n\n        # Routemaps\n        self.config[\"route_maps\"][ pod.filters[\"route_maps\"][\"connected_to_bgp\"][\"name\"] ] = {\n            \"sequence_numbers\":{\n                10: {\n                    \"type\": \"permit\",\n                    \"match\": [ \"ip address prefix-list {}\".format(pod.filters[\"prefix_lists\"][\"transit\"][\"name\"]) ]\n                },\n                20: {\n                    \"type\": \"permit\",\n                    \"match\": [ \"ip address prefix-list {}\".format(pod.filters[\"prefix_lists\"][\"loopbacks\"][\"name\"]) ]\n                }\n            }\n        }\n\n        # BGP Config\n        # Set BGP ASN\n        if self.config[\"router_bgp\"][\"as\"] is None:\n            self.config[\"router_bgp\"][\"as\"] = pod.bgp[\"spines_asn\"]\n        # Set Router ID\n        self.config[\"router_bgp\"][\"router_id\"] = loopback0_ip_address\n        # Set ECMP and Max Paths\n        self.config[\"router_bgp\"][\"ecmp\"] = pod.bgp[\"ecmp\"]\n        self.config[\"router_bgp\"][\"maximum_paths\"] = pod.bgp[\"maximum_paths\"]\n        # Set defaults\n        self.config[\"router_bgp\"][\"bgp_defaults\"] = pod.bgp[\"spine_defaults\"]\n        if self.model in [\"vEOS\", \"veos\", \"cEOS\", \"ceos\"]:\n            try:\n                self.config[\"router_bgp\"][\"bgp_defaults\"].remove(\"update wait-for-convergence\")\n            except ValueError:\n                pass\n            try:\n                self.config[\"router_bgp\"][\"bgp_defaults\"].remove(\"update wait-install\")\n            except ValueError:\n                pass\n        # Set up IPv4 peer groups\n        self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ] = {}\n        for k, v in pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"].items():\n            self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][k] = v\n\n        # Set up IPv4 neighbors\n        #Set up dynamic BGP peering or Neighbor based\n        if pod.bgp[\"dynamic_peering\"] == True:\n            #Divide leafs_asn_range into as few continuous asn ranges as possible\n            dynamic_peering_peer_filter_statements = []\n            from operator import itemgetter\n            from itertools import groupby\n            leafs_asn_range = string_to_list(pod.bgp[\"leafs_asn_range\"])\n            if len(leafs_asn_range) > 1:\n                for k,g in groupby(enumerate(leafs_asn_range),lambda x:x[0]-x[1]):\n                    group = map(itemgetter(1), g)\n                    group = list(map(int,group))\n                    dynamic_peering_peer_filter_statements.append(\"{}-{}\".format(group[0], group[-1]))\n            else:\n                dynamic_peering_peer_filter_statements = [ pod.bgp[\"leafs_asn_range\"] ]\n\n            #Define Peer Filer\n            self.config[\"peer_filters\"] = {\n                pod.filters[\"peer_filters\"][\"bgp_range_accept\"][\"name\"] : {\n                    \"sequence_numbers\" :{\n                    }\n                }\n            }\n            for i, statement in enumerate(dynamic_peering_peer_filter_statements):\n                self.config[\"peer_filters\"][pod.filters[\"peer_filters\"][\"bgp_range_accept\"][\"name\"]][\"sequence_numbers\"][(i+1)*10] = {\n                    \"match\": \"as-range {} result accept\".format(statement)\n                }\n\n            #Define BGP Listen Range neighbor statement\n            if len(pod.underlay_p2p_network_summaries) > 1:\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][\"bgp_listen_range_prefix\"] = str(pod.underlay_p2p_network_summaries[ int(self.spine_number) -1 ])\n            else:\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][\"bgp_listen_range_prefix\"] = str(pod.underlay_p2p_network_summaries[ 0 ])\n            self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] ][\"peer_filter\"] = pod.filters[\"peer_filters\"][\"bgp_range_accept\"][\"name\"] #Peer filter name\n        else:\n            for iface, details in self.downlink_interfaces.items():\n                if \"neighbor_ip_address\" in details.keys():\n                    self.config[\"router_bgp\"][\"neighbors\"][ str(details[\"neighbor_ip_address\"]) ] = {\n                        \"peer_group\": pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"]\n                    }\n                    if \"neighbor_asn\" in details.keys():\n                        self.config[\"router_bgp\"][\"neighbors\"][ str(details[\"neighbor_ip_address\"]) ][\"remote_as\"] = details[\"neighbor_asn\"]\n\n        # Enable IPv4 address family\n        self.config[\"router_bgp\"][\"address_family_ipv4\"] = {\n            \"peer_groups\":{\n                pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] :{\n                    \"activate\": True\n                }\n            }\n        }\n\n        # If EVPN is enabled\n        if pod.bgp[\"evpn_enabled\"] == True:\n            # Set up EVPN neighbors\n            #Get hosts from max spine/superspine number and pod.overlay_loopback_network_summary_spines/superspines\n            if pod.bgp[\"super_spines_asn\"] is None or int(pod.bgp[\"super_spines_asn\"]) == 0:\n                # Set up EVPN peer groups and neighbors\n                self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ] = {}\n                for k, v in pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"].items():\n                    self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][k] = v\n\n                if pod.bgp[\"dynamic_peering\"] == True:\n                    #Define BGP Listen Range neighbor statement\n                    self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][\"bgp_listen_range_prefix\"] = str(pod.overlay_loopback_network_summary_leafs)\n                    self.config[\"router_bgp\"][\"peer_groups\"][ pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] ][\"peer_filter\"] = pod.filters[\"peer_filters\"][\"bgp_range_accept\"][\"name\"] #Peer filter name\n                else:\n                    #Add Remote ASN to peer-group\n                    for iface, details in self.downlink_interfaces.items():\n                        #Get suspected Loopback IP Address of neighbor\n                        neighbor_leaf_index = int(switches_in_dc[details[\"neighborHostname\"]].leaf_number)\n                        if pod.overlay_loopback_network_summary_leafs == pod.overlay_loopback_network_summary_spines:\n                            neighbor_leaf_index += max_spines\n                        neighbor_loopback_ip = str( list( ipaddress.ip_network( pod.overlay_loopback_network_summary_leafs ).hosts() ) [(int(neighbor_leaf_index) - 1) ] )\n                        self.config[\"router_bgp\"][\"neighbors\"][neighbor_loopback_ip] = {\n                            \"peer_group\": pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"]\n                        }\n                        if \"neighbor_asn\" in details.keys():\n                            self.config[\"router_bgp\"][\"neighbors\"][ neighbor_loopback_ip ][\"remote_as\"] = details[\"neighbor_asn\"]\n\n            #Enable EVPN address family\n            self.config[\"router_bgp\"][\"address_family_evpn\"] = {\n                \"peer_groups\":{\n                    pod.bgp[\"peer_groups\"][\"spine\"][\"EVPN_OVERLAY_PEERS\"][\"name\"] :{\n                        \"activate\": True\n                    }\n                }\n            }\n        else:\n            for iface, details in self.downlink_interfaces.items():\n                if \"neighbor_ip_address\" in details.keys():\n                    self.config[\"router_bgp\"][\"neighbors\"][ str(details[\"neighbor_ip_address\"]) ] = {\n                        \"peer_group\": pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"]\n                    }\n                    if \"neighbor_asn\" in details.keys():\n                        self.config[\"router_bgp\"][\"neighbors\"][ str(details[\"neighbor_ip_address\"]) ][\"remote_as\"] = details[\"neighbor_asn\"]\n\n        # Enable IPv4 address family\n        self.config[\"router_bgp\"][\"address_family_ipv4\"] = {\n            \"peer_groups\":{\n                pod.bgp[\"peer_groups\"][\"spine\"][\"IPv4_UNDERLAY_PEERS\"][\"name\"] :{\n                    \"activate\": True\n                }\n            }\n        }\n\n        # Set up redistributed connected parameters\n        self.config[\"router_bgp\"][\"redistribute_routes\"][\"connected\"] = {\n            \"route_map\": pod.filters[\"route_maps\"][\"connected_to_bgp\"][\"name\"]\n        }\n    \n        #Set BGP Tags\n        self.set_bgp_tags()\n\n    def create_config_parameters(self, pod):\n        '''\n        Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template \n        '''\n        self.set_spanning_tree(pod)\n        self.set_bgp(pod)\n        return self.config\n\n\nclass SuperSpineDetails(SwitchDetails):\n    def __init__(self):\n        super().__init__()\n        self.role = \"Super-Spine\"\n        self.super_spine_number = None\n\n    def check_tags(self):\n        tags = {\n            \"dc\" : {\"label\": \"DC\", \"type\": str},\n            \"super_spine_number\" : {\"label\": \"Super-Spine-Number\", \"type\": int}\n        }\n        for tag in tags.keys():\n            assert getattr(self, tag) is not None, \"{} is not set.  Please apply a '{}' tag to {} in the Tags section of Provisioning with the appropriate workspace selected\".format(\n                tags[tag][\"label\"], tags[tag][\"label\"], self.hostname\n            )\n            try:\n                value_type = tags[tag][\"type\"](getattr(self, tag))\n            except ValueError:\n                assert False, \"'{}' tag applied to {} has an invalid value, {}.  The value should be of type {}\".format(\n                    tags[tag][\"label\"], self.hostname, getattr(self, tag), tags[tag][\"type\"]\n                    )\n\n    def get_interfaces(self):\n        '''\n        Gets and sets the physical ethernet interfaces for connections from switch\n        Returns interface dictionary where keys are local interface names and values are dictionaries with keys below:\n        {\n            \"neighborHostname\": str,\n            \"neighborInterface\": str\n        }\n\n        '''\n        downlink_interfaces = {}\n        for i in my_device.getInterfaces():\n            peer_device, peer_interface = i.getPeerInfo()\n            if peer_device is not None:\n                if switches_in_dc.get(peer_device.hostName):\n                    neighbor = switches_in_dc.get(peer_device.hostName)\n                    if neighbor.role == \"Spine\":\n                        downlink_interfaces[i.name] = {\"neighborHostname\": peer_device.hostName, \"neighborInterface\": peer_interface.name}\n        self.downlink_interfaces = downlink_interfaces\n        return\n\n    def create_config_parameters(self, pod):\n        '''\n        Using self attributes and pod attributes, populates configuration dictionary for switch.config which will be used to generate configuration when rendered by template \n        '''\n        ## self.set_spanning_tree(pod)\n        ## self.set_bgp(pod)\n        return self.config\n\n\ndef create_switch(role):\n    if role == \"Leaf\":\n        return LeafDetails()\n    elif role == \"Spine\":\n        return SpineDetails()\n    elif role == \"Super-Spine\":\n        return SuperSpineDetails()\n    else:\n        return\n\ndef get_switch_details(device_id):\n    labels_to_fields = {\n        \"hostname\": \"hostname\",\n        \"model\": \"model\",\n        \"Role\": \"role\",\n        \"DC\": \"dc\",\n        \"DC-Pod\": \"dc_pod\",\n        \"Leaf-Number\": \"leaf_number\",\n        \"Leaf-Domain\": \"leaf_domain\",\n        \"Spine-Number\": \"spine_number\",\n        \"Super-Spine-Number\": \"super_spine_number\"\n    }\n    switch = None\n    found_switch = False\n    #Create tagstub\n    tsclient = ctx.getApiClient(tsgr.TagSearchStub)\n\n    #Create TagValueSearchRequest\n    tvsr = tspb.TagValueSearchRequest(label=\"Role\", workspace_id=workspace_id, topology_studio_request=True)\n    for tag in tsclient.GetTagValueSuggestions(tvsr).tags:\n        query= \"{}:\\\"{}\\\" AND device:{}\".format(tag.label, tag.value, device_id)\n        tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)\n        tagmresp =  tsclient.GetTagMatchesV2(tagmr)\n        for match in tagmresp.matches:\n            if match.device.device_id == device_id:\n                switch = create_switch(tag.value)\n                found_switch = True\n                break\n        if found_switch == True:\n            break\n\n    #Check to see role is set on switch\n    assert switch is not None, \"Role is not set on {}.  Please apply a 'Role' tag to {} with a value of either 'Leaf', 'Spine', or 'Super-Spine' in the Tags section of Provisioning with the appropriate workspace selected\".format(\n                match.device.device_id, match.device.device_id\n            )\n\n    for label in labels_to_fields.keys():\n        if label == \"hostname\":\n            for dev in ctx.topology.getDevices(deviceIds=[device_id]):\n                if dev.hostName:\n                    setattr(switch, labels_to_fields[ label ], dev.hostName)\n            continue\n        if label == \"model\":\n            for dev in ctx.topology.getDevices(deviceIds=[device_id]):\n                if dev.modelName:\n                    setattr(switch, labels_to_fields[ label ], dev.modelName)\n            continue\n        tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)\n        for tag in tsclient.GetTagValueSuggestions(tvsr).tags:\n            try:\n                query= \"{}:\\\"{}\\\" AND device:{}\".format(tag.label, tag.value, device_id)\n                tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)\n                tagmresp =  tsclient.GetTagMatchesV2(tagmr)\n            except:\n                continue\n            else:\n                for match in tagmresp.matches:\n                    if match.device.device_id == device_id:\n                        setattr(switch, labels_to_fields[ tag.label ], tag.value)\n                        break\n\n    switch.id = device_id\n    #Chcek to see switch tags are set and with proper values\n    switch.check_tags()\n    return switch\n\ndef get_switches_in_dc(dc):\n    #list of switches we'll return\n    switches = {}\n\n    #Create tagstub\n    tsclient = ctx.getApiClient(tsgr.TagSearchStub)\n\n    #Get switches in dc\n    query= \"{}:\\\"{}\\\"\".format(\"DC\", dc)\n    tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)\n    tagmresp =  tsclient.GetTagMatchesV2(tagmr)\n    for match in tagmresp.matches:\n        switch = get_switch_details(match.device.device_id)\n        if switch is None:\n            continue\n        if switch.hostname not in switches:\n            switches[switch.hostname] = switch\n    return switches\n\ndef get_manually_allocated_leaf_asns(my_switch, switches_in_dc, studios_input_data):\n    manually_allocated_asns = {}\n    for switch, switch_object in switches_in_dc.items():\n        if switch_object.role.lower() == \"leaf\" and switch_object.dc_pod == my_switch.dc_pod:\n            switch_object.get_asn_from_input(studio_input_data)\n            if switch_object.config[\"router_bgp\"].get(\"as\") is not None:\n                manually_allocated_asns[int(switch_object.leaf_domain)] = switch_object.config[\"router_bgp\"][\"as\"]\n    return manually_allocated_asns\n\ndef assign_leaf_switch_asn(switch_object, my_switch, my_pod):\n    if switch_object.config[\"router_bgp\"][\"as\"] is None and switch_object.role.lower() == \"leaf\" and switch_object.dc_pod == my_switch.dc_pod:\n        leaf_asns = string_to_list(my_pod.bgp[\"leafs_asn_range\"])\n        if len(leaf_asns) > 1:\n            #Create list of available leaf bgp asns\n            leaf_domain_index_shift = 0\n            for leaf_domain, manually_allocated_asn in my_pod.manually_allocated_leaf_asns.items():\n                if manually_allocated_asn in leaf_asns:\n                    leaf_asns.remove(manually_allocated_asn)\n                    if leaf_domain < int(switch_object.leaf_domain):\n                        leaf_domain_index_shift += 1\n            asn_index = int(switch_object.leaf_domain) - leaf_domain_index_shift -1\n            assert len(leaf_asns) > asn_index, \"the Pod leaf ASN range must be increased for specified leaf domains\"\n            switch_object.config[\"router_bgp\"][\"as\"] = leaf_asns[ asn_index]\n        else:\n            switch_object.config[\"router_bgp\"][\"as\"] = leaf_asns[0]\n    return switch_object\n\n#Set config data model to empty\nconfig = {}\n#Get Pod Details for switch\nmy_pod = get_pod_details(studio_input_data)\n#Get Switch Details\nmy_switch = get_switch_details(my_device_id)\n\nif my_pod is not None and my_switch is not None:\n    #Get Switch Details For All Switches In This DC\n    switches_in_dc = get_switches_in_dc(my_switch.dc)\n\n    #Get interface details for switch\n    my_switch.get_interfaces()\n    my_switch.merge_multilane_interfaces()\n\n    #Get already allocated leaf asns in Pod - these will be removed from leaf asn range since they are not available for allocation - key will be leaf_domain, value will be asn\n    my_pod.manually_allocated_leaf_asns = get_manually_allocated_leaf_asns(my_switch, switches_in_dc, studio_input_data)\n\n    #Assign an asn to all leaf switch objects that don't already have one\n    for switch, switch_object in switches_in_dc.items():\n        if switch_object.role.lower() == \"leaf\":\n            switches_in_dc[switch] = assign_leaf_switch_asn(switch_object, my_switch, my_pod)\n\n    #Assign ASN to my_switch\n    my_switch.config[\"router_bgp\"][\"as\"] = switches_in_dc[my_switch.hostname].config[\"router_bgp\"][\"as\"]\n\n    #Switch is either a leaf or spine\n    if my_switch.role in [\"Leaf\", \"Spine\"]:\n        my_switch.create_config_parameters(my_pod)\n        config = my_switch.config\n    #Switch has no supported role\n    else:\n        config = {}\n%>\n% if config.get(\"service_routing_protocols_model\") is not None and config.get(\"service_routing_protocols_model\") == \"multi-agent\":\nservice routing protocols model multi-agent\n!\n% endif\n## eos - spanning-tree\n% if config.get(\"spanning_tree\") is not None:\n%     if config[\"spanning_tree\"].get(\"mode\") is not None:\nspanning-tree mode ${ config[\"spanning_tree\"].get(\"mode\") }\n%     endif\n%     if config[\"spanning_tree\"].get(\"no_spanning_tree_vlan\") is not None:\nno spanning-tree vlan-id ${ config[\"spanning_tree\"].get(\"no_spanning_tree_vlan\") }\n%     endif\n!\n% endif\n## eos - VLANs\n%if config.get(\"vlans\") is not None:\n%     for vlan in natural_sort(config.get(\"vlans\")):\nvlan ${ vlan }\n%          if config.get(\"vlans\")[vlan].get(\"name\") is not None:\nname ${ config.get(\"vlans\")[vlan].get(\"name\") }\n%          endif\n%          if config.get(\"vlans\")[vlan].get(\"state\") is not None:\nstate ${ config.get(\"vlans\")[vlan].get(\"state\") }\n%          endif\n%          if config.get(\"vlans\")[vlan].get(\"trunk_groups\") is not None:\n%               for trunk_group in config.get(\"vlans\")[vlan].get(\"trunk_groups\"):\ntrunk group ${ trunk_group }\n%               endfor\n%          endif\n!   \n%    endfor %}\n%endif\n## eos- Port-Channel Interfaces\n% if config.get(\"port_channel_interfaces\") is not None:\n%   for port_channel_interface in natural_sort(config[\"port_channel_interfaces\"].keys()):\ninterface ${ port_channel_interface }\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"description\") is not None:\ndescription ${ config[\"port_channel_interfaces\"][port_channel_interface][\"description\"] }\n%     endif\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"shutdown\") == True:\nshutdown\n%     elif config[\"port_channel_interfaces\"][port_channel_interface].get(\"shutdown\") == False:\nno shutdown\n%     endif\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"mtu\") is not None:\nmtu ${ config[\"port_channel_interfaces\"][port_channel_interface][\"mtu\"] }\n%     endif\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"type\") is not None and config[\"port_channel_interfaces\"][port_channel_interface].get(\"type\") == \"routed\":\nno switchport\n%     else:\nswitchport\n%     endif\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"mode\") is not None and config[\"port_channel_interfaces\"][port_channel_interface].get(\"mode\") == \"access\":\nswitchport access vlan ${ config[\"port_channel_interfaces\"][port_channel_interface][\"vlans\"] }\n%     endif %}\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"mode\") is not None and config[\"port_channel_interfaces\"][port_channel_interface].get(\"mode\") == \"trunk\":\nswitchport mode ${ config[\"port_channel_interfaces\"][port_channel_interface][\"mode\"] }\n%     endif\n%     if config[\"port_channel_interfaces\"][port_channel_interface].get(\"trunk_groups\") is not None:\n%       for trunk_group in config[\"port_channel_interfaces\"][port_channel_interface][\"trunk_groups\"]:\nswitchport trunk group ${ trunk_group }\n%       endfor\n%     endif\n!\n%   endfor\n% endif\n## eos - Ethernet Interfaces\n%if config.get(\"ethernet_interfaces\") is not None:\n%for ethernet_interface in natural_sort(config[\"ethernet_interfaces\"].keys()):\ninterface ${ethernet_interface }\n%     if config[\"ethernet_interfaces\"][ethernet_interface][\"description\"] is not None:\ndescription ${config[\"ethernet_interfaces\"][ethernet_interface][\"description\"]}\n%     endif\n%     if config[\"ethernet_interfaces\"][ethernet_interface].get(\"channel_group\") is not None:\nchannel-group ${ config[\"ethernet_interfaces\"][ethernet_interface][\"channel_group\"][\"id\"] } mode ${ config[\"ethernet_interfaces\"][ethernet_interface][\"channel_group\"][\"mode\"] }\n%     else:\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"mtu\") is not None:\nmtu ${ config[\"ethernet_interfaces\"][ethernet_interface][\"mtu\"] }\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"type\") is not None and config[\"ethernet_interfaces\"][ethernet_interface].get(\"type\") == \"routed\":\nno switchport\n%         else:\nswitchport\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") is not None and config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") == \"access\":\n%             if config[\"ethernet_interfaces\"][ethernet_interface].get(\"vlans\") is not None:\nswitchport access vlan ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"vlans\") }\n%             endif\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") is not None and config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") == \"trunk\":\n%             if config[\"ethernet_interfaces\"][ethernet_interface].get(\"vlans\") is not None:\nswitchport trunk allowed vlan ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"vlans\") }\n%             endif\n%             if config[\"ethernet_interfaces\"][ethernet_interface].get(\"native_vlan\") is not None:\nswitchport trunk native vlan ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"native_vlan\") }\n%             endif\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") is not None:\nswitchport mode ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"mode\") }\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"trunk_groups\") is not None:\n%             for trunk_group in config[\"ethernet_interfaces\"][ethernet_interface].get(\"trunk_groups\"):\nswitchport trunk group ${ trunk_group }\n%             endfor\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"vrf\") is not None:\nvrf ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"vrf\") }\n%         endif\n%         if config[\"ethernet_interfaces\"][ethernet_interface].get(\"ip_address\") is not None:\nip address ${ config[\"ethernet_interfaces\"][ethernet_interface].get(\"ip_address\") }\n%             if config[\"ethernet_interfaces\"][ethernet_interface].get(\"ip_address_secondaries\") is not None:\n%                 for ip_address_secondary in config[\"ethernet_interfaces\"][ethernet_interface].get(\"ip_address_secondaries\"):\nip address ${ ip_address_secondary } secondary\n%                 endfor\n%             endif\n%         endif\n%     endif\n!\n%endfor\n%endif\n## eos - Loopback Interfaces\n%if config.get(\"loopback_interfaces\") is not None:\n%   for loopback_interface in natural_sort(config.get(\"loopback_interfaces\").keys()):\ninterface ${ loopback_interface }\n%       if config[\"loopback_interfaces\"][loopback_interface].get(\"description\") is not None:\ndescription ${ config[\"loopback_interfaces\"][loopback_interface].get(\"description\") }\n%       endif\n%       if config[\"loopback_interfaces\"][loopback_interface].get(\"shutdown\") is not None and config[\"loopback_interfaces\"][loopback_interface].get(\"shutdown\") == True:\nshutdown\n%       elif config[\"loopback_interfaces\"][loopback_interface].get(\"shutdown\") is not None and config[\"loopback_interfaces\"][loopback_interface].get(\"shutdown\") == False:\nno shutdown\n%       endif\n%       if config[\"loopback_interfaces\"][loopback_interface].get(\"vrf\") is not None:\nvrf ${ config[\"loopback_interfaces\"][loopback_interface].get(\"vrf\") }\n%       endif\n%       if config[\"loopback_interfaces\"][loopback_interface].get(\"ip_address\") is not None:\nip address ${ config[\"loopback_interfaces\"][loopback_interface].get(\"ip_address\") }\n%           if config[\"loopback_interfaces\"][loopback_interface].get(\"ip_address_secondaries\") is not None:\n%               for ip_address_secondary in config[\"loopback_interfaces\"][loopback_interface].get(\"ip_address_secondaries\"):\nip address ${ ip_address_secondary } secondary\n%               endfor\n%           endif\n%       endif\n!\n%   endfor\n%endif\n## eos - VLAN Interfaces\n% if config.get(\"vlan_interfaces\") is not None:\n%   for vlan_interface in natural_sort(config.get(\"vlan_interfaces\").keys()):\ninterface ${ vlan_interface }\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"description\") is not None:\ndescription ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"description\") }\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"shutdown\") == True:\nshutdown\n%     elif config.get(\"vlan_interfaces\")[vlan_interface].get(\"shutdown\") == False:\nno shutdown\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"mtu\") is not None:\nmtu ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"mtu\") }\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"no_autostate\") == True:\nno autostate\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"vrf\") is not None:\nvrf ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"vrf\") }\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address\") is not None:\nip address ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address\") }\n%         if config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address_secondaries\") is not None:\n%             for ip_address_secondary in config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address_secondaries\"):\nip address ${ ip_address_secondary } secondary\n%             endfor\n%         endif\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_virtual_router_address\") is not None:\nip virtual-router address ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_virtual_router_address\") }\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address_virtual\") is not None:\nip address virtual ${ config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_address_virtual\") }\n%     endif\n%     if config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_helpers\") is not None:\n%       for ip_helper in config.get(\"vlan_interfaces\")[vlan_interface].get(\"ip_helpers\").keys():\n<%        ip_helper_cli = \"ip helper-address \" + ip_helper %>\n%         if config.get(\"vlan_interfaces\")[vlan_interface][\"ip_helpers\"][ip_helper].get(\"vrf\") is not None:\n<%            ip_helper_cli = ip_helper_cli + \" vrf \" + config.get(\"vlan_interfaces\")[vlan_interface][\"ip_helpers\"][ip_helper].get(\"vrf\") %>\n%         endif\n%         if config.get(\"vlan_interfaces\")[vlan_interface][\"ip_helpers\"][ip_helper].get(\"source_interface\") is not None:\n<%            ip_helper_cli = ip_helper_cli + \" source-interface \" + config.get(\"vlan_interfaces\")[vlan_interface][\"ip_helpers\"][ip_helper].get(\"source_interface\") %>\n%         endif %}\n${ ip_helper_cli }\n%       endfor\n%      endif\n!\n%   endfor\n% endif\n## vxlan-interfaces\n% if config.get(\"vxlan_tunnel_interface\"):\ninterface Vxlan1\n%     if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"].get(\"source_interface\"):\nvxlan source-interface ${ config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"source_interface\"] }\n%     endif\n%     if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"].get(\"virtual_router\"):\nvxlan virtual-router encapsulation mac-address ${ config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"virtual_router\"][\"encapsulation_mac_address\"] }\n%     endif\n%     if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"].get(\"vxlan_udp_port\"):\nvxlan udp-port ${ config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_udp_port\"] }\n%     endif\n%     if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"].get(\"vxlan_vni_mappings\"):\n%       if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"].get(\"vlans\"):\n%           for vlan in config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"][\"vlans\"].keys():\nvxlan vlan ${ vlan } vni ${ config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"][\"vlans\"][vlan][\"vni\"] }\n%           endfor\n%       endif\n%       if config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"].get(\"vrfs\"):\n%           for vrf in config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"][\"vrfs\"].keys():\nvxlan vrf ${ vrf } vni ${ config[\"vxlan_tunnel_interface\"][\"Vxlan1\"][\"vxlan_vni_mappings\"][\"vrfs\"][vrf][\"vni\"] }\n%           endfor %}\n%       endif\n%     endif\n!\n% endif\n## eos - tcam profile\n% if config.get(\"tcam_profile\") is not None:\nhardware tcam\n%     if config[\"tcam_profile\"].get(\"profiles\") is not None:\n%         for profile in config[\"tcam_profile\"][\"profiles\"].keys():\nprofile ${ profile }\n${ config[\"tcam_profile\"][\"profiles\"][profile] }\n!\n%         endfor\n%     endif\n%     if config[\"tcam_profile\"].get(\"system\") is not None:\nsystem profile ${ config[\"tcam_profile\"][\"system\"] }\n%     endif\n!\n% endif\n## eos - ip virtual router mac\n% if config.get(\"ip_virtual_router_mac_address\") is not None:\nip virtual-router mac-address ${ config[\"ip_virtual_router_mac_address\"] }\n!\n% endif\n## eos - IP Routing \n% if config.get(\"ip_routing\") == True:\nip routing\n!\n% elif config.get(\"ip_routing\") == False:\nno ip routing\n!\n% endif\n## eos - VRFs\n% if config.get(\"vrfs\") is not None:\n%   for vrf in config.get(\"vrfs\"):\n%       if config.get(\"vrfs\")[vrf].get(\"ip_routing\") is not None and config.get(\"vrfs\")[vrf].get(\"ip_routing\") == True  and vrf != 'default':\nip routing vrf ${ vrf }\n%       elif config.get(\"vrfs\")[vrf].get(\"ip_routing\") is not None and config.get(\"vrfs\")[vrf].get(\"ip_routing\") == False  and vrf != 'default':\nno ip routing vrf ${ vrf }\n%       endif\n%   endfor\n!\n% endif\n## eos - prefix-lists\n% if config.get(\"prefix_lists\") is not None:\n%    for prefix_list in config[\"prefix_lists\"].keys():\nip prefix-list ${ prefix_list }\n%       for sequence in config[\"prefix_lists\"][prefix_list][\"sequence_numbers\"].keys():\n%         if config[\"prefix_lists\"][prefix_list][\"sequence_numbers\"][sequence].get(\"action\") is not None:\nseq ${ sequence } ${ config[\"prefix_lists\"][prefix_list][\"sequence_numbers\"][sequence][\"action\"] }\n%         endif\n%       endfor\n!\n%    endfor\n% endif\n## eos - mlag configuration\n% if config.get(\"mlag_configuration\") is not None and config[\"mlag_configuration\"].get(\"enabled\") == True:\nmlag configuration\n%     if config[\"mlag_configuration\"].get(\"domain_id\") is not None:\ndomain-id ${ config[\"mlag_configuration\"][\"domain_id\"] }\n%     endif\n%     if config[\"mlag_configuration\"].get(\"local_interface\") is not None:\nlocal-interface ${ config[\"mlag_configuration\"][\"local_interface\"] }\n%     endif\n%     if config[\"mlag_configuration\"].get(\"peer_address\") is not None:\npeer-address ${ config[\"mlag_configuration\"][\"peer_address\"] }\n%     endif\n%     if config[\"mlag_configuration\"].get(\"peer_address_heartbeat\") is not None:\n%       if config[\"mlag_configuration\"][\"peer_address_heartbeat\"].get(\"peer_ip\") is not None:\n%           if config[\"mlag_configuration\"][\"peer_address_heartbeat\"].get(\"vrf\") is not None and config[\"mlag_configuration\"][\"peer_address_heartbeat\"].get(\"vrf\") != 'default':\npeer-address heartbeat ${ config[\"mlag_configuration\"][\"peer_address_heartbeat\"][\"peer_ip\"] } vrf ${ config[\"mlag_configuration\"][\"peer_address_heartbeat\"][\"vrf\"] }\n## using the default VRF #}\n%           else:\npeer-address heartbeat ${ config[\"mlag_configuration\"][\"peer_address_heartbeat\"][\"peer_ip\"] }\n%           endif\n%       endif\n%     endif\n%     if config[\"mlag_configuration\"].get(\"peer_link\") is not None:\npeer-link ${ config[\"mlag_configuration\"][\"peer_link\"] }\n%     endif\n%     if config[\"mlag_configuration\"].get(\"dual_primary_detection_delay\") is not None:\ndual-primary detection delay ${ config[\"mlag_configuration\"][\"dual_primary_detection_delay\"] } action errdisable all-interfaces\n%     endif\n%     if config[\"mlag_configuration\"].get(\"reload_delay_mlag\") is not None:\nreload-delay mlag ${ config[\"mlag_configuration\"][\"reload_delay_mlag\"] }\n%     endif\n%     if config[\"mlag_configuration\"].get(\"reload_delay_non_mlag\") is not None:\nreload-delay non-mlag ${ config[\"mlag_configuration\"][\"reload_delay_non_mlag\"] }\n%     endif\n!\n% endif\n## eos - Route Maps\n% if config.get(\"route_maps\") is not None:\n%   for route_map in config[\"route_maps\"].keys():\n%       for sequence in config[\"route_maps\"][route_map][\"sequence_numbers\"].keys():\n%           if config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence].get(\"type\") is not None:\nroute-map ${ route_map } ${ config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence][\"type\"] } ${ sequence }\n%               if config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence].get(\"description\") is not None:\ndescription ${ config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence][\"description\"] }\n%               endif\n%               if config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence].get(\"match\") is not None:\n%                   for match_rule in config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence][\"match\"]:\nmatch ${ match_rule }\n%                   endfor\n%               endif\n%               if config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence].get(\"set\") is not None:\n%                   for set_rule in config[\"route_maps\"][route_map][\"sequence_numbers\"][sequence][\"set\"]:\nset ${ set_rule }\n%                   endfor\n%               endif\n!\n%           endif\n%       endfor\n%   endfor\n% endif\n## eos - peer-filters\n% if config.get(\"peer_filters\") is not None:\n%   for peer_filter in config[\"peer_filters\"].keys():\npeer-filter ${ peer_filter }\n%     for sequence in config[\"peer_filters\"][peer_filter][\"sequence_numbers\"].keys():\n%         if config[\"peer_filters\"][peer_filter][\"sequence_numbers\"][sequence].get(\"match\") is not None:\n${ sequence } match ${ config[\"peer_filters\"][peer_filter][\"sequence_numbers\"][sequence][\"match\"] }\n%         endif\n%     endfor\n!\n%   endfor\n% endif\n## eos - Router BGP\n% if config.get(\"router_bgp\") is not None:\n% if config[\"router_bgp\"].get(\"as\") is not None:\nrouter bgp ${ config[\"router_bgp\"][\"as\"] }\n%     if config[\"router_bgp\"].get(\"router_id\") is not None:\nrouter-id ${ config[\"router_bgp\"][\"router_id\"] }\n%     endif\n%     if config[\"router_bgp\"].get(\"maximum_paths\"):\n<% max_paths_cli = \"maximum-paths {} \".format(config[\"router_bgp\"][\"maximum_paths\"]) %>\n%        if config[\"router_bgp\"].get(\"ecmp\"):\n<% max_paths_cli += \"ecmp {}\".format(config[\"router_bgp\"][\"ecmp\"]) %>\n        % endif\n${max_paths_cli}\n%     endif\n%     if config[\"router_bgp\"].get(\"bgp_defaults\") is not None:\n%       for bgp_default in config[\"router_bgp\"][\"bgp_defaults\"]:\n${ bgp_default }\n%       endfor\n%     endif\n%     if config[\"router_bgp\"].get(\"peer_groups\") is not None:\n%       for peer_group in config[\"router_bgp\"][\"peer_groups\"].keys():\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"bgp_listen_range_prefix\") is not None and config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"peer_filter\") is not None:\nbgp listen range ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"bgp_listen_range_prefix\"] } peer-group ${ peer_group } peer-filter ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"peer_filter\"] }\n%         endif\n%       endfor\n%     for peer_group in config[\"router_bgp\"][\"peer_groups\"].keys():\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"description\") is not None:\nneighbor ${ peer_group } description ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"description\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"shutdown\") == True:\nneighbor ${ peer_group } shutdown\n%         endif\nneighbor ${ peer_group } peer group\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"remote_as\") is not None:\nneighbor ${ peer_group } remote-as ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"remote_as\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"local_as\") is not None:\nneighbor ${ peer_group } local-as ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"local_as\"] } no-prepend replace-as\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"next_hop_self\") == True:\nneighbor ${ peer_group } next-hop-self\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"next_hop_unchanged\") == True:\nneighbor ${ peer_group } next-hop-unchanged\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"update_source\") is not None:\nneighbor ${ peer_group } update-source ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"update_source\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"route_reflector_client\") == True:\nneighbor ${ peer_group } route-reflector-client\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"bfd\") == True:\nneighbor ${ peer_group } bfd\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"ebgp_multihop\") is not None:\nneighbor ${ peer_group } ebgp-multihop ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"ebgp_multihop\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"password\") is not None:\nneighbor ${ peer_group } password 7 ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"password\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"send_community\") is not None and config[\"router_bgp\"][\"peer_groups\"][peer_group][\"send_community\"] == \"all\":\nneighbor ${ peer_group } send-community\n%         elif config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"send_community\") is not None:\nneighbor ${ peer_group } send-community ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"send_community\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"maximum_routes\") is not None and config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"maximum_routes_warning_limit\") is not None:\nneighbor ${ peer_group } maximum-routes ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"maximum_routes\"] } warning-limit ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"maximum_routes_warning_limit\"] }\n%         elif config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"maximum_routes\") is not None:\nneighbor ${ peer_group } maximum-routes ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"maximum_routes\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"weight\") is not None:\nneighbor ${ peer_group } weight ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"weight\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"timers\") is not None:\nneighbor ${ peer_group } timers ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"timers\"] }\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"route_map_in\") is not None:\nneighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"route_map_in\"] } in\n%         endif\n%         if config[\"router_bgp\"][\"peer_groups\"][peer_group].get(\"route_map_out\") is not None:\nneighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"peer_groups\"][peer_group][\"route_map_out\"] } out\n%         endif\n%       endfor\n%     endif\n## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}\n## {%         set neighbor_interface_cli = \"neighbor interface \" ~ neighbor_interface %}\n## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}\n## {%             set neighbor_interface_cli = neighbor_interface_cli ~ \" peer-group \" ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}\n## {%         endif %}\n## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}\n## {%             set neighbor_interface_cli = neighbor_interface_cli ~ \" remote-as \" ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}\n## {%         endif %}\n## ##    {{ neighbor_interface_cli }}\n## {%     endfor %}\n%     if config[\"router_bgp\"].get(\"neighbors\") is not None:\n%       for neighbor in natural_sort(config[\"router_bgp\"][\"neighbors\"].keys()):\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"peer_group\") is not None:\nneighbor ${ neighbor } peer group ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"peer_group\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"remote_as\") is not None:\nneighbor ${ neighbor } remote-as ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"remote_as\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"next_hop_self\") == True:\nneighbor ${ neighbor } next-hop-self\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"shutdown\") == True:\nneighbor ${ neighbor } shutdown\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"local_as\") is not None:\nneighbor ${ neighbor } local-as ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"local_as\"] } no-prepend replace-as\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"description\") is not None:\nneighbor ${ neighbor } description ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"description\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"update_source\") is not None:\nneighbor ${ neighbor } update-source ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"update_source\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"bfd\") == True:\nneighbor ${ neighbor } bfd\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"password\") is not None:\nneighbor ${ neighbor } password 7 ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"password\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"weight\") is not None:\nneighbor ${ neighbor } weight ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"weight\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"timers\") is not None:\nneighbor ${ neighbor } timers ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"timers\"] }\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"route_map_in\") is not None:\nneighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"route_map_in\"] } in\n%         endif\n%         if config[\"router_bgp\"][\"neighbors\"][neighbor].get(\"route_map_out\") is not None:\nneighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"neighbors\"][neighbor][\"route_map_out\"] } out\n%         endif\n%       endfor\n%     endif\n## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}\n## {%         set aggregate_address_cli = \"aggregate-address \" ~ aggregate_address %}\n## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}\n## {%             set aggregate_address_cli = aggregate_address_cli ~ \" as-set\" %}\n## {%         endif %}\n## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}\n## {%             set aggregate_address_cli = aggregate_address_cli ~ \" summary-only\" %}\n## {%         endif %}\n## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}\n## {%             set aggregate_address_cli = aggregate_address_cli ~  \" attribute-map \" ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}\n## {%         endif %}\n## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}\n## {%             set aggregate_address_cli = aggregate_address_cli ~ \" match-map \" ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}\n## {%         endif %}\n## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}\n## {%             set aggregate_address_cli = aggregate_address_cli ~ \" advertise-only\" %}\n## {%         endif %}\n##    {{ aggregate_address_cli }}\n## {%     endfor %}\n%     if config[\"router_bgp\"].get(\"redistribute_routes\") is not None:\n%       for redistribute_route in config[\"router_bgp\"][\"redistribute_routes\"].keys():\n<%         redistribute_route_cli = \"redistribute \" + redistribute_route %>\n%         if config[\"router_bgp\"][\"redistribute_routes\"][redistribute_route].get(\"route_map\") is not None:\n<%             redistribute_route_cli = redistribute_route_cli + \" route-map \" + config[\"router_bgp\"][\"redistribute_routes\"][redistribute_route][\"route_map\"] %>\n%         endif\n${ redistribute_route_cli }\n%       endfor\n%     endif\n## L2VPNs - (vxlan) vlan based\n%     if config[\"router_bgp\"].get(\"vlans\") is not None:\n%       for vlan in config[\"router_bgp\"][\"vlans\"]:\n!\nvlan ${ vlan }\n%         if config[\"router_bgp\"][\"vlans\"][vlan].rd is not None:\n    rd ${ config[\"router_bgp\"][\"vlans\"][vlan].rd }\n%         endif\n%         if config[\"router_bgp\"][\"vlans\"][vlan].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"].get(\"both\") is not None:\n%             for route_target in config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"][\"both\"]:\n    route-target both ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlans\"][vlan].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"].get(\"import\") is not None:\n%             for route_target in config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"][\"import\"]:\n    route-target import ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlans\"][vlan].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"].get(\"export\") is not None:\n%             for route_target in config[\"router_bgp\"][\"vlans\"][vlan][\"route_targets\"][\"export\"]:\n    route-target export ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlans\"][vlan].get(\"redistribute_routes\") is not None:\n%           for redistribute_route in config[\"router_bgp\"][\"vlans\"][vlan][\"redistribute_routes\"]:\n    redistribute ${ redistribute_route }\n%           endfor\n%         endif\n%       endfor\n## vxlan vlan aware bundles\n%       if config[\"router_bgp\"].get(\"vlan_aware_bundles\") is not None:\n%         for vlan_aware_bundle in config[\"router_bgp\"][\"vlan_aware_bundles\"].keys():\n!\nvlan-aware-bundle ${ vlan_aware_bundle }\n%         if  config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"rd\") is not None:\n    rd ${  config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"rd\"] }\n%         endif\n%         if config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"].get(\"both\") is not None:\n%             for route_target in  config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"][\"both\"]:\n    route-target both ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"].get(\"import\") is not None:\n%             for route_target in config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"][\"import\"]:\n    route-target import ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"].get(\"export\") is not None:\n%             for route_target in  config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"route_targets\"][\"export\"]:\n    route-target export ${ route_target }\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"redistribute_routes\") is not None:\n%           for redistribute_route in config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"redistribute_routes\"]:\n    redistribute ${ redistribute_route }\n%           endfor %}\n%         endif\n%         if config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle].get(\"vlan\") is not None:\n    vlan ${ config[\"router_bgp\"][\"vlan_aware_bundles\"][vlan_aware_bundle][\"vlan\"] }\n%         endif\n%         endfor\n%       endif\n%     endif\n## address families activation\n## address family evpn activation ##\n%     if config[\"router_bgp\"].get(\"address_family_evpn\") is not None:\n!\naddress-family evpn\n%         if config[\"router_bgp\"][\"address_family_evpn\"].get(\"evpn_hostflap_detection\") is not None and config[\"router_bgp\"][\"address_family_evpn\"][\"evpn_hostflap_detection\"].get(\"enabled\") == False:\n    no host-flap detection\n%         else:\n%             if config[\"router_bgp\"][\"address_family_evpn\"].get(\"evpn_hostflap_detection\") is not None and config[\"router_bgp\"][\"address_family_evpn\"][\"evpn_hostflap_detection\"].get(\"window\") is not None:\n    host-flap detection window ${ config[\"router_bgp\"][\"address_family_evpn\"][\"evpn_hostflap_detection\"][\"window\"] }\n%             endif\n%             if config[\"router_bgp\"][\"address_family_evpn\"].get(\"evpn_hostflap_detection\") is not None and config[\"router_bgp\"][\"address_family_evpn\"][\"evpn_hostflap_detection\"].get(\"threshold\") is not None:\n    host-flap detection threshold ${ config[\"router_bgp\"][\"address_family_evpn\"][\"evpn_hostflap_detection\"][\"threshold\"] }\n%             endif\n%         endif\n%         if config[\"router_bgp\"][\"address_family_evpn\"].get(\"domain_identifier\") is not None:\n    domain identifier ${ config[\"router_bgp\"][\"address_family_evpn\"][\"domain_identifier\"] }\n%         endif\n%         if config[\"router_bgp\"][\"address_family_evpn\"].get(\"peer_groups\") is not None:\n%           for peer_group in config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"].keys():\n%             if config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group].get(\"route_map_in\") is not None:\n    neighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group][\"route_map_in\"] } in\n%             endif\n%             if config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group].get(\"route_map_out\") is not None:\n    neighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group][\"route_map_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group].get(\"activate\") == True:\n    neighbor ${ peer_group } activate\n%             elif config[\"router_bgp\"][\"address_family_evpn\"][\"peer_groups\"][peer_group].get(\"activate\") == False:\n    no neighbor ${ peer_group } activate\n%             endif\n%           endfor\n%         endif\n%     endif\n## {# address family rt-membership activation #}\n## {%     if router_bgp.address_family_rtc is arista.avd.defined %}\n##    !\n##    address-family rt-membership\n## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}\n##       neighbor ${ peer_group } activate\n## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}\n##       no neighbor ${ peer_group } activate\n## {%             endif %}\n## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}\n## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}\n##       neighbor ${ peer_group } default-route-target only\n## {%                 else %}\n##       neighbor ${ peer_group } default-route-target\n## {%                 endif %}\n## {%             endif %}\n## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}\n##       neighbor ${ peer_group } default-route-target encoding origin-as omit\n## {%             endif %}\n## {%         endfor %}\n## {%     endif %}\n## address family ipv4 activation\n%     if config[\"router_bgp\"].get(\"address_family_ipv4\") is not None:\n!\naddress-family ipv4\n%       if config[\"router_bgp\"][\"address_family_ipv4\"].get(\"networks\") is not None:\n%         for network in config[\"router_bgp\"][\"address_family_ipv4\"][\"networks\"].keys():\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"networks\"][network].get(\"route_map\") is not None:\n    network ${ network } route-map ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"networks\"][network][\"route_map\"] }\n%             else:\n    network ${ network }\n%             endif\n%         endfor\n%       endif\n%       if config[\"router_bgp\"][\"address_family_ipv4\"].get(\"peer_groups\") is not None:\n%           for peer_group in config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"].keys():\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"route_map_in\") is not None:\n    neighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group][\"route_map_in\"] } in\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"route_map_out\") is not None:\n    neighbor ${ peer_group } route-map ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group][\"route_map_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"prefix_list_in\") is not None:\n    neighbor ${ peer_group } prefix-list ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group][\"prefix_list_in\"] } in\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"prefix_list_out\") is not None:\n    neighbor ${ peer_group } prefix-list ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group][\"prefix_list_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"activate\") == True:\n    neighbor ${ peer_group } activate\n%             elif config[\"router_bgp\"][\"address_family_ipv4\"][\"peer_groups\"][peer_group].get(\"activate\") == False:\n    no neighbor ${ peer_group } activate\n%             endif\n%           endfor\n%       endif\n%       if config[\"router_bgp\"][\"address_family_ipv4\"].get(\"neighbors\") is not None:\n%           for neighbor in config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"].keys():\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"route_map_in\") is not None:\n    neighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"route_map_in\"] } in\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"route_map_out\") is not None:\n    neighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"route_map_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"prefix_list_in\") is not None:\n    neighbor ${ neighbor } prefix-list ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"prefix_list_in\"] } in\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"prefix_list_out\") is not None:\n    neighbor ${ neighbor } prefix-list ${ config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"prefix_list_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"default_originate\") is not None:\n<%                 neighbor_default_originate_cli = \"neighbor \" + neighbor + \" default-originate\" %>\n%                 if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"default_originate\"].get(\"route_map\") is not None:\n<%                     neighbor_default_originate_cli = neighbor_default_originate_cli + \" route-map \" + config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"default_originate\"][\"route_map\"] %>\n%                 endif\n%                 if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor][\"default_originate\"].get(\"always\") == True:\n<%                     neighbor_default_originate_cli = neighbor_default_originate_cli + \" always\" %>\n%                 endif\n    ${ neighbor_default_originate_cli }\n%             endif\n%             if config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"activate\") == True:\n    neighbor ${ neighbor } activate\n%             elif config[\"router_bgp\"][\"address_family_ipv4\"][\"neighbors\"][neighbor].get(\"activate\") == False:\n    no neighbor ${ neighbor } activate\n%             endif\n%           endfor\n%       endif\n%     endif\n## {# address family ipv4 multicast activation #}\n## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}\n##    !\n##    address-family ipv4 multicast\n## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}\n##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}\n##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}\n##       neighbor ${ peer_group } activate\n## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}\n##       no neighbor ${ peer_group } activate\n## {%             endif %}\n## {%         endfor %}\n## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}\n##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}\n##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}\n##       neighbor {{ neighbor }} activate\n## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}\n##       no neighbor {{ neighbor }} activate\n## {%             endif %}\n## {%         endfor %}\n## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}\n## {%             set redistribute_route_cli = \"redistribute \" ~ redistribute_route %}\n## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}\n## {%                 set redistribute_route_cli = redistribute_route_cli ~ \" route-map \" ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}\n## {%             endif %}\n##       {{ redistribute_route_cli }}\n## {%         endfor %}\n## {%     endif %}\n## {# address family ipv6 activation #}\n## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}\n##    !\n##    address-family ipv6\n## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}\n##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}\n## {%             else %}\n##       network {{ network }}\n## {%             endif %}\n## {%         endfor %}\n## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}\n##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}\n##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}\n##       neighbor ${ peer_group } activate\n## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}\n##       no neighbor ${ peer_group } activate\n## {%             endif %}\n## {%         endfor %}\n## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}\n##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}\n##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out\n## {%             endif %}\n## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}\n##       neighbor {{ neighbor }} activate\n## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}\n##       no neighbor {{ neighbor }} activate\n## {%             endif %}\n## {%         endfor %}\n## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}\n## {%             set redistribute_route_cli = \"redistribute \" ~ redistribute_route %}\n## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}\n## {%                 set redistribute_route_cli = redistribute_route_cl ~ \" route-map \" ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}\n## {%             endif %}\n##       {{ redistribute_route_cli }}\n## {%         endfor %}\n## {%     endif %}\n## {# address family vpn-ipv4 activation #}\n## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}\n##    !\n##    address-family vpn-ipv4\n## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}\n##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}\n## {%         endif %}\n## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}\n##       neighbor ${ peer_group } activate\n## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}\n##       no neighbor ${ peer_group } activate\n## {%             endif %}\n## {%         endfor %}\n## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}\n## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}\n##       neighbor {{ neighbor }} activate\n## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}\n##       no neighbor {{ neighbor }} activate\n## {%             endif %}\n## {%         endfor %}\n## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}\n##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}\n## {%         endif %}\n## {%     endif %}\n## L3VPNs - (vxlan) VRFs\n%     if config[\"router_bgp\"].get(\"vrfs\") is not None:\n%       for vrf in config[\"router_bgp\"][\"vrfs\"].keys():\n!\nvrf ${ vrf }\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"rd\") is not None:\n    rd ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"rd\"] }\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"].get(\"import\") is not None:\n%             for address_family in config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"][\"import\"].keys():\n%                 for route_target in config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"][\"import\"][address_family]:\n    route-target import ${ address_family } ${ route_target }\n%                 endfor\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"route_targets\") is not None and config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"].get(\"export\") is not None:\n%             for address_family in config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"][\"export\"].keys():\n%                 for route_target in config[\"router_bgp\"][\"vrfs\"][vrf][\"route_targets\"][\"export\"][address_family]:\n    route-target export ${ address_family } ${ route_target }\n%                 endfor\n%             endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"router_id\") is not None:\n    router-id ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"router_id\"] }\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"timers\") is not None:\n    timers bgp ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"timers\"] }\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"networks\") is not None:\n%           for network in config[\"router_bgp\"][\"vrfs\"][vrf][\"networks\"].keys():\n%             if config[\"router_bgp\"][\"vrfs\"][vrf].networks[network].get(\"route_map\") is not None:\n    network ${ network } route-map ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"networks\"][network][\"route_map\"] }\n%             else:\n    network ${ network }\n%             endif\n%           endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"neighbors\") is not None:\n%           for neighbor in config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"].keys():\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"remote_as\") is not None:\n    neighbor ${ neighbor } remote-as ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"remote_as\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"peer_group\") is not None:\n    neighbor ${ neighbor } peer group ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"peer_group\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"password\") is not None:\n    neighbor ${ neighbor } password 7 ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"password\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"local_as\") is not None:\n    neighbor ${ neighbor } local-as ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"local_as\"] } no-prepend replace-as\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"description\") is not None:\n    neighbor ${ neighbor } description ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"description\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"ebgp_multihop\") is not None:\n<%                 neighbor_ebgp_multihop_cli = \"neighbor \" + neighbor + \" ebgp-multihop\" %>\n%                 if type(config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"ebgp_multihop\"]) is int:\n<%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + \" \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"ebgp_multihop\"] %>\n%                 endif\n    ${ neighbor_ebgp_multihop_cli }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"next_hop_self\") == True:\n    neighbor ${ neighbor } next-hop-self\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"timers\") is not None:\n    neighbor ${ neighbor } timers ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"timers\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"send_community\") is not None and config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"send_community\"] == \"all\":\n    neighbor ${ neighbor } send-community\n%             elif config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"send_community\") is not None:\n    neighbor ${ neighbor } send-community ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"send_community\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"maximum_routes\") is not None:\n    neighbor ${ neighbor } maximum-routes ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"maximum_routes\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"default_originate\") is not None:\n<%                neighbor_default_originate_cli = \"neighbor \" + neighbor + \" default-originate\" %>\n%                 if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"default_originate\"].get(\"route_map\") is not None:\n<%                    neighbor_default_originate_cli = neighbor_default_originate_cli + \" route-map \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"default_originate\"][\"route_map\"] %>\n%                 endif\n%                 if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"default_originate\"].get(\"always\") == True:\n<%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ \" always\" %>\n%                 endif\n    ${ neighbor_default_originate_cli }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"update_source\") is not None:\n    neighbor ${ neighbor } update-source ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"update_source\"] }\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"route_map_out\") is not None:\n    neighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"route_map_out\"] } out\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor].get(\"route_map_in\") is not None:\n    neighbor ${ neighbor } route-map ${ config[\"router_bgp\"][\"vrfs\"][vrf][\"neighbors\"][neighbor][\"route_map_in\"] } in\n%             endif\n%           endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"redistribute_routes\") is not None:\n%           for redistribute_route in config[\"router_bgp\"][\"vrfs\"][vrf][\"redistribute_routes\"].keys():\n<%             redistribute_cli = \"redistribute \" + redistribute_route %>\n%              if config[\"router_bgp\"][\"vrfs\"][vrf][\"redistribute_routes\"][redistribute_route].get(\"route_map\") is not None:\n<%                 redistribute_cli = redistribute_cli + \" route-map \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"redistribute_routes\"][redistribute_route][\"route_map\"] %>\n%              endif\n    ${ redistribute_cli }\n%           endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"aggregate_addresses\") is not None:\n%           for aggregate_address in config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"].keys():\n<%             aggregate_address_cli = \"aggregate-address \" + aggregate_address %>\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address].get(\"as_set\") == True:\n<%                 aggregate_address_cli = aggregate_address_cli + \" as-set\" %>\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address].get(\"summary_only\") == True:\n<%                  aggregate_address_cli = aggregate_address_cli + \" summary-only\" %>\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address].get(\"attribute_map\") is not None:\n<%                  aggregate_address_cli = aggregate_address_cli + \" attribute-map \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address][\"attribute_map\"] %>\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address].get(\"match_map\") is not None:\n<%                  aggregate_address_cli = aggregate_address_cli + \" match-map \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address][\"match_map\"] %>\n%             endif\n%             if config[\"router_bgp\"][\"vrfs\"][vrf][\"aggregate_addresses\"][aggregate_address].get(\"advertise_only\") == True:\n<%                 aggregate_address_cli = aggregate_address_cli + \" advertise-only\" %>\n%             endif\n    ${ aggregate_address_cli }\n%           endfor\n%         endif\n%         if config[\"router_bgp\"][\"vrfs\"][vrf].get(\"address_families\") is not None:\n%           for  address_family in config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"].keys():\n    !\n    address-family ${ address_family }\n%             for neighbor in config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"][address_family][\"neighbors\"].keys():\n%                 if config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"][address_family][\"neighbors\"][neighbor].get(\"activate\") == True:\n        neighbor ${ neighbor } activate\n%                 endif\n%             endfor\n%             for network in config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"][address_family][\"networks\"].keys():\n<%                network_cli = \"network \" + network %>\n%                 if config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"][address_family][\"networks\"][network].get(\"route_map\") is not None:\n<%                     network_cli = network_cli + \" route-map \" + config[\"router_bgp\"][\"vrfs\"][vrf][\"address_families\"][address_family][\"networks\"][network][\"route_map\"] %>\n%                 endif\n        ${ network_cli }\n%             endfor\n%           endfor\n%         endif\n%       endfor\n%     endif\n!\n% endif\n% endif\n"
            input_schema:
                fields:
                    values:
                        mlagLinkSubnet:
                            id: mlagLinkSubnet
                            name: mlagPeerLinkSubnet
                            label: 'MLAG Peer Link Subnet'
                            description: 'Define the subnet from which to allocate IP addresses for the MLAG source interfaces.  By setting a subnet with a subnet mask of 30 or 31, you will re-use the same IP addresses for MLAG source interfaces across all leaf MLAG pairs in your network. To use unique IP addresses for every MLAG source interface, enter a subnet with a subnet mask less than 30'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 192.168.255.254/31
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        internalVlan:
                            id: internalVlan
                            name: mlagVlan
                            label: 'MLAG Peer Link VLAN'
                            description: 'Define the VLAN ID to use for MLAG peer communication'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '4094'
                                range: null
                                static_options: null
                                dynamic_options: null
                        mlagPortChannelId:
                            id: mlagPortChannelId
                            name: mlagPortChannelId
                            label: 'MLAG Port Channel ID'
                            description: 'Define the VLAN ID to use for MLAG peer communication'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '2000'
                                range: null
                                static_options: null
                                dynamic_options: null
                        virtualRouterMac:
                            id: virtualRouterMac
                            name: virtualRouterMacAddress
                            label: 'Virtual Router MAC Address'
                            description: 'Assign a virtual MAC address for redundant host and switch connections'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '00:1c:73:00:00:99'
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        mlagSubnetMask:
                            id: mlagSubnetMask
                            name: mlagSubnetMask
                            label: 'MLAG Subnet Mask'
                            description: 'Set the subnet mask for the MLAG interface connections in the fabric'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: '31'
                                range: null
                                static_options:
                                    values:
                                        - '31'
                                        - '30'
                                dynamic_options: null
                        lacpMode:
                            id: lacpMode
                            name: lacpMode
                            label: 'LACP Mode'
                            description: 'Define the LACP mode used for member interfaces of the MLAG peer link port channel'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: active
                                static_options:
                                    values:
                                        - active
                                        - passive
                                        - 'on (static)'
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        commonMlagConfig:
                            id: commonMlagConfig
                            name: commonMlagConfig
                            label: 'MLAG Configuration'
                            description: 'Configure the parameters for the MLAG pairs in this Pod.'
                            required: true
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - mlagLinkSubnet
                                        - internalVlan
                                        - mlagPortChannelId
                                        - virtualRouterMac
                                        - mlagSubnetMask
                                        - lacpMode
                        spineAS:
                            id: spineAS
                            name: spineAsn
                            label: 'Spine ASN'
                            description: 'Define the BGP ASN assigned to spine switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '65000'
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafASbase:
                            id: leafASbase
                            name: leafAsnRange
                            label: 'Leaf ASN Range'
                            description: 'Define the BGP ASN range used to assign ASNs to leaf switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 65001-65535
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        spineLoopback0Subnet:
                            id: spineLoopback0Subnet
                            name: spineLoopback0Subnet
                            label: 'Spine Router ID Subnet'
                            description: 'Define the subnet from which IP addresses are allocated to each spine''s Loopback0 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.0.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafLoopback0Subnet:
                            id: leafLoopback0Subnet
                            name: leafLoopback0Subnet
                            label: 'Leaf Router ID Subnet'
                            description: 'Define the subnet from which IP addresses are allocated to each leaf''s Loopback0 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.0.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        spineBGPDynamicNeighbors:
                            id: spineBGPDynamicNeighbors
                            name: spineBGPDynamicNeighbors
                            label: 'Spine BGP Dynamic Neighbors'
                            description: 'Enable to set up dynamic BGP peering on the spine switches'
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        evpnEnabled:
                            id: evpnEnabled
                            name: evpnEnabled
                            label: 'BGP EVPN Enabled'
                            description: 'Enable to form EVPN adjacencies for the control plane of a VXLAN overlay'
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        commonBGPConfig:
                            id: commonBGPConfig
                            name: commonBGPConfig
                            label: 'BGP Configuration'
                            description: 'Configure the BGP settings for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - spineAS
                                        - leafASbase
                                        - spineLoopback0Subnet
                                        - leafLoopback0Subnet
                                        - spineBGPDynamicNeighbors
                                        - evpnEnabled
                        spineNotes:
                            id: spineNotes
                            name: spineNotes
                            label: Notes
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        spines:
                            id: spines
                            name: spines
                            label: Spines
                            description: 'Specify the spine switches in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: spineNotes
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: device
                                tag_filter_query: 'Role:Spine '
                        asNumber:
                            id: asNumber
                            name: asn
                            label: ASN
                            description: 'Override the automatic ASN allocation for this leaf domain by entering a value.'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: null
                                range: null
                                static_options: null
                                dynamic_options: null
                        leafNotes:
                            id: leafNotes
                            name: leafNotes
                            label: Notes
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        leafDetails:
                            id: leafDetails
                            name: l3LeafDetails
                            label: 'L3 Leaf Details'
                            description: 'Summary of leaf devices in this leaf domain.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: leafNotes
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: device
                                tag_filter_query: null
                        leafDomain:
                            id: leafDomain
                            name: l3LeafDomain
                            label: 'Leaf Domain'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - asNumber
                                        - leafDetails
                        leafDomains:
                            id: leafDomains
                            name: LeafDomains
                            label: 'Leaf Domains'
                            description: 'Specify the MLAG pairs or standalone leaf switches in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: leafDomain
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: Leaf-Domain
                                tag_filter_query: null
                        spanningTreeMode:
                            id: spanningTreeMode
                            name: spanningTreeMode
                            label: 'Spanning Tree Mode'
                            description: 'Select the spanning tree mode for devices in this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options:
                                    values:
                                        - MSTP
                                        - Rapid-PVST
                                        - RSTP
                                        - None
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        fabricSubnetMask:
                            id: fabricSubnetMask
                            name: underlayFabricSubnetMask
                            label: 'Fabric Subnet Mask'
                            description: 'Set the subnet mask for the transit connections in the fabric'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: '31'
                                static_options:
                                    values:
                                        - '30'
                                        - '31'
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        underlayRoutingProtocol:
                            id: underlayRoutingProtocol
                            name: underlayRoutingProtocol
                            label: 'Routing Protocol'
                            description: 'Set the routing protocol used for underlay connectivity'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options:
                                    values:
                                        - BGP
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        fabricLinksSubnet:
                            id: fabricLinksSubnet
                            name: underlayFabricSubnet
                            label: 'Fabric Subnet'
                            description: 'Define a subnet in CIDR notation for the IP transit links for use by all spines or create a list of subnets so that each spine uses one subnet for IP allocation. If creating a list, separate each subnet with a comma'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.200.0/24
                                static_options: null
                                format: null
                                length: null
                                pattern: null
                                dynamic_options: null
                        underlayRouting:
                            id: underlayRouting
                            name: underlayRouting
                            label: 'Underlay Routing'
                            description: 'Specify the underlay routing details for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - fabricSubnetMask
                                        - underlayRoutingProtocol
                                        - fabricLinksSubnet
                        vxlanOverlay:
                            id: vxlanOverlay
                            name: vxlanOverlay
                            label: 'VXLAN Overlay'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_BOOLEAN
                            boolean_props:
                                default_value: true
                        leafLoopback1Subnet:
                            id: leafLoopback1Subnet
                            name: leafLoopback1Subnet
                            label: 'VTEP Address Range'
                            description: 'Define a subnet in CIDR notation from which to allocate VXLAN tunnel source IP addresses. These IP addresses will be assigned to the leaf switch''s Loopback1 interface'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: 172.16.1.0/24
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        vVtepAddress:
                            id: vVtepAddress
                            name: vVtepAddress
                            label: 'vVTEP Address'
                            description: 'If you are not using an integrated routing and bridging model, enter an IP address in CIDR notation. This addess will be a secondary IP address on the Loopback1 interface of all leaf switches'
                            required: false
                            type: INPUT_FIELD_TYPE_STRING
                            string_props:
                                default_value: null
                                static_options: null
                                format: cidr
                                length: null
                                pattern: null
                                dynamic_options: null
                        overlayDetails:
                            id: overlayDetails
                            name: overlayDetails
                            label: 'Overlay Details'
                            description: 'Configure the VXLAN overlay settings for this Pod.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - vxlanOverlay
                                        - leafLoopback1Subnet
                                        - vVtepAddress
                        maxSpines:
                            id: maxSpines
                            name: maxSpines
                            label: 'Maximum Number of Spines'
                            description: 'If no number is entered, the spine limit will be set to the greatest ''Spine-Number'' tag value in this Pod'
                            required: false
                            type: INPUT_FIELD_TYPE_INTEGER
                            integer_props:
                                default_value: null
                                range: null
                                static_options: null
                                dynamic_options: null
                        maximums:
                            id: maximums
                            name: maximums
                            label: 'Spine Limit'
                            description: 'Limit the potential growth of spine nodes to a maximum number. This prevents the fabric''s IP addresses from being recalculated when additional spines are added in the future.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - maxSpines
                        pod:
                            id: pod
                            name: pod
                            label: Pod
                            description: 'Configure a leaf-spine module for your fabric.'
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - commonMlagConfig
                                        - commonBGPConfig
                                        - spines
                                        - leafDomains
                                        - spanningTreeMode
                                        - underlayRouting
                                        - overlayDetails
                                        - maximums
                        pods:
                            id: pods
                            name: pods
                            label: Pods
                            description: 'Configure a leaf-spine module for your fabric.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: pod
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: DC-Pod
                                tag_filter_query: null
                        dataCenter:
                            id: dataCenter
                            name: dataCenter
                            label: 'Data Center'
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - pods
                        dataCenters:
                            id: dataCenters
                            name: dataCenters
                            label: 'Data Centers'
                            description: 'Select a data center using the tag label DC.'
                            required: false
                            type: INPUT_FIELD_TYPE_RESOLVER
                            resolver_props:
                                base_field_id: dataCenter
                                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                                input_tag_label: DC
                                tag_filter_query: null
                        root:
                            id: root
                            name: ""
                            label: ""
                            description: ""
                            required: false
                            type: INPUT_FIELD_TYPE_GROUP
                            group_props:
                                members:
                                    values:
                                        - dataCenters
                layout:
                    value: '{"pod":{"key":"pod","type":"INPUT","order":["spines","leafDomains","commonMlagConfig","underlayRouting","commonBGPConfig","overlayDetails","spanningTreeMode","maximums"]},"commonMlagConfig":{"key":"commonMlagConfig","type":"INPUT","order":["mlagLinkSubnet","mlagSubnetMask","internalVlan","mlagPortChannelId","virtualRouterMac","lacpMode"]},"underlayRouting":{"key":"underlayRouting","type":"INPUT","order":["underlayRoutingProtocol","fabricLinksSubnet","fabricSubnetMask"]},"leafLoopback1Subnet":{"key":"leafLoopback1Subnet","type":"INPUT","dependency":{"vxlanOverlay":{"value":[false],"mode":"HIDE"}}},"vVtepAddress":{"key":"vVtepAddress","type":"INPUT","dependency":{"vxlanOverlay":{"value":[false],"mode":"HIDE"}}}}'
