- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: 857333ca-e200-46db-808d-6d23243cca4f
        workspace_id: ''
      display_name: AVD Campus Fabric
      description: Provision the fabric of an L2 or L3 campus network.
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |-
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          from collections import Counter, OrderedDict
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.services import TagServiceStub, \
              TagAssignmentServiceStub, \
              TagConfigServiceStub,\
              TagAssignmentConfigServiceStub
          from arista.tag.v2.services.gen_pb2 import TagRequest, \
              TagConfigSetRequest, \
              TagStreamRequest, \
              TagConfigStreamRequest, \
              TagAssignmentStreamRequest, \
              TagAssignmentConfigSetRequest, \
              TagAssignmentConfigStreamRequest
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig


          campus_designs = {
                  "L2": "l2ls",
                  "L3": "l3ls-evpn"
              }

          node_type_defaults = {
              "l3ls-evpn": {
                  "spine": {},
                  "l3leaf": {},
                  "l2leaf": {}
              },
              "l2ls": {
                  "spline": {
                      "default_evpn_role": None,
                      "mlag_support": True,
                      "vtep": False,
                      "connected_endpoints": False,
                      "network_services_l2": True,
                      "network_services_l3": True,
                      "underlay_router": True,
                      "uplink_type": "p2p"
                  },
                  "leaf":{
                      "default_evpn_role": None,
                      "mlag_support": True,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": False,
                      "underlay_router": False,
                      "uplink_type": "port-channel"
                  },
                  "memberleaf": {
                      "default_evpn_role": None,
                      "mlag_support": False,
                      "vtep": False,
                      "connected_endpoints": True,
                      "network_services_l2": True,
                      "network_services_l3": False,
                      "underlay_router": False,
                      "uplink_type": "port-channel"
                  }
              }
          }

          fabric_variables = {
              "bgp_peer_groups": {
                  "IPv4_UNDERLAY_PEERS": {
                      "name": "IPv4-UNDERLAY-PEERS",
                      "password": None
                  },
                  "MLAG_IPv4_UNDERLAY_PEER": {
                      "name": "MLAG-IPv4-UNDERLAY-PEER",
                      "password": None,
                  },
                  "EVPN_OVERLAY_PEERS": {
                      "name": "EVPN-OVERLAY-PEERS",
                      "password": None
                  }
              },
              "bfd_multihop": {
                  "interval": 300,
                  "min_rx": 300,
                  "multiplier": 3
              },
              "evpn_ebgp_multihop": 3,
              "evpn_hostflap_detection": {
                  "enabled": False,
                  "threshold": 5,
                  "window": 180
              },
              "interface_descriptions":{
                  "underlay_l3_ethernet_interfaces": "P2P_LINK_TO_{link['peer'].upper()}_{link['peer_interface']}",
                  "underlay_l2_ethernet_interfaces": "TO_{link['peer'].upper()}_{link['peer_interface']}",
                  "underlay_port_channel_interfaces": "{link['peer'].upper()}_Po{link.get('peer_channel_group_id')}",
                  "router_id_interface": "EVPN_Overlay_Peering",
                  "vtep_source_interface": "VTEP_VXLAN_Tunnel_Source",
                  "mlag_ethernet_interfaces": "MLAG_{mlag_peer}_{mlag_peer_interface}",
                  "mlag_port_channel_interface": "MLAG_PEER_{switch_facts['mlag_peer']}_Po{switch_facts['mlag_port_channel_id']}"
              },
              "p2p_interface_settings": []
          }


          platform_settings = {
              "jericho-fixed": {
                  "regexes": [r'DCS-7280\w(R|R2)\D*-.+', r'DCS-7048T'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": "vxlan-routing",
                  "info": "Configured in standard settings"
              },
              "jericho-chassis": {
                  "regexes": [r'DCS-75\d\d'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": "vxlan-routing",
                  "info": "Configured in standard settings"
              },
              "jericho2-fixed": {
                  "regexes": [r'DCS-7280\w(R3)\D*-.+'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              },
              "jericho2-chassis": {
                  "regexes": [r'DCS-78\d\d'],
                  "reload_delay": {
                      "mlag": 900,
                      "non_mlag": 1020
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              },
              "default": {
                  "regexes": [r'.+'],
                  "reload_delay": {
                      "mlag": 300,
                      "non_mlag": 330
                  },
                  "tcam_profile": None,
                  "info": "Configured in standard settings"
              }
          }
          veos_regex = r'(v|c)EOS(-)*(Lab)*'


          def compare_eos_versions(version1, version2):
              version1 = re.sub(r'[a-zA-Z]', "", version1)
              version2 = re.sub(r'[a-zA-Z]', "", version2)
              versions1 = [int(v) for v in version1.split(".")]
              versions2 = [int(v) for v in version2.split(".")]
              for i in range(max(len(versions1),len(versions2))):
                  v1 = versions1[i] if i < len(versions1) else 0
                  v2 = versions2[i] if i < len(versions2) else 0
                  if v1 > v2:
                      return 1
                  elif v1 <v2:
                      return -1
              return 0


          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None


          def convert_dicts(dictionary, primary_key="name", secondary_key=None):
              """
              The `arista.avd.convert_dicts` filter will convert a dictionary containing nested dictionaries to a list of
              dictionaries. It inserts the outer dictionary keys into each list item using the primary_key `name` (key name is
              configurable) and if there is a non-dictionary value,it inserts this value to
              secondary key (key name is configurable), if secondary key is provided.
              This filter is intended for:
              - Seemless data model migration from dictionaries to lists.
              - Improve Ansible's processing performance when dealing with large dictionaries by converting them to lists of dictionaries.
              Note: If there is a non-dictionary value with no secondary key provided, it will pass through untouched
              To use this filter:
              ```jinja
              {# convert list of dictionary with default `name:` as the primary key and None secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.name }}
              {% endfor %}
              {# convert list of dictionary with `id:` set as the primary key and `types:` set as the secondary key #}
              {% set example_list = example_dictionary | arista.avd.convert_dicts('id','types') %}
              {% for example_item in example_list %}
              item primary key is {{ example_item.id }}
              item secondary key is {{ example_item.types }}
              {% endfor %}
              ```
              Parameters
              ----------
              dictionary : any
                  Nested Dictionary to convert - returned untouched if not a nested dictionary and list
              primary_key : str, optional
                  Name of primary key used when inserting outer dictionary keys into items.
              secondary_key : str, optional
                  Name of secondary key used when inserting dictionary values which are list into items.
              Returns
              -------
              any
                  Returns list of dictionaries or input variable untouched if not a nested dictionary/list.
              """
              if not isinstance(dictionary, (dict, list)) or os.environ.get("AVD_DISABLE_CONVERT_DICTS"):
                  # Not a dictionary/list, return the original
                  return dictionary
              elif isinstance(dictionary, list):
                  output = []
                  for element in dictionary:
                      if not isinstance(element, dict):
                          item = {}
                          item.update({primary_key: element})
                          output.append(item)
                      elif primary_key not in element and secondary_key is not None:
                          # if element of nested dictionary is a dictionary but primary key is missing, insert primary and secondary keys.
                          for key in element:
                              output.append(
                                  {
                                      primary_key: key,
                                      secondary_key: element[key],
                                  }
                              )
                      else:
                          output.append(element)
                  return output
              else:
                  output = []
                  for key in dictionary:
                      if secondary_key is not None:
                          # Add secondary key for the values if secondary key is provided
                          item = {}
                          item.update({primary_key: key})
                          item.update({secondary_key: dictionary[key]})
                          output.append(item)
                      else:
                          if not isinstance(dictionary[key], dict):
                              # Not a nested dictionary
                              output.append({primary_key: key})
                          else:
                              # Nested dictionary
                              item = dictionary[key].copy()
                              item.update({primary_key: key})
                              output.append(item)
                  return output

          from itertools import count, groupby
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError(f"value must be of type list, got {type(list_to_compress)}")
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return ",".join("-".join(map(str, (g[0], g[-1])[: len(g)])) for g in G)


          def string_to_list(string_to_convert):
              numbers = []
              segments = [segment.strip() for segment in string_to_convert.split(",") if segment.strip() != ""]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          if i not in numbers:
                              numbers.append(i)
                  else:
                      if int(segment) not in numbers:
                          numbers.append(int(segment))
              return numbers


          def convert(text):
              return int(text) if text.isdigit() else text.lower()


          def natural_sort(iterable, sort_key=None):
              if iterable is None:
                  return []

              def alphanum_key(key):
                  if sort_key is not None and isinstance(key, dict):
                      return [convert(c) for c in re.split("([0-9]+)", str(key.get(sort_key, key)))]
                  else:
                      return [convert(c) for c in re.split("([0-9]+)", str(key))]

              return sorted(iterable, key=alphanum_key)


          def range_expand(range_to_expand):
              if not (isinstance(range_to_expand, list) or isinstance(range_to_expand, str)):
                  raise TypeError(f"value must be of type list or str, got {type(range_to_expand)}")

              result = []

              # If we got a list, unpack it and run this function recursively
              if isinstance(range_to_expand, list):
                  for r in range_to_expand:
                      result.extend(range_expand(r))

              # Must be a str now
              else:
                  prefix = ""

                  # Unpack list in string
                  for one_range in range_to_expand.split(","):
                      if one_range is None:
                          continue

                      # Find prefix (if any)
                      regex = r"^(.*?)(((\d+)-)?(\d+)\/)?(((\d+)-)?(\d+)\/)?(((\d+)-)?(\d+))(\.((\d+)-)?(\d+))?"
                      # Number of groups in this regex.
                      regex_groups = 17
                      # Groups one-by-one:
                      # Group 1  (.*?)                                                                           matches prefix ex. Ethernet, Eth, Po, Port-Channel
                      # Group 2       (((\d+)-)?(\d+)\/)?                                                        matches module(s) and slash ex. 12/, 1-3/
                      # Group 3        ((\d+)-)?                                                                 matches first module and dash ex. 1-
                      # Group 4         (\d+)                                                                    matches first module ex. 1
                      # Group 5                 (\d+)                                                            matches last module ex. 12, 3
                      # Group 6                          (((\d+)-)?(\d+)\/)?                                     matches parent interface(s) and slash ex. 47/, 1-48/
                      # Group 7                           ((\d+)-)?                                              matches parent interface(s) and dash ex. 47-
                      # Group 8                            (\d+)                                                 matches first parent interface ex. 1
                      # Group 9                                    (\d+)                                         matches last parent interface ex. 47, 48
                      # Group 10                                            (((\d+)-)?(\d+))                     matches (breakout) interface(s) ex. 1, 1-4, 1-48
                      # Group 11                                             ((\d+)-)?                           matches first interfaces and dash ex. 1-, 1-
                      # Group 12                                              (\d+)                              matches first interface
                      # Group 13                                                      (\d+)                      matches last interface ex. 1, 4, 48
                      # Group 14                                                            (\.((\d+)-)?(\d+))?  matches dot and sub-interface(s) ex. .141, .12-15
                      # Group 15                                                               ((\d+)-)?         matches first sub-interface and dash ex. 12-
                      # Group 16                                                                (\d+)            matches first sub-interface ex. 12
                      # Group 17                                                                        (\d+)    matches last sub-interface ex. 141, 15
                      # Remember that the groups() object is 0-based and the group numbers above are 1-based
                      search_result = re.search(regex, one_range)
                      if search_result:
                          if len(search_result.groups()) == regex_groups:
                              groups = search_result.groups()
                              first_module = last_module = None
                              first_parent_interface = last_parent_interface = None
                              first_interface = last_interface = None
                              first_subinterface = last_subinterface = None
                              # Set prefix if found (otherwise use last set prefix)
                              if groups[0]:
                                  prefix = groups[0]
                              if groups[4]:
                                  last_module = int(groups[4])
                              if groups[3]:
                                  first_module = int(groups[3])
                              else:
                                  first_module = last_module
                              if groups[8]:
                                  last_parent_interface = int(groups[8])
                              if groups[7]:
                                  first_parent_interface = int(groups[7])
                              else:
                                  first_parent_interface = last_parent_interface
                              if groups[12]:
                                  last_interface = int(groups[12])
                              if groups[11]:
                                  first_interface = int(groups[11])
                              else:
                                  first_interface = last_interface
                              if groups[16]:
                                  last_subinterface = int(groups[16])
                              if groups[15]:
                                  first_subinterface = int(groups[15])
                              else:
                                  first_subinterface = last_subinterface

                              def expand_subinterfaces(interface_string):
                                  result = []
                                  if last_subinterface:
                                      for subinterface in range(first_subinterface, last_subinterface + 1):
                                          result.append(f"{interface_string}.{subinterface}")
                                  else:
                                      result.append(interface_string)
                                  return result

                              def expand_interfaces(interface_string):
                                  result = []
                                  for interface in range(first_interface, last_interface + 1):
                                      for res in expand_subinterfaces(f"{interface_string}{interface}"):
                                          result.append(res)
                                  return result

                              def expand_parent_interfaces(interface_string):
                                  result = []
                                  if last_parent_interface:
                                      for parent_interface in range(first_parent_interface, last_parent_interface + 1):
                                          for res in expand_interfaces(f"{interface_string}{parent_interface}/"):
                                              result.append(res)
                                  else:
                                      for res in expand_interfaces(f"{interface_string}"):
                                          result.append(res)
                                  return result

                              def expand_module(interface_string):
                                  result = []
                                  if last_module:
                                      for module in range(first_module, last_module + 1):
                                          for res in expand_parent_interfaces(f"{interface_string}{module}/"):
                                              result.append(res)
                                  else:
                                      for res in expand_parent_interfaces(f"{interface_string}"):
                                          result.append(res)
                                  return result

                              result.extend(expand_module(prefix))

                          else:
                              raise IndexError(f"Invalid range, got {one_range} and found {search_result.groups()}")

              return result


          def default(*values):
              """
              Accepts any number of arguments. Return the first value which is not None
              Last resort is to return None.
              Parameters
              ----------
              *values : any
                  One or more values to test
              Returns
              -------
              any
                  First value which is not None
              """

              for value in values:
                  if value is not None:
                      return value
              return None


          def get(dictionary, key, default=None, required=False, org_key=None, separator="."):
              """
              Get a value from a dictionary or nested dictionaries.
              Key supports dot-notation like "foo.bar" to do deeper lookups.
              Returns the supplied default value or None if the key is not found and required is False.
              Parameters
              ----------
              dictionary : dict
                  Dictionary to get key from
              key : str
                  Dictionary Key - supporting dot-notation for nested dictionaries
              default : any
                  Default value returned if the key is not found
              required : bool
                  Fail if the key is not found
              org_key : str
                  Internal variable used for raising exception with the full key name even when called recursively
              separator: str
                  String to use as the separator parameter in the split function. Useful in cases when the key
                  can contain variables with "." inside (e.g. hostnames)
              Returns
              -------
              any
                  Value or default value
              Raises
              ------
              AristaAvdMissingVariableError
                  If the key is not found and required == True
              """

              if org_key is None:
                  org_key = key
              keys = str(key).split(separator)
              value = dictionary.get(keys[0])
              if value is None:
                  if required is True:
                      raise TypeError(org_key)
                  return default
              else:
                  if len(keys) > 1:
                      return get(value, separator.join(keys[1:]), default=default, required=required, org_key=org_key, separator=separator)
                  else:
                      return value

          def get_all(data, path: str, required: bool = False, org_path=None):
              """
              Get all values from data matching a data path.
              Path supports dot-notation like "foo.bar" to do deeper lookups. Lists will be unpacked recursively.
              Returns an empty list if the path is not found and required is False.
              Parameters
              ----------
              data : any
                  Data to walk through
              path : str
                  Data Path - supporting dot-notation for nested dictionaries/lists
              required : bool
                  Fail if the path is not found
              org_path : str
                  Internal variable used for raising exception with the full path even when called recursively
              Returns
              -------
              list [ any ]
                  List of values matching data path or empty list if no matches are found.
              Raises
              ------
              AristaAvdMissingVariableError
                  If the path is not found and required == True
              """

              if org_path is None:
                  org_path = path

              path_elements = str(path).split(".")
              if isinstance(data, list):
                  output = []
                  for data_item in data:
                      output.extend(get_all(data_item, path, required=required, org_path=org_path))

                  return output

              elif isinstance(data, dict):
                  value = data.get(path_elements[0])

                  if value is None:
                      if required:
                          raise TypeError(org_path)

                      return []

                  if len(path_elements) > 1:
                      return get_all(value, ".".join(path_elements[1:]), required=required, org_path=org_path)

                  else:
                      return [value]

              return []


          def get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=True):
              '''
              Returns all tags applied to a device that match the label of the input tag_assignment_key

              Args:
                  tag_assignment_key: TagAssignmentKey object with the label field set
              '''
              label = tag_assignment_key.label.value
              value = tag_assignment_key.value.value
              device_id = tag_assignment_key.device_id.value
              workspace_id = tag_assignment_key.workspace_id.value
              # Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              matching_tags = []

              # Create TagValueSearchRequest
              tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                  tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=topology_studio_request)
                  tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      if match.device.device_id == device_id:
                          matching_tags.append(tag)

              return matching_tags

          def __get_devices_matching_tag_query(query):
              # Now try to search with this query to get the matching devices
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              search_req = tspb.TagMatchRequestV2(query=query, workspace_id=ctx.studio.workspaceId)
              search_res = tsclient.GetTagMatchesV2(search_req)
              return [match.device.device_id for match in search_res.matches] or query

          def get_tag_value(device_id=None, label=None, workspace_id=None, topology_studio_request=True):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key, topology_studio_request=topology_studio_request)
              if len(tag_values) > 0:
                  return tag_values[0].value

          def get_tag_values(device_id=None, label=None, workspace_id=None):
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.element_type = 1
              if workspace_id is not None:
                  tag_assignment_key.workspace_id.value = workspace_id
              if device_id is not None:
                  tag_assignment_key.device_id.value =  device_id
              if label is not None:
                  tag_assignment_key.label.value = label
              tag_values = get_tag_values_applied_to_device(tag_assignment_key)
              if len(tag_values) > 0:
                  return [ tag_value.value for tag_value in tag_values ]

          def create_tag(tag_key):
              '''
              tag_key is a TagKey
              '''
              tcsr = TagConfigSetRequest()
              tcsr.value.key.workspace_id.value = tag_key.workspace_id.value
              tcsr.value.key.element_type = tag_key.element_type
              tcsr.value.key.label.value = tag_key.label.value
              tcsr.value.key.value.value = tag_key.value.value
              client = ctx.getApiClient(TagConfigServiceStub)
              client.Set(tcsr)

          def apply_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = False
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_tag(tag_assignment_key):
              '''
              tag_assignment_key is a TagAssignmentKey
              '''
              tacsr = TagAssignmentConfigSetRequest()
              tacsr.value.key.workspace_id.value = tag_assignment_key.workspace_id.value
              tacsr.value.key.element_type = tag_assignment_key.element_type
              tacsr.value.key.label.value = tag_assignment_key.label.value
              tacsr.value.key.value.value = tag_assignment_key.value.value
              tacsr.value.key.device_id.value = tag_assignment_key.device_id.value
              tacsr.value.key.interface_id.value = tag_assignment_key.interface_id.value
              tacsr.value.remove.value = True
              client = ctx.getApiClient(TagAssignmentConfigServiceStub)
              client.Set(tacsr)

          def remove_all_tag_values(tag_label, device_id, workspace_id, value=None):
              '''
              Removes all tags with the input tag label matchiing the input device_id
              If a value is supplied, only tags matching the label and value will be removed from the device
              '''
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = tag_label
              # tag_assignment_key.value.value = None
              matching_tags = get_tag_values_applied_to_device(tag_assignment_key)
              # If there are any mlag_configuration.peer_link tags applied
              if len(matching_tags) > 0:
                  # Remove tags
                  for tag in matching_tags:
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      if value is None:
                          remove_tag(tak_to_remove)
                      else:
                          if tag.value == value:
                              remove_tag(tak_to_remove)


          def update_device_tag(tag_assignment_key, multiple_values=False):
              """
              tag_assignment_key is a TagAssignmentKey that you want to update the device with
              """
              applied_tags = get_tag_values_applied_to_device(tag_assignment_key)
              already_assigned = False
              for tag in applied_tags:
                  if tag.value != tag_assignment_key.value.value:
                      if multiple_values == True:
                          continue
                      tak_to_remove = TagAssignmentKey()
                      tak_to_remove.workspace_id.value = tag_assignment_key.workspace_id.value
                      tak_to_remove.element_type = 1
                      tak_to_remove.device_id.value =  tag_assignment_key.device_id.value
                      tak_to_remove.label.value = tag_assignment_key.label.value
                      tak_to_remove.value.value = tag.value
                      remove_tag(tak_to_remove)
                  else:
                      already_assigned = True

              if already_assigned:
                  return

              #Create desired tag
              tag_key = TagKey()
              tag_key.workspace_id.value = workspace_id
              tag_key.element_type = 1
              tag_key.label.value = tag_assignment_key.label.value
              tag_key.value.value = tag_assignment_key.value.value
              create_tag(tag_key)

              # Apply desired tag
              apply_tag(tag_assignment_key)


          def update_tags(switch_facts):
              device_id = switch_facts["serial_number"]
              # node_id tag
              # Create/Update/Apply the node_id tag
              tag_assignment_key = TagAssignmentKey()
              tag_assignment_key.workspace_id.value = workspace_id
              tag_assignment_key.element_type = 1
              tag_assignment_key.device_id.value =  device_id
              tag_assignment_key.label.value = "node_id"
              tag_assignment_key.value.value = str(switch_facts["id"])
              update_device_tag(tag_assignment_key)
              # Update campus-pod tag
              if switch_facts["type"] in ["leaf", "memberleaf"]:
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "Campus-Pod"
                  tag_assignment_key.value.value = str(switch_facts["group"])
                  update_device_tag(tag_assignment_key)
              # Update network services tags
              if switch_facts["network_services"].get("l2"):
                  # Create/Apply the following tag 'network_services:L2'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "NetworkServices"
                  tag_assignment_key.value.value = "L2"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L2'
                  remove_all_tag_values("NetworkServices", device_id, workspace_id, value="L2")
              if switch_facts["network_services"].get("l3"):
                  # Create/Apply the following tag 'network_services:L3'
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "NetworkServices"
                  tag_assignment_key.value.value = "L3"
                  update_device_tag(tag_assignment_key, multiple_values=True)
              else:
                  # Remove the following tag 'network_services:L3'
                  remove_all_tag_values("NetworkServices", device_id, workspace_id, value="L3")
              # Update mlag_configuration.peer_link
              if switch_facts.get("mlag"):
                  mlag_peer_link = "Port-Channel{}".format(switch_facts["mlag_port_channel_id"])
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "mlag_configuration.peer_link"
                  tag_assignment_key.value.value = str(mlag_peer_link)
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("mlag_configuration.peer_link", device_id, workspace_id)

              # Update routing tags
              bgp_tags = {"router_bgp.as": switch_facts.get("bgp_as"), "router_bgp.router_id": switch_facts.get("router_id")}
              if switch_facts.get("underlay_router") \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  # Set bgp as and router id tags
                  for label, value in bgp_tags.items():
                      tag_assignment_key = TagAssignmentKey()
                      tag_assignment_key.workspace_id.value = workspace_id
                      tag_assignment_key.element_type = 1
                      tag_assignment_key.device_id.value =  device_id
                      tag_assignment_key.label.value = str(label)
                      tag_assignment_key.value.value = str(value)
                      update_device_tag(tag_assignment_key)
              else:
                  # Remove possible bgp tags
                  for label, value in bgp_tags.items():
                      #Remove tags with same label that don't match proper value
                      if value is None:
                          remove_all_tag_values(str(label), device_id, workspace_id)
              # Update VTEP tag
              # ctx.info(f"{switch_facts['hostname']} VTEP: {switch_facts.get('vtep')}")
              if switch_facts.get("vtep"):
                  tag_assignment_key = TagAssignmentKey()
                  tag_assignment_key.workspace_id.value = workspace_id
                  tag_assignment_key.element_type = 1
                  tag_assignment_key.device_id.value =  device_id
                  tag_assignment_key.label.value = "Vtep"
                  tag_assignment_key.value.value = "True"
                  update_device_tag(tag_assignment_key)
              else:
                  remove_all_tag_values("Vtep", device_id, workspace_id)
              return


          def device_matches_resolver_query(resolver, device_id):
              _, ctx_resolver = resolver.resolveWithContext(device_id)
              if ctx_resolver and ctx_resolver.query_str.strip() != "":
                  return True
              else:
                  return False


          # returns dictionary of device to label value based on workspace tag assignments
          def populate_single_value_dict(workspace_id, label):
              sv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      sv_dict[match.device.device_id] = tag.value
              return sv_dict

          # returns dictionary of device to label values based on workspace tag assignments
          def populate_multi_value_dict(workspace_id, label):
              mv_dict = {}
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              tvsr = tspb.TagValueSearchRequest(
                  label=label,
                  workspace_id=workspace_id,
                  topology_studio_request=True
              )
              for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                  query = f"{tag.label}:\"{tag.value}\""
                  tagmr = tspb.TagMatchRequestV2(
                      query=query,
                      workspace_id=workspace_id,
                      topology_studio_request=True
                  )
                  tagmresp = tsclient.GetTagMatchesV2(tagmr)
                  for match in tagmresp.matches:
                      mv_dict.setdefault(match.device.device_id, []).append(tag.value)
              return mv_dict


          def get_mlag_peer_by_tags(switch_facts):
              potential_roles = {"spline": "Spline", "leaf": "Leaf", "memberleaf": "Member-Leaf"}
              mlag_peer_switch_facts = None
              device_id = switch_facts["serial_number"]
              role = potential_roles.get(switch_facts["type"])
              campus = switch_facts["campus"]
              site = switch_facts["site"]
              if role is None:
                  return
              query = f'NOT device:{device_id} AND Role:{role} AND NOT Role:Member-Leaf AND Campus:"{campus}" AND Site:"{site}"'
              if switch_facts["type"] == "leaf":
                  query += f' Campus-Pod:"{switch_facts["group"]}"'

              potential_mlag_peer_sns = __get_devices_matching_tag_query(query)
              if type(potential_mlag_peer_sns) == list:
                  if len(potential_mlag_peer_sns) > 1:
                      ctx.warning(f"Detected multiple MLAG peers for {switch_facts['hostname']}: {potential_mlag_peer_sns}")
                  if len(potential_mlag_peer_sns) > 0:
                      mlag_peer_switch_facts = all_switch_facts_in_my_site.get(potential_mlag_peer_sns[0])

              return mlag_peer_switch_facts


          def get_mlag_ip(switch_facts, mlag_peer_ipv4_pool, mlag_peer_subnet_mask, mlag_role):
              mlag_subnet = ipaddress.ip_network(mlag_peer_ipv4_pool)
              assert mlag_subnet.prefixlen <= mlag_peer_subnet_mask, "MLAG Subnet mask length must be longer than the mask of the mlag subnet"
              if mlag_subnet.prefixlen != mlag_peer_subnet_mask:
                  mlag_subnet = list(mlag_subnet.subnets(new_prefix=mlag_peer_subnet_mask))[int(switch_facts["mlag_primary_id"]) - 1]
              if mlag_role == "primary":
                  return list(mlag_subnet.hosts())[0]
              elif mlag_role == "secondary":
                  return list(mlag_subnet.hosts())[1]
              return


          def get_router_id(switch_facts):
              router_id_subnet = switch_facts["loopback_ipv4_pool"]
              switch_id = switch_facts["id"]
              offset = switch_facts["loopback_ipv4_offset"]
              return list(ipaddress.ip_network(router_id_subnet).hosts())[(switch_id - 1) + offset]


          def get_vtep_loopback(switch_facts, offset=None):
              if switch_facts["type"] == "spline" or offset is None:
                  offset = 0
              vtep_loopback_subnet = switch_facts["vtep_loopback_ipv4_pool"]
              if switch_facts.get("mlag_primary_id"):
                  switch_id = switch_facts["mlag_primary_id"] - 1 + offset
              else:
                  switch_id = switch_facts["id"] - 1 + offset
              return list(ipaddress.ip_network(vtep_loopback_subnet).hosts())[switch_id]


          def get_inband_management_ip(switch_facts):
              # Use same virtual ip, primary mlag switch ip, and secondary mlag switch ip on all gateways
              if switch_facts["campus_type"] == "l2ls":
                  if switch_facts["type"] == "spline":
                      if switch_facts["mlag_role"] == "secondary":
                          # Return inband management subnet network address + 2 
                          list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[2]
                      else:
                          # Return inband management subnet network address + 1
                          return list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[1]
                  else:
                      return list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[switch_facts["id"] + 2]
              return 



          def set_switch_facts_properties(device_id, campus_resolver):
              # Initialize switch_facts
              switch_facts = {}
              switch_facts = {"serial_number": device_id}

              # Get facts from tags
              switch_facts["hostname"] = [ dev.hostName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["platform"] = [ dev.modelName for dev in ctx.topology.getDevices(deviceIds=[device_id])][0]
              switch_facts["eos_version"] = get_tag_value(device_id=device_id, label="eos", workspace_id=workspace_id, topology_studio_request=False)
              switch_facts["campus"] = campus_dict.get(device_id)
              switch_facts["site"] = site_dict.get(device_id)

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return
              campus_details = campus_resolved["campusDetails"]
              site_resolved = campus_details["site"].resolve(device=device_id)
              if site_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Site input.  Make sure a 'Site' tag is applied.")
                  return
              site_details = site_resolved["siteFacts"]

              # Set switch node type
              switch_facts["type"] = None
              potential_roles = {"Spline": "spline", "Leaf": "leaf", "Member-Leaf": "memberleaf"}
              roles_applied_to_switch = role_dict.get(device_id)
              # If no role is applied to switch, switch should not be in fabric build
              if roles_applied_to_switch is None:
                  ctx.warning(f"No Role tag set for {switch_facts['hostname']}")
                  return

              # Check to see that a device isn't assigned multiple roles within the campus fabric
              roles_intersect = [role for role in roles_applied_to_switch if role in list(potential_roles.keys())]
              assert len(roles_intersect) <= 1, f"Only 1 campus role should be applied to the switch. " \
                                                f"Detected the following roles applied to {switch_facts['hostname']}: {roles_intersect}"

              # Set node type
              if roles_applied_to_switch is not None:
                  for role in potential_roles.keys():
                      if role in roles_applied_to_switch:
                          switch_facts["type"] = potential_roles[role]
                          break
              
              if switch_facts["type"] is None:
                  ctx.warning(f"No Role tag set for {switch_facts['hostname']}")
                  return

              # Set campus type
              switch_facts["campus_type"] = campus_designs[site_details["campusType"]]

              # Get custom node properties
              custom_node_properties = {
                  "connected_endpoints": None,
                  "default_evpn_role": None,
                  "mlag_support": None,
                  "vtep": None,
                  "network_services_l2": None,
                  "network_services_l3": None
              }
              if switch_facts["type"] == "spline":
                  spline_defaults = site_details['nodeTypeProperties']['defaultSplineProperties']
                   # Set custom EVPN role
                  if spline_defaults.get('splineEvpnRoleDefault', '').strip() != "":
                      custom_node_properties['default_evpn_role'] = True if spline_defaults['splineEvpnRoleDefault'] == "Yes" else False
                  # Set custom MLAG support role
                  if spline_defaults.get('splineMlagSupportDefault', '').strip() != "":
                      custom_node_properties['mlag_support'] = True if spline_defaults['splineMlagSupportDefault'] == "Yes" else False
                  # Set custom Vtep role
                  if spline_defaults.get('splineVtepDefault', '').strip() != "":
                      custom_node_properties['vtep'] = True if spline_defaults['splineVtepDefault'] == "Yes" else False
                  # Set custom Connnected Endpoints role
                  if spline_defaults.get('splineConnectedEndpointsDefault', '').strip() != "":
                      custom_node_properties['connected_endpoints'] = True if spline_defaults['splineConnectedEndpointsDefault'] == "Yes" else False
                  # Set custom L2 Network Services role
                  if spline_defaults.get('splineL2NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l2'] = True if spline_defaults['splineL2NetworkServicesDefault'] == "Yes" else False
                  # Set custom L3 Network Services role
                  if spline_defaults.get('splineL3NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l3'] = True if spline_defaults['splineL3NetworkServicesDefault'] == "Yes" else False

              elif switch_facts["type"] == "leaf":
                  leaf_defaults = site_details['nodeTypeProperties']['defaultLeafProperties']
                   # Set custom EVPN role
                  if leaf_defaults.get('leafEvpnRoleDefault', '').strip() != "":
                      custom_node_properties['default_evpn_role'] = True if leaf_defaults['leafEvpnRoleDefault'] == "Yes" else False
                  # Set custom MLAG support role
                  if leaf_defaults.get('leafMlagSupportDefault', '').strip() != "":
                      custom_node_properties['mlag_support'] = True if leaf_defaults['leafMlagSupportDefault'] == "Yes" else False
                  # Set custom Vtep role
                  if leaf_defaults.get('leafVtepDefault', '').strip() != "":
                      custom_node_properties['vtep'] = True if leaf_defaults['leafVtepDefault'] == "Yes" else False
                  # Set custom Connnected Endpoints role
                  if leaf_defaults.get('leafConnectedEndpointsDefault', '').strip() != "":
                      custom_node_properties['connected_endpoints'] = True if leaf_defaults['leafConnectedEndpointsDefault'] == "Yes" else False
                  # Set custom L2 Network Services role
                  if leaf_defaults.get('leafL2NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l2'] = True if leaf_defaults['leafL2NetworkServicesDefault'] == "Yes" else False
                  # Set custom L3 Network Services role
                  if leaf_defaults.get('leafL3NetworkServicesDefault', '').strip() != "":
                      custom_node_properties['network_services_l3'] = True if leaf_defaults['leafL3NetworkServicesDefault'] == "Yes" else False

              # Set node properties
              switch_facts["connected_endpoints"] = default(custom_node_properties.get("connected_endpoints"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["connected_endpoints"])
              switch_facts["default_evpn_role"] = default(custom_node_properties.get("default_evpn_role"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["default_evpn_role"])
              switch_facts["mlag_support"] = default(custom_node_properties.get("mlag_support"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["mlag_support"])
              switch_facts["network_services_l2"] = default(custom_node_properties.get("network_services_l2"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["network_services_l2"])
              switch_facts["network_services_l3"] = default(custom_node_properties.get("network_services_l3"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["network_services_l3"])
              switch_facts["underlay_router"] = default(custom_node_properties.get("underlay_router"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["underlay_router"])
              switch_facts["uplink_type"] = default(custom_node_properties.get("uplink_type"), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["uplink_type"])
              switch_facts["vtep"] = default(custom_node_properties.get('vtep'), node_type_defaults[switch_facts["campus_type"]][switch_facts["type"]]["vtep"])
              # switch_facts["ip_addressing"] = 
              # switch_facts["interface_descriptions"] = 

              # Set node id based on NodeId mini-tagger values
              node_id = node_id_dict.get(device_id)
              if node_id is not None:
                  switch_facts['id'] = int(node_id)
              else:
                  ctx.warning(f"No NodeId tag set for {switch_facts['hostname']}")
                  return

              # Set group
              if switch_facts["type"] == "spline":
                  switch_facts["group"] = "{}_{}_Splines".format(switch_facts["campus"], switch_facts["site"])
              else:
                  switch_facts['group'] = campus_pod_dict.get(device_id)
                  if switch_facts['group'] is None:
                      ctx.warning(f"{switch_facts['hostname']} does not have a Campus-Pod tag applied.")
                      return

              return switch_facts


          def set_switch_facts_properties_for_query(label, value, campus_resolver):
              # Dictionary of switches that will be returned
              all_switch_facts = {}

              #Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              #Get switches in same Campus
              query= "{}:\"{}\"".format(label, value)
              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
              for match in tagmresp.matches:
                  switch_facts_from_query = set_switch_facts_properties(match.device.device_id, campus_resolver)
                  if switch_facts_from_query is None:
                      continue
                  if match.device.device_id not in all_switch_facts:
                      all_switch_facts[match.device.device_id] = switch_facts_from_query
              return all_switch_facts


          def set_switch_facts(switch_facts, campus_resolver):
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return
              campus_details = campus_resolved["campusDetails"]
              site_resolved = campus_details["site"].resolve(device=device_id)
              if site_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Site input.  Make sure a 'Site' tag is applied.")
                  return
              site_details = site_resolved["siteFacts"]

              # Get fabric details
              if switch_facts["underlay_router"] == True:
                  switch_facts["underlay_routing_protocol"] = site_details["siteRoutingProtocols"]["siteUnderlayRoutingProtocol"].lower()
                  if site_details["siteRoutingProtocols"].get("siteOverlayRoutingProtocol"):
                      switch_facts["overlay_routing_protocol"] = site_details["siteRoutingProtocols"]["siteOverlayRoutingProtocol"].lower()
                  else:
                      switch_facts["overlay_routing_protocol"] = ""

              # Get node defaults from user inputs
              if switch_facts["type"] == "spline":
                  node_defaults = site_details["splineDefaults"]
              else:
                  node_defaults = site_details["campusPodDefaults"]

              # Logs
              # ctx.info(f"Site Details: {site_details}")
              # ctx.info(f"Node Defaults: {node_defaults}")

              # Get spanning tree details
              if switch_facts["network_services_l2"]:
                  switch_facts["spanning_tree_mode"] = node_defaults["spanningTreeDetails"].get("spanningTreeMode", "").lower()
                  if switch_facts["type"] == "spline":
                      if switch_facts["campus_type"] == "l2ls":
                          switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority") if node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority") is not None else 4096
                      else:
                          switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("splineSpanningTreePriority")
                  elif switch_facts["type"] == "leaf":
                      switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("leafSpanningTreePriority")
                  elif switch_facts["type"] == "memberleaf":
                      switch_facts["spanning_tree_priority"] = node_defaults["spanningTreeDetails"].get("memberLeafSpanningTreePriority")

              # virtual router mac
              if switch_facts["network_services_l2"] and switch_facts["network_services_l3"]:
                  switch_facts["virtual_router_mac_address"] = node_defaults["mlagDetails"]["virtualRouterMacAddress"]

              # Get router related facts
              if switch_facts["underlay_router"] == True and node_defaults.get("routerIdPool") is not None:
                  switch_facts["loopback_ipv4_pool"] = node_defaults["routerIdPool"]

                  if switch_facts["type"] == "spline":
                      switch_facts["loopback_ipv4_offset"] = 0
                  elif switch_facts["type"] == "leaf":
                      if site_details["splineDefaults"]["routerIdPool"] == site_details["campusPodDefaults"]["routerIdPool"]:
                          # Offset is 2
                          switch_facts["loopback_ipv4_offset"] = 2
                      else:
                          switch_facts["loopback_ipv4_offset"] = 0

                  # switch_facts["loopback_ipv4_description"]  = 

                  # Set Router ID
                  switch_facts["router_id"] = str(get_router_id(switch_facts))

                  # Set uplink ipv4 pool
                  switch_facts["uplink_ipv4_pool"] = node_defaults.get("uplinkIpv4Pool")
                  switch_facts["uplink_ipv4_subnet_mask"] = 31

                  # Set BGP parameters
                  if switch_facts["underlay_routing_protocol"] == "bgp" or switch_facts["overlay_routing_protocol"] == "bgp":
                      # Set asn
                      asns = string_to_list(str(node_defaults["bgpDetails"]["bgpAsns"]))
                      if len(asns) > 1:
                          if switch_facts.get("mlag_primary_id"):
                              switch_facts["bgp_as"] = asns[switch_facts["mlag_primary_id"] - 1]
                          else:
                              switch_facts["bgp_as"] = asns[switch_facts["id"] - 1]
                      else:
                          switch_facts["bgp_as"] = asns[0]

                      # Set bgp defaults
                      switch_facts["bgp_defaults"] = node_defaults["bgpDetails"]["bgpDefaults"]

                      # Set bgp max paths
                      # switch_facts["bgp_maximum_paths"] = 4
                      
                      # Set bgp ecmp 
                      # switch_facts["bgp_ecmp"] = 4

                      # # Set evpn role and evpn neighbors
                      if switch_facts["overlay_routing_protocol"] == "bgp" and switch_facts["underlay_router"] is True:
                          # Set evpn role
                          switch_facts["evpn_role"] = switch_facts.get("default_evpn_role")
                      
                          # Set evpn neighbors
                          switch_facts["evpn_route_servers"] = switch_facts["uplink_switches"]
                          switch_facts["evpn_route_server_ids"] = switch_facts["uplink_switches_ids"]
                      else:
                          # Set evpn role
                          switch_facts["evpn_role"] = None
                          
                          # Set evpn neighbors
                          switch_facts["evpn_route_servers"] = []
                          switch_facts["evpn_route_server_ids"] = []

                  # Set OSPF parameters
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      switch_facts["underlay_ospf_process_id"] = site_details["ospfDetails"]["processId"]
                      switch_facts["underlay_ospf_area"] = site_details["ospfDetails"]["area"]
                      switch_facts["underlay_ospf_max_lsa"] = site_details["ospfDetails"]["maxLsa"]
                      switch_facts["underlay_ospf_bfd_enable"] = site_details["ospfDetails"]["bfd"]
                      switch_facts["ospf_defaults"] = node_defaults["ospfDetails"]["ospfDefaults"]

              # Get mlag settings
              if switch_facts["mlag_support"] == True:
                  mlag_peer_switch_facts = get_mlag_peer_by_tags(switch_facts)
                  if mlag_peer_switch_facts is not None:
                      switch_facts["mlag"] = True
                  else:
                      ctx.warning(f"Could not find an MLAG peer for {switch_facts['hostname']}")
                      switch_facts["mlag"] = False

                  if switch_facts["mlag"] == True and mlag_peer_switch_facts is not None:
                      switch_facts["mlag_peer"] = mlag_peer_switch_facts["hostname"]

                      switch_facts["mlag_peer_serial_number"] = mlag_peer_switch_facts["serial_number"]

                      switch_facts["mlag_group"] = switch_facts["group"]

                      if switch_facts["underlay_router"] == True:
                          switch_facts["mlag_l3"] = True
                      else:
                          switch_facts["mlag_l3"] = False

                      switch_facts["mlag_peer_vlan"] =  node_defaults["mlagDetails"]["mlagPeerVlan"]
                      switch_facts["mlag_peer_ipv4_pool"] = node_defaults["mlagDetails"]["mlagPeerIPv4Pool"]
                      switch_facts["mlag_peer_subnet_mask"] = 31
                      if switch_facts.get("underlay_router"):
                          # Set mlag_peer_l3_vlan if there is value set in studio input
                          if node_defaults['mlagDetails']['mlagPeerL3Vlan'] is not None \
                                  and node_defaults['mlagDetails']['mlagPeerL3IPv4Pool'].strip() != "":
                              switch_facts['mlag_peer_l3_vlan'] = node_defaults['mlagDetails']['mlagPeerL3Vlan']
                              switch_facts['mlag_peer_l3_ipv4_pool'] = node_defaults['mlagDetails']['mlagPeerL3IPv4Pool']
                              switch_facts['mlag_peer_l3_subnet_mask'] = 31
                          else:
                              switch_facts['mlag_peer_l3_vlan'] = switch_facts['mlag_peer_vlan']
                              switch_facts['mlag_peer_l3_ipv4_pool'] = switch_facts["mlag_peer_ipv4_pool"]
                              switch_facts['mlag_peer_l3_subnet_mask']= switch_facts["mlag_peer_subnet_mask"]

                      switch_facts["mlag_lacp_mode"] = "active"
                      # switch_facts["reload_delay_mlag"] = 300
                      # switch_facts["reload_delay_non_mlag"] = 330
                      # switch_facts["mlag_ibgp_origin_incomplete"] = True

                      if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                          switch_facts["mlag_primary_id"] = int(switch_facts["id"])

                          switch_facts["mlag_role"] = "primary"

                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                    switch_facts["mlag_peer_subnet_mask"], "primary"))

                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                         switch_facts["mlag_peer_subnet_mask"], "secondary"))

                          if switch_facts.get("underlay_router"):
                              switch_facts["mlag_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                           switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                              switch_facts["mlag_peer_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                                switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                      else:
                          switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])
                          
                          switch_facts["mlag_role"] = "secondary"

                          switch_facts["mlag_ip"] = str(get_mlag_ip(switch_facts,
                              switch_facts["mlag_peer_ipv4_pool"], switch_facts["mlag_peer_subnet_mask"], "secondary"))

                          switch_facts["mlag_peer_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_ipv4_pool"],
                                                                         switch_facts["mlag_peer_subnet_mask"], "primary"))


                          if switch_facts.get("underlay_router"):


                              switch_facts["mlag_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                           switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                              switch_facts["mlag_peer_l3_ip"] = str(get_mlag_ip(switch_facts, switch_facts["mlag_peer_l3_ipv4_pool"],
                                                                                switch_facts["mlag_peer_l3_subnet_mask"], "primary"))
              
                      # Set mlag interfaces                
                      switch_facts["mlag_interfaces"] = node_defaults["mlagDetails"]["mlagPeerInterfaces"]
                      if switch_facts["type"] == "leaf":
                          campus_pod_mlag_interfaces = site_details["campusPods"].resolve(device=device_id)["campusPodFacts"]["campusPodMlagPeerInterfaces"]
                          if len(campus_pod_mlag_interfaces) > 0:
                              switch_facts["mlag_interfaces"] = campus_pod_mlag_interfaces
                      switch_facts["mlag_peer_switch_interfaces"] = switch_facts["mlag_interfaces"]

              else:
                  switch_facts["mlag"] = False

              if switch_facts["underlay_router"] == True:
                  if switch_facts["vtep"]:  # and site_details["siteRoutingProtocols"]["siteOverlayRoutingProtocol"] != "":
                      switch_facts["vtep_loopback_ipv4_pool"] = node_defaults["vtepLoopbackIPv4Pool"]
                      switch_facts["vtep_loopback"] = "Loopback1"
                      if site_details["nodeTypeProperties"]["defaultSplineProperties"].get("splineVtepDefault"):
                          vtep_offset = 1
                      else:
                          vtep_offset = 0
                      switch_facts["vtep_ip"] =  str(get_vtep_loopback(switch_facts, offset=vtep_offset))
                  # else:
                  #     # Turn off the vtep setting since there are no VTEPs in this network
                  #     switch_facts["vtep"] = False

              # Get inband management details
              if node_defaults.get("inbandManagementDetails"):
                  # inband management vlan
                  switch_facts["inband_management_vlan"] = node_defaults["inbandManagementDetails"].get("inbandManagementVlan")

                  # inband management subnet
                  switch_facts["inband_management_subnet"] = node_defaults["inbandManagementDetails"].get("inbandManagementSubnet")
              
              # Set inband management details
              if switch_facts.get("inband_management_subnet") and switch_facts.get("inband_management_vlan"):
                  # inband management role and parents
                  if switch_facts["campus_type"] == "l2ls" and switch_facts["type"] != "spline":
                      switch_facts["inband_management_role"] = "child"

                  else:
                      if switch_facts["type"] == "memberleaf":
                          switch_facts["inband_management_role"] = "child"

                  # inbound management parent devices 
                  switch_facts["inband_management_parents"] = switch_facts["uplink_switches_ids"]

                  # inband_management_ip
                  switch_facts["inband_management_ip"] = "{}/{}".format(
                      str(get_inband_management_ip(switch_facts)),
                      str(ipaddress.ip_network(switch_facts["inband_management_subnet"]).prefixlen)
                  )

                  # inband management gateway
                  switch_facts["inband_management_gateway"] = str(list(ipaddress.ip_network(switch_facts["inband_management_subnet"]).hosts())[0])

                  # inband management interface
                  switch_facts["inband_management_interface"] = "Vlan{}".format(switch_facts["inband_management_vlan"])

                  # set boot vlan for campus ZTP feature
                  switch_facts["boot_vlan"] = switch_facts.get("inband_management_vlan")

              if re.match(veos_regex, switch_facts["platform"]):
                  switch_facts["p2p_uplinks_mtu"] = 1500
              else:
                  switch_facts["p2p_uplinks_mtu"] = 9214

              # for regex in jericho_platform_regexes:
              #     if re.search(regex, switch_facts["platform"]):
              #         switch_facts["reload_delay_mlag"] = 780
              #         switch_facts["reload_delay_non_mlag"] = 1020
              #         break

              return switch_facts


          def get_uplink_info(switch_facts, campus_resolver):
              '''
              Returns switch_facts' uplink_interfaces, uplink_switches, and uplink switches' downlink_interfaces
              '''
              device_id = switch_facts["serial_number"]
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return
              campus_details = campus_resolved["campusDetails"]
              site_resolved = campus_details["site"].resolve(device=device_id)
              if site_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Site input.  Make sure a 'Site' tag is applied.")
                  return
              site_details = site_resolved["siteFacts"]

              # Initialize return variables
              uplink_interfaces = []
              uplink_switches = []
              uplink_switch_interfaces = []

              # Get input values
              uplink_interface_dicts = []
              if switch_facts["type"] == "leaf":
                  uplink_interface_dicts = site_details["campusPods"].resolve(device=device_id)["campusPodFacts"]["leafUplinkInterfaces"]
              elif switch_facts["type"] == "memberleaf":
                  uplink_interface_dicts = site_details["campusPods"].resolve(device=device_id)["campusPodFacts"]["memberLeafUplinkInterfaces"]
              
              # Set return variables
              for uplink_interface_dict in uplink_interface_dicts:
                  if uplink_interface_dict["hostname"] == switch_facts["hostname"]:
                      uplink_interfaces.append(uplink_interface_dict["uplinkInterface"])
                      uplink_switches.append(uplink_interface_dict["uplinkSwitchHostname"])
                      uplink_switch_interfaces.append(uplink_interface_dict["uplinkSwitchInterface"])

              return uplink_interfaces, uplink_switches, uplink_switch_interfaces


          def set_switch_uplink_info(switch_facts, campus_resolver):
              # # interface info from studio topology tags
              # uplink_interfaces = switch_facts["uplink_interfaces"]
              # downlink_interfaces = switch_facts["downlink_interfaces"]
              # mlag_peer_link_interfaces = switch_facts["mlag_peer_link_interfaces"]

              # switch uplink info
              switch_facts["uplink_interfaces"], switch_facts["uplink_switches"], switch_facts["uplink_switch_interfaces"]  = get_uplink_info(switch_facts, campus_resolver)

              # uplink_switches ids (This is time consuming way to get switch_facts)
              switch_facts["uplink_switches_ids"] = []
              for hostname in switch_facts["uplink_switches"]:
                  for tmp_switch_sn, tmp_switch_facts in all_switch_facts_in_my_site.items():
                      if tmp_switch_facts["hostname"] == hostname:
                          switch_facts["uplink_switches_ids"].append(tmp_switch_sn)

              return switch_facts


          def set_switch_downlink_info(switch_facts):
              '''
              Using switch_facts uplink info which is previously set by set_switch_uplink_info(switch_facts. campus_resolver), set the
              downlink info for switch_facts using the uplink info from other switches in all_switch_facts_in_my_site
              '''
              switch_facts["downlink_switches_ids"] = []
              if switch_facts["type"] == "spline":
                  for tmp_switch_sn, tmp_switch_facts in all_switch_facts_in_my_site.items():
                      if tmp_switch_facts["type"] == "leaf" and switch_facts["serial_number"] in tmp_switch_facts["uplink_switches_ids"] \
                              and tmp_switch_sn not in switch_facts["downlink_switches_ids"]:    
                          switch_facts["downlink_switches_ids"].append(tmp_switch_sn)
              elif switch_facts["type"] == "leaf":
                  for tmp_switch_sn, tmp_switch_facts in all_switch_facts_in_my_site.items():
                      if tmp_switch_facts["type"] == "memberleaf" and tmp_switch_facts["group"] == switch_facts["group"] \
                              and switch_facts["serial_number"] in tmp_switch_facts["uplink_switches_ids"] and tmp_switch_sn not in switch_facts["downlink_switches_ids"]:                
                          switch_facts["downlink_switches_ids"].append(tmp_switch_sn)

              return switch_facts


          def set_topology_facts(switch_facts):
              topology_facts = {
                  "links": {}
              }
              if switch_facts["uplink_type"] == "p2p":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = all_switch_facts_in_my_site[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      link_facts["peer_bgp_as"] = uplink_switch_facts.get("bgp_as")
                      link_facts["type"] = "underlay_p2p"
                      link_facts["ip_address"] = str(get_p2p_uplinks_ip(switch_facts, uplink_switch_facts))
                      link_facts["peer_ip_address"] = str(get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts))
                      if switch_facts.get("underlay_multicast"):
                          link_facts["pim_enabled"] = True
                      else:
                          link_facts["pim_enabled"] = False
                      topology_facts["links"][uplink_interface] = link_facts

              elif switch_facts["uplink_type"] == "port-channel":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = all_switch_facts_in_my_site[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_type"] = uplink_switch_facts["type"]
                      # Campus Service has a field here for allowed_vlans
                      if switch_facts["allow_all_vlans"] is False:
                          # Remove vlans if uplink switch doesn't have them
                          uplink_vlans = list(set(switch_facts["vlans"]) & set(uplink_switch_facts.get("vlans", [])))
                          if switch_facts.get("inband_management_vlan"):
                              uplink_vlans.append(switch_facts["inband_management_vlan"])
                          link_facts["vlans"] = uplink_vlans
                      link_facts["type"] = "underlay_l2"
                      if uplink_switch_facts.get("mlag") is not None and uplink_switch_facts.get("mlag") is True:
                          link_facts["channel_description"] = uplink_switch_facts["mlag_group"]

                      if switch_facts.get("mlag") is not None and switch_facts.get("mlag") is True:
                          link_facts["peer_channel_description"] = switch_facts["mlag_group"]

                      if switch_facts.get("mlag_role") is not None and switch_facts["mlag_role"] == "secondary":
                          mlag_peer_switch_facts =  all_switch_facts_in_my_site[switch_facts["mlag_peer_serial_number"]]
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_switch_interfaces"][0]))
                      else:
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_switch_interfaces"][0]))
                      topology_facts["links"][uplink_interface] = link_facts

              switch_facts["topology"] = topology_facts
              return switch_facts


          def get_network_services_leaf_switch(switch_facts, campus_resolver):
              # device_id from switch_facts
              device_id = switch_facts["serial_number"]

              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return switch_facts
              campus_details = campus_resolved["campusDetails"]
              site_resolved = campus_details["site"].resolve(device=device_id)
              if site_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Site input.  Make sure a 'Site' tag is applied.")
                  return switch_facts
              site_details = site_resolved["siteFacts"]

              # Set services
              if switch_facts["network_services_l2"] is True or switch_facts["network_services_l3"] is True:
                  # allow all vlans
                  switch_facts["allow_all_vlans"] = site_details["services"].get("allowAllVLANs", False)
                  leaf = {
                      "vlans": [],
                      "tenants": {}
                  }
                  add_vrfs = {}  # Used to determine which services are applied to this switch
                  add_svis = []  # For logging
                  add_l2vlans = []  # Not necessary
                  # Add VRF if node is found in any of vrf fields
                  for vrf in site_details["services"]["vrfs"]:
                      # Add all vrfs if add_all_vrfs flag is set to True
                      if site_details["services"].get("applyAllVrfs", False) is True:
                          add_vrfs[vrf['vrfName']] = {
                              "svis": []
                          }
                          continue

                      # if l3 interface is to be configured on switch
                      if len(vrf.get('l3Interfaces').resolve(device=switch_facts['serial_number'])['interfaces']) > 0:
                          if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              continue

                      # Add VRF if there is a BGP neighbor for this node in vrf
                      for bgp_peer in vrf.get("externalBgpPeers", []):
                          # if bgp peer is to be configured on switch
                          if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      if add_vrfs.get(vrf['vrfName']):
                          continue

                      # Add VRF if there is a static route for this node in vrf
                      for sr in vrf.get('staticRoutes', []):
                          # if static route is to be configured on switch
                          if device_matches_resolver_query(sr['devices'], switch_facts['serial_number']):
                              add_vrfs[vrf['vrfName']] = {
                                  "svis": []
                              }
                              break

                      # Last check in loop is unnecessary
                      # if add_vrfs.get(vrf['vrfName']):
                      #     continue

                  # Add VLAN if assigned to switch; Add VRF the VLAN is in if not already added; 
                  for vlan in site_details["services"]["vlans"]:
                      # Check if vlan is applied to switch
                      if device_matches_resolver_query(vlan['campusPod'], device_id):
                          add_svis.append(vlan['vlanId'])
                          leaf['vlans'].append(int(vlan['vlanId']))
                          if vlan['sviDetails'].get('vrf', '') == '':
                              vrf_name = 'default'
                          else:
                              vrf_name = vlan['sviDetails']['vrf']

                          # Add vrf to add_vrfs
                          if not add_vrfs.get(vrf_name):
                              add_vrfs[vrf_name] = {
                                  "svis": []
                              }

                          # Add vlan to vrf's add_svis
                          add_vrfs[vrf_name]["svis"].append(int(vlan['vlanId']))

                  # Filter only services applied to this switch
                  if len(add_vrfs) > 0 or len(add_l2vlans) > 0:
                      leaf['tenants'].update({ "services": {"vrfs": add_vrfs, "l2vlans": add_l2vlans} })

                  switch_facts["tenants"]= leaf.get('tenants', {})
                  switch_facts["vlans"] = leaf.get('vlans', [])

                  if switch_facts["serial_number"] == my_switch_facts["serial_number"]:
                      ctx.info(f"VRFs to be configured on switch: {list(add_vrfs.keys())}")
                      ctx.info(f"VLANs to be configured on switch: {add_svis}")

              return switch_facts


          def get_network_services_spline_switch(switch_facts):
              '''
              Get VLANs applied to spline switch via downstream neighbors
              '''
              spline = {
                  "vlans": [],
                  "tenants": {}
              }
              if switch_facts["type"] != "spline":
                  return switch_facts

              if switch_facts["campus_type"] == "l2ls":
                  for switch_id in switch_facts.get("downlink_switches_ids", []):
                      tmp_switch_facts = all_switch_facts_in_my_site.get(switch_id)
                      if tmp_switch_facts is None:
                          continue
                      for vlan in tmp_switch_facts.get('vlans', []):
                          if vlan not in spline['vlans']:
                              spline['vlans'].append(vlan)
              
                      # Only names/ids matter, user inputs within dictionaries dont matter
                      # Get tenant info from downstream tenants
                      for tenant in tmp_switch_facts.get('tenants', {}):
                          if tenant not in spline['tenants']:
                              spline['tenants'][tenant] = tmp_switch_facts["tenants"][tenant]
                          else:
                              # check if vrfs exist for tenant
                              for vrf in tmp_switch_facts["tenants"][tenant].get("vrfs", {}):
                                  if vrf not in spline['tenants'][tenant]["vrfs"]:
                                      spline['tenants'][tenant]["vrfs"][vrf] = tmp_switch_facts["tenants"][tenant]["vrfs"][vrf]
                                  else:
                                      # check if svis exist 
                                      for svi in tmp_switch_facts["tenants"][tenant]["vrfs"][vrf].get("svis", {}):
                                          if svi not in  spline['tenants'][tenant]["vrfs"][vrf]["svis"]:
                                              spline['tenants'][tenant]["vrfs"][vrf]["svis"][svi] = tmp_switch_facts["tenants"][tenant]["vrfs"][vrf]["svis"][svi]

              switch_facts["tenants"]= spline.get("tenants")
              switch_facts["vlans"] = spline.get("vlans")
              return switch_facts


          def set_base_config(config, switch_facts):
              # Set spanning tree
              if switch_facts.get("spanning_tree_mode"):
                  config["spanning_tree"]["mode"] = switch_facts["spanning_tree_mode"]
                  if switch_facts.get("spanning_tree_priority"):
                      if config["spanning_tree"]["mode"] == "mstp":
                          config["spanning_tree"]["mst_instances"] = {
                              0: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                          config['spanning_tree']['mst'] = {
                              'configuration': {
                                  "instances": {}
                              }
                          }
                      elif config["spanning_tree"]["mode"] == "rapid-pvst":
                          config["spanning_tree"]["rapid_pvst_instances"] = {
                              1: {"priority": switch_facts["spanning_tree_priority"]}
                          }
                      elif config["spanning_tree"]["mode"] == "rstp":
                          config["spanning_tree"]["rstp_priority"] = switch_facts["spanning_tree_priority"]

              # Set tcam profile
              # for regex in jericho_platform_regexes:
              #     if re.search(regex, switch_facts["platform"]):
              #         config["tcam_profile"] = {
              #             "system": "vxlan-routing"
              #         }
              #         break
              # Set routing
              config["service_routing_protocols_model"] = "multi-agent"
              if switch_facts["underlay_router"] == True:
                  config["ip_routing"] = True
                  if switch_facts.get("underlay_multicast"):
                      config["router_multicast"] = {
                          "ipv4": {
                              "routing": True
                          }
                      }
              # Set router-bgp
              if switch_facts["underlay_router"] == True \
                 and (switch_facts["underlay_routing_protocol"] == "bgp" \
                 or switch_facts["overlay_routing_protocol"] == "bgp"):
                  config["router_bgp"]["as"] = switch_facts["bgp_as"]
                  config["router_bgp"]["router_id"] = switch_facts["router_id"]
                  config["router_bgp"]["bgp_defaults"] = switch_facts["bgp_defaults"]
                  if switch_facts.get("bgp_maximum_paths"):
                      config["router_bgp"]["maximum_paths"] = switch_facts["bgp_maximum_paths"]
                  if switch_facts.get("bgp_ecmp"):
                      config["router_bgp"]["ecmp"] = switch_facts["bgp_ecmp"]
              return config


          def set_mlag_config(config, switch_facts):
              if switch_facts.get('mlag'):
                  # Set spanning tree relevant config
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['spanning_tree']['no_spanning_tree_vlan'] = ",".join(
                          [str(switch_facts['mlag_peer_l3_vlan']), str(switch_facts['mlag_peer_vlan'])]
                      )
                  else:
                      config['spanning_tree']['no_spanning_tree_vlan'] = switch_facts['mlag_peer_vlan']

                  # Set mlag vlan
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['vlans'][switch_facts['mlag_peer_l3_vlan']] = {
                          "tenant": "system",
                          "name": "LEAF_PEER_L3",
                          "trunk_groups": ['LEAF_PEER_L3']
                      }
                  config['vlans'][switch_facts['mlag_peer_vlan']] = {
                      "tenant": "system",
                      "name": "MLAG_PEER",
                      "trunk_groups": ['MLAG']
                  }

                  # Set mlag svi
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"] = {
                          "description": "MLAG_PEER_L3_PEERING",
                          "shutdown": False,
                          "ip_address": f"{switch_facts['mlag_l3_ip']}/{switch_facts['mlag_peer_l3_subnet_mask']}",
                          "no_autostate": True,
                          "mtu": switch_facts['p2p_uplinks_mtu']
                      }
                  config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_vlan']}"] = {
                      "description": "MLAG_PEER",
                      "shutdown": False,
                      "ip_address": f"{switch_facts['mlag_ip']}/{switch_facts['mlag_peer_subnet_mask']}",
                      "no_autostate": True,
                      "mtu": switch_facts['p2p_uplinks_mtu']
                  }
                  if switch_facts['mlag_l3'] is True and switch_facts['underlay_routing_protocol'] == "ospf":
                      config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"]['ospf_network_point_to_point'] = True
                      config['vlan_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"]['ospf_area'] \
                          = switch_facts['underlay_ospf_area']

                  # Set port-channel interfaces
                  switch_facts["mlag_port_channel_id"] = "".join(re.findall(r'\d', switch_facts["mlag_interfaces"][0]))
                  config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"] = {
                      "description": eval(f"f\"{fabric_variables['interface_descriptions']['mlag_port_channel_interface']}\""),
                      "type": "switched",
                      "shutdown": False,
                      "mode": "trunk",
                      "trunk_groups": ['MLAG']
                  }
                  if switch_facts['mlag_l3'] is True and switch_facts['mlag_peer_l3_vlan'] != switch_facts['mlag_peer_vlan']:
                      config['port_channel_interfaces'][f"Port-Channel{switch_facts['mlag_port_channel_id']}"]['trunk_groups']\
                          .append("LEAF_PEER_L3")

                  # Set ethernet interfaces
                  for i, iface in enumerate(switch_facts['mlag_interfaces']):
                      mlag_peer = switch_facts['mlag_peer']
                      mlag_peer_interface = switch_facts['mlag_peer_switch_interfaces'][i]
                      config['ethernet_interfaces'][iface] = {
                          "peer": mlag_peer,
                          "peer_interface": mlag_peer_interface,
                          "peer_type": "mlag",
                          "description": eval(f"f\"{fabric_variables['interface_descriptions']['mlag_ethernet_interfaces']}\""),
                          "type": "switched",
                          "shutdown": False,
                          "channel_group": {
                              "id": switch_facts['mlag_port_channel_id'],
                              "mode": switch_facts['mlag_lacp_mode']
                          }
                      }

                  # Set mlag config
                  config['mlag_configuration'] = {
                      "enabled": True,
                      "domain_id": switch_facts['mlag_group'],
                      "local_interface": f"Vlan{switch_facts['mlag_peer_vlan']}",
                      "peer_address": switch_facts['mlag_peer_ip'],
                      "peer_link": f"Port-Channel{switch_facts['mlag_port_channel_id']}",
                      # "reload_delay_mlag": switch_facts['reload_delay_mlag'],
                      # "reload_delay_non_mlag": switch_facts['reload_delay_non_mlag']
                  }

                  # Set route maps
                  # Origin Incomplete for MLAG iBGP learned routes
                  # if switch_facts['mlag_l3'] is True and \
                  #         switch_facts['mlag_ibgp_origin_incomplete'] is True and \
                  #         switch_facts['underlay_routing_protocol'] == "bgp":
                  #     config['route_maps']["RM-MLAG-PEER-IN"] = {
                  #         "sequence_numbers": {
                  #             10: {
                  #                 "type": "permit",
                  #                 "set": ["origin incomplete"],
                  #                 "description": "Make routes learned over MLAG Peer-link less "
                  #                             "preferred on spines to ensure optimal routing"
                  #             }
                  #         }
                  #     }

                  # Set bgp config
                  if switch_facts['mlag_l3'] is True and switch_facts['underlay_routing_protocol'] == "bgp":
                      (config['router_bgp']['peer_groups']
                      [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]) = {
                          "type": "ipv4",
                          "remote_as": switch_facts['bgp_as'],
                          "next_hop_self": True,
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['password'] is not None:
                          (config['router_bgp']['peer_groups']
                          [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]['password']) = \
                              fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['password']
                      # if switch_facts['mlag_ibgp_origin_incomplete'] is True:
                      #     (config['router_bgp']['peer_groups']
                      #     [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]['route_map_in']) = \
                      #         "RM-MLAG-PEER-IN"
                      (config['router_bgp']['address_family_ipv4']['peer_groups']
                      [fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name']]) = {
                          "activate": True
                      }
                      config['router_bgp']['neighbor_interfaces'][f"Vlan{switch_facts['mlag_peer_l3_vlan']}"] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name'],
                          "remote_as": switch_facts['bgp_as'],
                          "description": switch_facts['mlag_peer']
                      }
                      config['router_bgp']['neighbors'][switch_facts['mlag_peer_l3_ip']] = {
                          "peer_group": fabric_variables['bgp_peer_groups']['MLAG_IPv4_UNDERLAY_PEER']['name'],
                          "description": switch_facts['mlag_peer']
                      }

              return config


          def set_underlay_config(config, switch_facts):
              underlay_data = {}
              underlay_data["links"] = switch_facts["topology"]["links"]
              # First add interface details from devices whose uplink interface neighbors are this switch
              for sn in switch_facts["downlink_switches_ids"]:
                  neighbor_switch_facts = all_switch_facts_in_my_site[sn]
                  for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                      if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                          link = {}
                          link["peer_id"] = neighbor_switch_facts["serial_number"]
                          link["peer"] = neighbor_switch_facts["hostname"]
                          link["peer_interface"] = neighbor_link
                          link["peer_type"] = neighbor_switch_facts["type"]
                          link["peer_bgp_as"] = neighbor_switch_facts.get("bgp_as")
                          link["type"] = neighbor_link_info["type"]
                          link["ip_address"] = neighbor_link_info.get("peer_ip_address")
                          link["peer_ip_address"] = neighbor_link_info.get("ip_address")
                          link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                          link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                          link["channel_description"] = neighbor_link_info.get("peer_channel_description")
                          link["pim_enabled"] = neighbor_link_info.get("pim_enabled")
                          if neighbor_link_info.get("vlans"):
                              link["vlans"] = neighbor_link_info["vlans"]
                          if neighbor_switch_facts.get("boot_vlan") is not None:
                              link["boot_vlan"] = neighbor_switch_facts["boot_vlan"]

                          interface = neighbor_link_info["peer_interface"]
                          underlay_data["links"][interface] = link
                      
              # Determine whether or not boot ztp can be configured on this switch
              issue_boot_ztp_warning = False
              boot_ztp_eligible = False
              if compare_eos_versions(switch_facts["eos_version"], "4.27.1F") >= 0:
                  boot_ztp_eligible = True
              # Set Ethernet interfaces
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_p2p":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "P2P_LINK_TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "type": "routed",
                          "shutdown": False,
                          "ip_address": "{}/{}".format(link["ip_address"], switch_facts["uplink_ipv4_subnet_mask"])
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["ethernet_interfaces"][iface]["ospf_network_point_to_point"] = True
                          config["ethernet_interfaces"][iface]["ospf_area"] = switch_facts["underlay_ospf_area"]
                      if link.get("pim_enabled"):
                          config["ethernet_interfaces"][iface]["pim"] = {
                              "ipv4": {"sparse_mode": True}
                          }
                  elif link["type"] == "underlay_l2":
                      config["ethernet_interfaces"][iface] = {
                          "peer": link["peer"],
                          "peer_interface": link["peer_interface"],
                          "peer_type": link["peer_type"],
                          "description": "TO_{}_{}".format(link["peer"].upper(), link["peer_interface"]),
                          "type": "routed",
                          "shutdown": False
                      }
                      if link.get("boot_vlan") and boot_ztp_eligible is True:
                          config["ethernet_interfaces"][iface]["boot_vlan"] = link["boot_vlan"]
                      else:
                          issue_boot_ztp_warning = True

                      if link.get("channel_group_id"):
                          config["ethernet_interfaces"][iface]["channel_group"] = {
                              "id": link["channel_group_id"],
                              "mode": "active"
                          }

              if issue_boot_ztp_warning is True:
                  ctx.warning(f"Could not configure a boot vlan on downstream interfaces for {switch_facts['hostname']} because its EOS version is {switch_facts['eos_version']}.  The switch's EOS version must be >= 4.27.1F.")

              # Set Port-Channel interfaces
              port_channel_list = [] # go through this
              for iface in underlay_data["links"]:
                  link = underlay_data["links"][iface]
                  if link["type"] == "underlay_l2" and \
                          link.get("channel_group_id") and \
                          link.get("channel_group_id") not in port_channel_list:
                      port_channel_list.append(link["channel_group_id"])
                      port_channel = {
                          "description": "{}_Po{}".format(link["peer"].upper(), link.get("peer_channel_group_id")),
                          "type": "switched",
                          "shutdown": False,
                          "mode": "trunk",
                          "mlag": link["channel_group_id"]
                      }
                      if link.get('vlans'):
                          port_channel['vlans'] = list_compress(link['vlans'])

                      config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])] = port_channel

              # L2 and L3
              if switch_facts["network_services_l2"] == True and \
                  switch_facts["network_services_l3"] == True:
                  # set viritual router mac address
                  config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"]

              # Routing
              if switch_facts["underlay_router"] == True:
                  # Set loopback interfaces
                  if switch_facts.get("router_id"):
                      config["loopback_interfaces"]["Loopback0"] = {
                          "description": "ROUTER_ID",
                          "shutdown": False,
                          "ip_address": "{}/32".format(switch_facts["router_id"]),
                      }
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"]["Loopback0"]["ospf_area"] = switch_facts["underlay_ospf_area"]
                  if switch_facts["vtep"] == True:
                      config["loopback_interfaces"][switch_facts["vtep_loopback"]] = {
                         "description": "VTEP_VXLAN_Tunnel_Source",
                         "shutdown": False,
                         "ip_address": "{}/32".format(switch_facts["vtep_ip"])
                      }
                      if switch_facts.get("vtep_vvtep_ip") and switch_facts.get("evpn_services_l2_only") is not None and \
                          switch_facts.get("evpn_services_l2_only") == False:
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]] = [switch_facts["vtep_vvtep_ip"] ]
                      if switch_facts["underlay_routing_protocol"] == "ospf":
                          config["loopback_interfaces"][switch_facts["vtep_loopback"]]["ospf_area"] = switch_facts["underlay_ospf_area"]

                  # Set bgp if necessary
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "type": "ipv4",
                          "maximum_routes": 12000,
                          "send_community": "all"
                      }
                      if fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"] is not None:
                          config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] \
                              ["password"] = fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["password"]
                      config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"]] = {
                          "activate": True,
                      }
                      config["router_bgp"]["redistribute_routes"]["connected"] = {
                          "route_map": "RM-CONN-2-BGP"
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_bgp"]["neighbors"][link["peer_ip_address"]] = {
                                  "peer_group": fabric_variables["bgp_peer_groups"]["IPv4_UNDERLAY_PEERS"]["name"],
                                  "remote_as": link["peer_bgp_as"],
                                  "description": "{}_{}".format(link["peer"], link["peer_interface"])
                              }
                      # Create prefix lists
                      config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"] = {
                          "sequence_numbers": {
                              10: {
                                  "action": "permit {} eq 32".format(switch_facts["loopback_ipv4_pool"])
                              }
                          }
                      }
                      if switch_facts.get("vtep_ip") is not None:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][20] = {
                              "action": "permit {} eq 32".format(switch_facts["vtep_loopback_ipv4_pool"])
                          }
                      if switch_facts.get("vtep_vvtep_ip") is not None \
                         and switch_facts.get("evpn_services_l2_only") is not None \
                         and switch_facts.get("evpn_services_l2_only") == False:
                          config["prefix_lists"]["PL-LOOPBACKS-EVPN-OVERLAY"]["sequence_numbers"][30] = {
                              "action": "permit {}".format(switch_facts["vtep_vvtep_ip"])
                          }
                      # Create route-maps
                      config["route_maps"]["RM-CONN-2-BGP"] = {
                          "sequence_numbers": {
                              10: {
                                  "type": "permit",
                                  "match": ["ip address prefix-list PL-LOOPBACKS-EVPN-OVERLAY"]
                              }
                          }
                      }
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      config["router_ospf"]["process_ids"] = {
                          switch_facts["underlay_ospf_process_id"]: {
                              "passive_interface_default": True,
                              "router_id": switch_facts["router_id"],
                              "no_passive_interfaces": [],
                              "max_lsa": switch_facts["underlay_ospf_max_lsa"],
                              "ospf_defaults": switch_facts["ospf_defaults"]
                          }
                      }
                      for iface, link in underlay_data["links"].items():
                          if link["type"] == "underlay_p2p":
                              config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append(iface)
                      if switch_facts.get("mlag_l3") is not None and switch_facts.get("mlag_l3") == True:
                          config["router_ospf"]["process_ids"][switch_facts["underlay_ospf_process_id"]]\
                              ["no_passive_interfaces"].append("Vlan{}".format(switch_facts["mlag_peer_l3_vlan"]))
                      if switch_facts["underlay_ospf_bfd_enable"] == True:
                          config["bfd_enable"] = True

              return config


          def set_overlay_config(config, switch_facts):
              if not switch_facts.get("underlay_router"):
                  return config
              if switch_facts["overlay_routing_protocol"] != "bgp":
                  return config

              overlay_data = {}
              # Set evpn route servers
              overlay_data["evpn_route_servers"] = {}
              for rs_id in switch_facts["evpn_route_server_ids"]:
                  rs_switch_facts = all_switch_facts_in_my_site[rs_id]
                  if rs_switch_facts["evpn_role"] == "server":
                      server = {
                          "bgp_as": rs_switch_facts["bgp_as"],
                          "ip_address": rs_switch_facts["router_id"]
                      }
                      overlay_data["evpn_route_servers"][rs_switch_facts["hostname"]] = server

              # Set evpn route clients
              overlay_data["evpn_route_clients"] = {}
              if switch_facts["evpn_role"] == "server":
                  for campus_switch_facts in all_switch_facts_in_my_site.values():
                      if campus_switch_facts["evpn_role"] is not None and campus_switch_facts["evpn_role"] == "client":
                          if switch_facts['serial_number'] in campus_switch_facts["evpn_route_server_ids"]:
                              client = {
                                  "bgp_as": campus_switch_facts["bgp_as"],
                                  "ip_address": campus_switch_facts["router_id"]
                              }
                              overlay_data["evpn_route_clients"][campus_switch_facts["hostname"]] = client

              # Set ebgp
              config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "type": "evpn",
                  "update_source": "Loopback0",
                  "bfd": True,
                  "ebgp_multihop": str(fabric_variables["evpn_ebgp_multihop"]),
                  "send_community": "all",
                  "maximum_routes": 0,
              }
              if switch_facts["evpn_role"] == "server":
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["next_hop_unchanged"] = True
              if fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"] is not None:
                  config["router_bgp"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]]\
                  ["password"] = fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["password"]
              config["router_bgp"]["address_family_ipv4"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": False
              }
              config["router_bgp"]["address_family_evpn"]["peer_groups"][fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"]] = {
                  "activate": True
              }
              if switch_facts.get("vtep_ip") and fabric_variables["evpn_hostflap_detection"]["enabled"] == True:
                  config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"] = {
                      "window": fabric_variables["evpn_hostflap_detection"]["window"],
                      "threshold": fabric_variables["evpn_hostflap_detection"]["threshold"],
                      "enabled": fabric_variables["evpn_hostflap_detection"]["enabled"]
                  }
              # Overlay network peering
              for rs, info in overlay_data["evpn_route_servers"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": rs,
                      "remote_as": info["bgp_as"]
                  }
              for cs, info in overlay_data["evpn_route_clients"].items():
                  config["router_bgp"]["neighbors"][info["ip_address"]] = {
                      "peer_group": fabric_variables["bgp_peer_groups"]["EVPN_OVERLAY_PEERS"]["name"],
                      "description": cs,
                      "remote_as": info["bgp_as"]
                  }
              return config


          def set_vxlan_config(config, switch_facts):
              if switch_facts.get("vtep") == True:
                  config["vxlan_interface"] = {
                      "Vxlan1": {
                          "description": "{}_VTEP".format(switch_facts["hostname"]),
                          "vxlan": {
                              "source_interface": switch_facts["vtep_loopback"],
                              "udp_port": 4789
                          }
                      }
                  }
                  if switch_facts.get("mlag"):
                      config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] = "mlag-system-id"
              return config


          def set_inband_management_config(config, switch_facts):
              if switch_facts.get("inband_management_role", "") == "child":
                  # child-vlans
                  config["vlans"][switch_facts["inband_management_vlan"]] = {
                      "tenant": "system",
                      "name": "L2LEAF_INBAND_MGMT"
                  }
                  # child-management-interfaces
                  config["management_interfaces"] = {
                      switch_facts["inband_management_interface"]: {
                          "description": "L2LEAF_INBAND_MGMT",
                          "shutdown": False,
                          "mtu": switch_facts["p2p_uplinks_mtu"],
                          "ip_address": switch_facts["inband_management_ip"],
                          "gateway": switch_facts["inband_management_gateway"],
                          "type": "inband"
                      }
                  }
                  # child-static-routes
                  config["static_routes"].append(
                      {
                          "destination_address_prefix": "0.0.0.0/0",
                          "gateway": switch_facts["inband_management_gateway"]
                      }
                  )

              else:
                  # parent-logic
                  inband_management_data = {
                      "vlans": [],
                      "subnets": []
                  }
                  for tmp_switch_facts in all_switch_facts_in_my_site.values():
                      if switch_facts["serial_number"] in tmp_switch_facts.get("inband_management_parents", []):
                          inband_management_data["role"] = "parent"
                          if tmp_switch_facts["inband_management_subnet"] not in inband_management_data["subnets"]:
                              inband_management_data["vlans"].append(tmp_switch_facts["inband_management_vlan"])
                              inband_management_data["subnets"].append(tmp_switch_facts["inband_management_subnet"])

                  if inband_management_data.get("role", "") == "parent":
                      # parent-vlans
                      for vlan in inband_management_data.get("vlans", []):
                          config["vlans"][vlan] = {
                              "tenant": "system",
                              "name": "L2LEAF_INBAND_MGMT"
                          }
                      # parent-vlan-interfaces
                      for i, subnet in enumerate(inband_management_data.get("subnets", [])):
                          vlan_interface = {
                              "description": "L2LEAF_INBAND_MGMT",
                              "shutdown": False,
                              "mtu": switch_facts["p2p_uplinks_mtu"],
                              "ip_virtual_router_addresses": [list(ipaddress.ip_network(subnet).hosts())[0]],
                              "ip_attached_host_route_export": {
                                  "distance": 19
                              }
                          }
                          if switch_facts.get("mlag") is not None and switch_facts["mlag"] is True and switch_facts["mlag_role"] == "secondary":
                              ip_address = list(ipaddress.ip_network(subnet).hosts())[2]
                          else:
                              ip_address = list(ipaddress.ip_network(subnet).hosts())[1]

                          subnet_mask = subnet.split("/")[-1]
                          vlan_interface["ip_address"] = f"{ip_address}/{subnet_mask}"

                          config["vlan_interfaces"]["Vlan{}".format(inband_management_data["vlans"][i])] = vlan_interface
                      # Set virtual router mac address unless it will be set in network services
                      if not (switch_facts["network_services_l2"] is True and switch_facts["network_services_l3"] is True):
                          config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"].lower()

                      if switch_facts["underlay_router"] is True and switch_facts["underlay_routing_protocol"] == "bgp":
                          # parent-router-bgp
                          config["router_bgp"]["redistribute_routes"]["attached-host"] = {}

                          # parent-prefix-lists
                          config["prefix_lists"]["PL-L2LEAF-INBAND-MGMT"] = {
                              "sequence_numbers": {}
                          }
                          for i, subnet in enumerate(inband_management_data.get("subnets", [])):
                              config["prefix_lists"]["PL-L2LEAF-INBAND-MGMT"]["sequence_numbers"][(i+1)*10] = {
                                  "action": f"permit {subnet}"
                              }

                          # parent-route-maps
                          # sequence 10 is set in underlay so avoid setting it here
                          config["route_maps"]["RM-CONN-2-BGP"]["sequence_numbers"][20] = {
                              "type": "permit",
                              "match": ["ip address prefix-list PL-L2LEAF-INBAND-MGMT"]
                          }

              return config


          def get_tenants(switch_facts, campus_resolver):
              '''
              Convert studio services data model to avd network services data model

              Args:
                  
              Returns: 
                  all_services: a dictionary that conforms to avd's network services data model
              '''
              # device_id 
              device_id = switch_facts["serial_number"]
              # Process Studio inputs
              campus_resolved = campus_resolver.resolve(device=device_id)
              if campus_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Campus input.  Make sure a 'Campus' tag is applied.")
                  return None
              campus_details = campus_resolved["campusDetails"]
              site_resolved = campus_details["site"].resolve(device=device_id)
              if site_resolved is None:
                  ctx.warning(f"{switch_facts['hostname']} did not resolve for the Site input.  Make sure a 'Site' tag is applied.")
                  return None

              site_details = site_resolved["siteFacts"]

              all_vrfs = site_details["services"]["vrfs"]  # a list of studios vrf input dictionaries
              all_vlans = site_details["services"]["vlans"]  # a list of studios vlan input dictionaries

              tenant_name = "services"
              tenant = {
                  tenant_name: {
                      "vrfs": {
                          # initialize default vrf
                          "default": {
                              "svis": {}
                          }
                      }
                  }
              }
              if "default" not in [vrf["vrfName"] for vrf in all_vrfs]:
                  all_vrfs = all_vrfs + [{"vrfName": "default", "mlagL3PeeringDetails": {}, "staticRoutes": [], "vrfOspfConfiguration": {}}]
              for vrf in all_vrfs:
                  vrf_name = vrf["vrfName"]
                  tenant[tenant_name]["vrfs"][vrf_name] = {"svis": {}}
                  if switch_facts["network_services_l3"] is True:
                      # mlag l3 peering
                      if vrf.get("mlagL3PeeringDetails") and vrf["mlagL3PeeringDetails"].get("vrfMlagPeerL3Vlan"):
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_ibgp_peering_vlan"] = vrf["mlagL3PeeringDetails"]["vrfMlagPeerL3Vlan"]
                      
                          if vrf["mlagL3PeeringDetails"].get("vrfMlagPeerL3IPv4Pool", "") != "":
                              mlag_ibgp_peering_ipv4_pool = vrf["mlagL3PeeringDetails"]["vrfMlagPeerL3IPv4Pool"]
                              if switch_facts["mlag_role"] == "primary":
                                  mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                              switch_facts["mlag_peer_l3_subnet_mask"], "primary"))

                                  mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                                  switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                              else:
                                  mlag_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                              switch_facts["mlag_peer_l3_subnet_mask"], "secondary"))

                                  mlag_peer_l3_ip = str(get_mlag_ip(switch_facts, mlag_ibgp_peering_ipv4_pool,
                                                                                  switch_facts["mlag_peer_l3_subnet_mask"], "primary"))
                              
                          else:
                              mlag_l3_ip = switch_facts["mlag_l3_ip"]
                              mlag_peer_l3_ip = switch_facts["mlag_peer_l3_ip"]

                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_l3_ip"] = mlag_l3_ip
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_peer_l3_ip"] = mlag_peer_l3_ip
                          tenant[tenant_name]["vrfs"][vrf_name]["mlag_peer_l3_subnet_mask"] = switch_facts["mlag_peer_l3_subnet_mask"]

                      # static routes
                      if len(vrf.get("staticRoutes", [])) > 0:
                          tenant[tenant_name]["vrfs"][vrf_name]["static_routes"] = []
                          for sr in vrf.get("staticRoutes", []):
                              if device_matches_resolver_query(sr["devices"], device_id):
                                  static_route = {
                                      "destination_address_prefix": sr["routeDetails"]["destinationAddressPrefix"],
                                      "name": sr["description"].replace(" ", "_")
                                  }
                                  # gateway
                                  if sr["routeDetails"].get("gateway", "") == "":
                                      static_route["gateway"] = None
                                  else:
                                      static_route["gateway"] = sr["routeDetails"]["gateway"]
                                  # interface
                                  if sr["routeDetails"].get("interface", "") == "":
                                      static_route["interface"] = None
                                  else:
                                      static_route["interface"] = sr["routeDetails"]["interface"]
                                  # distance
                                  if sr["routeDetails"].get("distance", "") == "":
                                      static_route["distance"] = None
                                  else:
                                      static_route["distance"] = sr["routeDetails"]["distance"]
                                  # distance
                                  if sr["routeDetails"].get("tag", "") == "":
                                      static_route["tag"] = None
                                  else:
                                      static_route["tag"] = sr["routeDetails"]["tag"]
                                  # metric
                                  if sr["routeDetails"].get("metric", "") == "":
                                      static_route["metric"] = None
                                  else:
                                      static_route["metric"] = sr["routeDetails"]["metric"]
                                  
                                  tenant[tenant_name]["vrfs"][vrf_name]["static_routes"].append(static_route)

                      # redistribute static routes


                      # l3 interfaces
                      if vrf.get("l3Interfaces") and device_matches_resolver_query(vrf["l3Interfaces"], device_id):
                          # Create l3_interfaces list in tenant vrf if it doesn't already exist
                          if not tenant[tenant_name]["vrfs"][vrf_name].get("l3_interfaces"):
                              tenant[tenant_name]["vrfs"][vrf_name]["l3_interfaces"] = []
                          # Populate l3_interfaces list in tenant vrf with user input l3 interfaces
                          for l3_interface in vrf['l3Interfaces'].resolve(device=device_id).get("interfaces", []):
                              interface = {}
                              interface["interfaces"] = [l3_interface["name"]]
                              interface["nodes"] = [switch_facts["serial_number"]]
                              interface["ip_addresses"] = [l3_interface["ipAddress"]]
                              interface["enabled"] = l3_interface["enabled"]
                              if l3_interface.get("description", "") != "":
                                  interface["description"] = l3_interface["description"]
                              if l3_interface.get("mtu"):
                                  interface["mtu"] = l3_interface["mtu"]
                              if len(l3_interface.get("eosCli", [])) > 0:
                                  interface["raw_eos_cli"] = l3_interface["eosCli"]
                                  interface["raw_eos_cli"] = "\n".join(l3_interface["eosCli"])  # will use this method when extended text input type is available
                              # Check ospf
                              if switch_facts["underlay_routing_protocol"] == "ospf" and l3_interface.get("ospf"):
                                  ospf = {
                                      "enabled": l3_interface["ospf"]["enabled"],
                                      "point_to_point": l3_interface["ospf"]["pointToPoint"],
                                      "area": l3_interface["ospf"].get("area", "0"),
                                      "cost": l3_interface["ospf"].get("cost"),
                                  }
                                  # ospf authentication
                                  if l3_interface["ospf"].get("authentication", "") != "":
                                      ospf["authentication"] = l3_interface["ospf"]["authentication"]
                                  # ospf simple auth key
                                  if l3_interface["ospf"].get("simpleAuthKey", "") != "":  
                                      ospf["simpleAuthKey"] = l3_interface["ospf"]["simpleAuthKey"]
                                  # ospf message digest keys
                                  if len(l3_interface["ospf"].get("messageDigestKeys", [])) > 0:
                                      ospf["message_digest_keys"] = []
                                      for mdk in l3_interface["ospf"]["messageDigestKeys"]:
                                          ospf["message_digest_keys"].append({
                                              "id": mdk.get("id"),
                                              "hash_algorithm": mdk.get("hashAlgorithm"),
                                              "key": mdk.get("key"), 
                                          })
                                  interface["ospf"] = ospf

                              # add interface
                              tenant[tenant_name]["vrfs"][vrf_name]["l3_interfaces"].append(interface)

                      # external bgp peers
                      if switch_facts["underlay_routing_protocol"] == "bgp" and len(vrf.get('externalBgpPeers', {})) > 0:
                          tenant[tenant_name]["vrfs"][vrf_name]['bgp_peers'] = {}
                          for bgp_peer in vrf.get('externalBgpPeers', {}):
                              # check if bgp peer is to be configured on switch
                              if device_matches_resolver_query(bgp_peer['devices'], switch_facts['serial_number']):
                                  peer = {}
                                  peer['remote_as'] = bgp_peer['remoteAs']
                                  if bgp_peer.get('description') and bgp_peer['description'].strip() != "":
                                      peer['description'] = bgp_peer['description']
                                  if bgp_peer.get('password', '').strip() != "":
                                      peer['password'] = bgp_peer['password']
                                  if bgp_peer.get('sendCommunity', '').strip() != "":
                                      peer['send_community'] = bgp_peer['sendCommunity']
                                  if bgp_peer.get('nextHopSelf', '').strip() != "":
                                      peer['next_hop_self'] = bgp_peer['nextHopSelf']
                                  if bgp_peer['maxRoutes'].get('maximumRoutes'):
                                      peer['maximum_routes'] = bgp_peer['maxRoutes'].get('maximumRoutes')
                                  if bgp_peer['maxRoutes'].get('warningLimit'):
                                      peer['warning_limit_routes'] = bgp_peer['maxRoutes'].get('warningLimit')
                                  if bgp_peer['defaultOriginate'].get('ebgpPeerDefaultOriginateEnable'):
                                      peer['default_originate'] = {
                                          "always": bgp_peer['defaultOriginate'].get('always')
                                      }
                                  if bgp_peer.get('updateSource', '').strip() != "":
                                      peer['update_source'] = bgp_peer['updateSource']
                                  if bgp_peer.get('ebgpMultihop'):
                                      peer['ebgp_multihop'] = bgp_peer['ebgpMultihop']

                                  peer['nodes'] = [switch_facts['serial_number']]

                                  if bgp_peer['nextHop'].get('ipv4NextHop', '').strip() != "":
                                      peer['set_ipv4_next_hop'] = bgp_peer['nextHop']['ipv4NextHop']
                                  if bgp_peer['nextHop'].get('ipv6NextHop', '').strip() != "":
                                      peer['set_ipv6_next_hop'] = bgp_peer['nextHop']['ipv6NextHop']
                                  if bgp_peer['routeMap'].get('routeMapOut', '').strip() != "":
                                      peer['route_map_out'] = bgp_peer['routeMap']['routeMapOut']
                                  if bgp_peer['routeMap'].get('routeMapIn', '').strip() != "":
                                      peer['route_map_in'] = bgp_peer['routeMap']['routeMapIn']
                                  if bgp_peer.get('weight'):
                                      peer['weight'] = bgp_peer['weight']
                                  if bgp_peer.get('localAs'):
                                      peer['local_as'] = bgp_peer['localAs']

                                  tenant[tenant_name]["vrfs"][vrf_name]['bgp_peers'][bgp_peer['neighborIpAddress']] = peer

                      # ospf configuration
                      if (vrf["vrfOspfConfiguration"].get("vrfOspfEnabled") and switch_facts["underlay_routing_protocol"] == "ospf") \
                              or (switch_facts["underlay_routing_protocol"] == "ospf" and vrf_name == "default"):
                          ospf = {"enabled": True}
                          # process_id
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfProcessId") is not None:
                              ospf["process_id"] = vrf["vrfOspfConfiguration"]["vrfOspfProcessId"]
                          else:
                              ospf["process_id"] = switch_facts["underlay_ospf_process_id"]
                          # max lsa
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfMaxLsa") is not None:
                              ospf["max_lsa"] = vrf["vrfOspfConfiguration"]["vrfOspfMaxLsa"]
                          else:
                              ospf["max_lsa"] = switch_facts["underlay_ospf_max_lsa"]
                          # bfd
                          if vrf.get("vrfOspfConfiguration", {}).get("vrfOspfBfd", "") != "":
                              ospf["bfd"] = True if vrf["vrfOspfConfiguration"]["vrfOspfBfd"] == "Yes" else False
                          else:
                              ospf["bfd"] = switch_facts["underlay_ospf_bfd_enable"]
                          # add ospf details to vrf
                          tenant[tenant_name]["vrfs"][vrf_name]["ospf"] = ospf

              for vlan in all_vlans:
                  vlan_id = vlan["vlanId"]
                  svi = {}
                  if vlan["sviDetails"].get("vrf", "") == "":
                      vrf_name =  "default"
                  else:
                      vrf_name = vlan["sviDetails"]["vrf"]
                  if switch_facts["network_services_l2"] is True:
                      svi = {
                          "name": vlan.get("name", None),
                          "description": None,
                          "ip_virtual_router_addresses": [],
                          "ip_helpers": {},
                          "nodes": {},
                          "mtu": vlan.get("mtu"),
                      }
                      if switch_facts["campus_type"] == "l2ls":
                          # virtual ip
                          virtual_ip = vlan["sviDetails"].get("sviIpVirtualRouterAddress")
                          svi["ip_virtual_router_addresses"].append(virtual_ip)


                          # Set primary/secondary node ip address
                          if switch_facts["type"] == "spline":
                              try:
                                  if switch_facts["mlag_role"] == "secondary":
                                      # Get/Set secondary ip
                                      ip_address = vlan["sviDetails"].get("secondarySwitchSviIpAddress", "")
                                      if ip_address == "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[2]}/{ip_network.prefixlen}"
                                  else:
                                      # Get/Set primary ip
                                      ip_address = vlan["sviDetails"].get("primarySwitchSviIpAddress", "")
                                      if ip_address == "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[1]}/{ip_network.prefixlen}"
                                  svi["nodes"][switch_facts["serial_number"]] = {"ip_address": ip_address}
                              except IndexError as e:
                                  assert False, f"VLAN {vlan_id}'s virtual IP address does not have a subnet mask.  If the virtual IP address is not entered in CIDR notation, there must be input values for the primary and secondary switch IP addresses."

                      else:
                          # virtual ip
                          virtual_ip = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('sviIpVirtualRouterAddress')
                          svi["ip_virtual_router_addresses"].append(virtual_ip)

                          # Set primary/secondary node ip address
                          if switch_facts["type"] == "leaf":
                              try:
                                  if switch_facts["mlag_role"] == "secondary":
                                      # Get/Set secondary ip
                                      ip_address = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('secondarySwitchSviIpAddress', "")
                                      if ip_address == "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[2]}/{ip_network.prefixlen}"
                                  else:
                                      # Get/Set primary ip
                                      ip_address = vlan['campusPod'].resolve(device=device_id)['podDetails'].get('primarySwitchSviIpAddress', "")
                                      if ip_address == "":
                                          ip_network = ipaddress.ip_interface(virtual_ip).network
                                          ip_address = f"{list(ip_network.hosts())[1]}/{ip_network.prefixlen}"
                                  svi["nodes"][switch_facts["serial_number"]] = {"ip_address": ip_address}
                              except IndexError as e:
                                  assert False, f"VLAN {vlan_id}'s virtual IP address does not have a subnet mask.  If the virtual IP address is not entered in CIDR notation, there must be input values for the primary and secondary switch IP addresses."

                      # ip helper configuration
                      for ip_helper in vlan.get("dhcpHelpers", []):
                          svi['ip_helpers'][ip_helper.get("dhcpServer")] = {
                              "source_interface": ip_helper.get("dhcpSourceInterface")
                          }

                      # ospf configuration
                      if switch_facts.get("underlay_routing_protocol", "") == "ospf" and vlan.get("sviOspfConfiguration"):
                          svi["ospf"] = {
                              "enabled": vlan["sviOspfConfiguration"]["enabled"],
                              "point_to_point": vlan["sviOspfConfiguration"]["pointToPoint"],
                              "area": vlan["sviOspfConfiguration"].get("area", "0"),
                              "cost": vlan["sviOspfConfiguration"].get("cost"),
                          }
                          # ospf authentication
                          if vlan["sviOspfConfiguration"].get("authentication", "") != "":
                              svi["ospf"]["authentication"] = vlan["sviOspfConfiguration"]["authentication"]
                          # ospf simple auth key
                          if vlan["sviOspfConfiguration"].get("simpleAuthKey", "") != "":  
                              svi["ospf"]["simpleAuthKey"] = vlan["sviOspfConfiguration"]["simpleAuthKey"]
                          # ospf message digest keys
                          if len(vlan["sviOspfConfiguration"].get("messageDigestKeys", [])) > 0:
                              svi["ospf"]["message_digest_keys"] = []
                              for mdk in vlan["sviOspfConfiguration"]["messageDigestKeys"]:
                                  svi["ospf"]["message_digest_keys"].append({
                                      "id": mdk.get("id"),
                                      "hash_algorithm": mdk.get("hashAlgorithm"),
                                      "key": mdk.get("key"), 
                                  }
                                  )
                          
                      # eos cli
                      if len(vlan.get("eosCli", [])) > 0:
                          svi["raw_eos_cli"] = vlan["eosCli"]
                          # svi["raw_eos_cli"] = "\n".join(vlan["eosCli"])  # will use this method when extended text input type is available

                      # vlan mst instance

                      # vlan stp priority

                  tenant[tenant_name]["vrfs"][vrf_name]["svis"][vlan_id] = svi

              switch_facts["all_tenants"] = tenant
              return switch_facts


          def set_network_services_config(config, switch_facts):
              # logic (Probably will be easier to break away from AVD logic)
              if switch_facts["network_services_l2"] is True or switch_facts["network_services_l3"] is True:
                  network_services_data = {}
                  tmp_tenants = []
                  # tenants
                  for tenant in convert_dicts(switch_facts["all_tenants"]):
                      if tenant["name"] in switch_facts.get('tenants', []):
                          switch_tenant = switch_facts["all_tenants"][tenant["name"]]
                          # vrfs
                          tmp_vrfs = []
                          for vrf in convert_dicts(tenant["vrfs"]):
                              if vrf["name"] in switch_tenant.get("vrfs", []):
                                  switch_vrf = switch_tenant["vrfs"][vrf["name"]]
                                  # svis & bgp_peers
                                  tmp_svis = []
                                  for svi in convert_dicts(vrf["svis"], primary_key='id'):
                                      if svi["id"] in switch_vrf.get("svis", []):
                                          tmp_svis.append(svi)
                                  vrf.update({'svis': tmp_svis, 'bgp_peers': vrf.get("bgp_peers", {})})
                                  tmp_vrfs.append(vrf)
                      # l2vlans
                      tmp_l2vlans = []
                      # for l2vlan in tenant.l2vlans | arista.avd.convert_dicts('id') | arista.avd.natural_sort('id')
                      #     if l2vlan.id in switch_tenant.l2vlans | arista.avd.default([])
                      #         tmp_l2vlans.append(l2vlan)

                      tenant.update({'vrfs': tmp_vrfs, 'l2vlans': tmp_l2vlans})
                      tmp_tenants.append(tenant)
                  network_services_data["tenants"] = tmp_tenants

                  # Log network services data
                  # ctx.info(f"Network Services Data: {network_services_data}")

              # l2
              if switch_facts["network_services_l2"]:
                  # vlans
                  # tenant vlans #}
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # Tenant VLANs w/SVIs #}
                          for svi in vrf["svis"]:
                              if svi.get("id"):
                                  vlan = {"tenant": tenant["name"]}
                                  if svi.get("name", "") != "":
                                      vlan["name"] = svi["name"]
                                  config["vlans"][svi["id"]] = vlan

                          # VLAN for iBGP peering in overlay VRFs #}
                          if switch_facts.get("mlag_l3", False) is True:
                              configure_mlag_ibgp_peering = vrf.get("enable_mlag_ibgp_peering_vrfs", True)
                              if configure_mlag_ibgp_peering and vrf.get("mlag_ibgp_peering_vlan"):
                                  vlan = {
                                      "tenant": tenant["name"],
                                      "name": f"MLAG_iBGP_{vrf['name']}",
                                      "trunk_groups": ["LEAF_PEER_L3"]
                                  }
                                  config["vlans"][vrf["mlag_ibgp_peering_vlan"]] = vlan
                      # Tenant L2 VLANs
                      for l2vlan in tenant["l2vlans"]:
                          if l2vlan.get('id'):
                              vlan = {
                                  "tenant": tenant["name"],
                              }
                              if l2vlan.get("name", "") != "":
                                  vlan["name"] = l2vlan["name"]
                              config["vlans"][l2vlan["id"]] = vlan

                  # ip-igmp-snooping

              # l2 & l3
              if switch_facts["network_services_l2"] is True and switch_facts["network_services_l3"] is True:
                  # ip-virtual-router-mac-address
                  if switch_facts.get("virtual_router_mac_address", "") != "":
                      config["ip_virtual_router_mac_address"] = switch_facts["virtual_router_mac_address"].lower()

                  # vlan-interface
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # tenant vlan interfaces
                          for svi in vrf["svis"]:
                              # detect if a svi_profile exists
                              if svi.get("profile"):
                                  # If exists, create a shortpath to access profile data
                                  svi_profile = svi_profiles[svi.get('profile')]
                              else:
                                  svi_profile = {}

                              svi_name = svi.get("name") # | default(svi.get("name"), svi_profile.name)

                              svi_description = default(svi.get("description"), svi_name)

                              svi_enabled = svi.get("enabled", True)  # | default(svi_profile.enabled)
                              
                              svi_ip_virtual_router_addresses = svi.get("ip_virtual_router_addresses", [])

                              svi_ip_address_virtual = svi.get("ip_address_virtual")  # default(svi.get("ip_address_virtual"), svi_profile.ip_address_virtual)

                              svi_ip_address_virtual_secondaries = svi.get("ip_address_virtual_secondaries")  # default(svi.get("ip_address_virtual_secondaries"), svi_profile.ip_address_virtual_secondaries)
                              
                              svi_mtu = svi.get("mtu")  # default(svi.get("mtu"), svi_profile.get("mtu"))

                              svi_ip_helpers = svi.get("ip_helpers")  # default(svi.get("ip_helpers"), vrf.get("ip_helpers"), svi_profile.get("ip_helpers")) 

                              svi_raw_eos_cli = svi.get("raw_eos_cli")  # default(svi.get("raw_eos_cli"), svi_profile.get("raw_eos_cli"))

                              vlan = {}
                              vlan["tenant"] = tenant["name"]
                              if svi_description.strip() != "":
                                  vlan["description"] = svi_description

                              if svi_enabled is True:
                                  vlan["shutdown"] = False
                              else:
                                  vlan["shutdown"] = True

                              vlan["vrf"] = vrf["name"]

                              # IP address configuration
                              if svi.get("nodes",{}).get(switch_facts['serial_number'], {}).get("ip_address"):
                                  vlan["ip_address"] = svi["nodes"][switch_facts['serial_number']]["ip_address"]
                              # Virtual Router IP Address
                              vlan["ip_virtual_router_addresses"] = svi_ip_virtual_router_addresses

                              # Virtual IP address
                              if svi_ip_address_virtual is not None:
                                  vlan["ip_address_virtual"] = svi_ip_address_virtual

                              # Virtual Secondary IP address
                              if svi_ip_address_virtual_secondaries is not None:
                                  vlan["ip_address_virtual_secondaries"] = svi_ip_address_virtual_secondaries
                              
                              # MTU definition
                              if svi_mtu is not None:
                                  vlan["mtu"] = svi_mtu

                              # IP helper configuration
                              if svi_ip_helpers is not None:
                                  vlan["ip_helpers"] = {}
                                  for helper_ip in svi_ip_helpers:
                                      vlan["ip_helpers"][helper_ip] = {
                                          "source_interface": svi_ip_helpers[helper_ip].get("source_interface"),
                                          "vrf": svi_ip_helpers[helper_ip].get("source_vrf")
                                      }

                              # ospf
                              if svi.get("ospf", {}).get("enabled", False) is True and vrf.get("ospf", {}).get("enabled", True) is True:
                                  # ospf area
                                  vlan["ospf_area"] = default(svi["ospf"]["area"], "0")

                                  # ospf network point to point
                                  vlan["ospf_network_point_to_point"] = default(svi["ospf"]["point_to_point"], False)

                                  # ospf cost
                                  if svi["ospf"].get("cost"):
                                      vlan["ospf_cost"] = svi["ospf"]["cost"]

                                  # authentication
                                  if svi["ospf"].get("authentication", "") == "simple" and svi["ospf"].get("simple_auth_key", "") != "":
                                      vlan["ospf_authentication"] = "simple"
                                      vlan["ospf_authentication"] = svi["ospf"]["simple_auth_key"]
                                  
                                  elif svi["ospf"].get("authentication", "") == "message-digest" and svi["ospf"].get("message_digest_keys"):
                                      vlan["ospf_authentication"] = "message-digest"
                                      vlan["ospf_message_digest_keys"] = {}
                                      for key in svi["ospf"].get("message-message_digest_keys", []):
                                          if key.get("id") and key.get("key"):
                                              vlan["ospf_message_digest_keys"][key["id"]] = {
                                                  "hash_algorithm": default(key.get("hash_algorithm"), "sha512"),
                                                  "key": key.get("key")
                                              }

                              # raw eos cli
                              if svi_raw_eos_cli is not None:
                                  vlan["eos_cli"] = svi_raw_eos_cli  # May need to indent each line by 6 spaces when input type changes to extended string

                              config["vlan_interfaces"][f"Vlan{svi['id']}"] = vlan

                          # VLAN interface for iBGP peering in overlay VRFs
                          if switch_facts.get("mlag_l3", False) is True:
                              configure_mlag_ibgp_peering = vrf.get("enable_mlag_ibgp_peering_vrfs", True)
                              if configure_mlag_ibgp_peering and vrf.get("mlag_ibgp_peering_vlan"):
                                  config["vlan_interfaces"][f"Vlan{vrf['mlag_ibgp_peering_vlan']}"] = {
                                      "tenant": tenant["name"],
                                      "type": "underlay_peering",
                                      "shutdown": False,
                                      "description": f"MLAG_PEER_L3_iBGP: vrf {vrf['name']}",
                                      "vrf": vrf["name"],
                                      "ip_address": f"{vrf['mlag_l3_ip']}/{vrf['mlag_peer_l3_subnet_mask']}",
                                      "mtu": switch_facts["p2p_uplinks_mtu"]
                                  }                    

              # l3
              if switch_facts["network_services_l3"] is True:
                  # ethernet-interfaces 
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          # configure ethernet interfaces
                          if vrf.get('l3_interfaces') is not None:
                              l3_interface_subif_parents = []
                              for l3_interface in vrf['l3_interfaces']:
                                  eth_iface = {}
                                  l3_interface_subif_id = None
                                  if "." in l3_interface['interfaces'][0]:
                                      if l3_interface.get('encapsulation_dot1q_vlan'):
                                          l3_interface_subif_id = l3_interface['encapsulation_dot1q_vlan']
                                      else:
                                          l3_interface_subif_id = l3_interface['interfaces'][0].split('.')[1]
                                      l3_interface_subif_parents.append(l3_interface['interfaces'][0].split('.')[0])
                                  if l3_interface_subif_id is not None:
                                      eth_iface['type'] = "l3dot1q"
                                      eth_iface['encapsulation_dot1q_vlan'] = l3_interface_subif_id
                                  else:
                                      eth_iface['type'] = "routed"
                                  eth_iface['peer_type'] = "l3_interface"
                                  eth_iface['vrf'] = vrf['name']
                                  eth_iface['ip_address'] = l3_interface['ip_addresses'][0]
                                  if l3_interface.get('mtu'):
                                      eth_iface['mtu'] = l3_interface['mtu']
                                  if l3_interface.get('enabled'):
                                      eth_iface['shutdown'] = False
                                  else:
                                      eth_iface['shutdown'] = True
                                  if l3_interface.get('description') and l3_interface['description'].strip() != "":
                                      eth_iface['description'] = l3_interface['description']
                                  if l3_interface.get("ospf") and vrf.get("ospf"):
                                      if l3_interface["ospf"].get("enabled") and vrf["ospf"].get("enabled"):
                                          # area
                                          eth_iface["ospf_area"] = l3_interface["ospf"].get("area", "0")

                                          # ospf network point to point
                                          eth_iface["ospf_network_point_to_point"] = default(l3_interface["ospf"]["point_to_point"], True)

                                          # ospf cost
                                          if l3_interface["ospf"].get("cost"):
                                              eth_iface["ospf_cost"] = l3_interface["ospf"]["cost"]

                                          # authentication
                                          if l3_interface["ospf"].get("authentication", "") == "simple" and l3_interface["ospf"].get("simple_auth_key", "") != "":
                                              eth_iface["ospf_authentication"] = "simple"
                                              eth_iface["ospf_authentication"] = l3_interface["ospf"]["simple_auth_key"]
                                          
                                          elif l3_interface["ospf"].get("authentication", "") == "message-digest" and l3_interface["ospf"].get("message_digest_keys"):
                                              eth_iface["ospf_authentication"] = "message-digest"
                                              eth_iface["ospf_message_digest_keys"] = {}
                                              for key in l3_interface["ospf"].get("message-message_digest_keys", []):
                                                  if key.get("id") and key.get("key"):
                                                      eth_iface["ospf_message_digest_keys"][key["id"]] = {
                                                          "hash_algorithm": default(key.get("hash_algorithm"), "sha512"),
                                                          "key": key.get("key")
                                                      }


                                  if l3_interface.get('eos_cli'):
                                      eth_iface['eos_cli'] = l3_interface['eos_cli']
                                  config['ethernet_interfaces'][l3_interface['interfaces'][0]] = eth_iface
                              for parent_iface in l3_interface_subif_parents:
                                  config['ethernet_interfaces'][parent_iface] = {
                                      "type": "routed",
                                      "peer_type": "l3_interface",
                                      "shutdown": False
                                  }


                  # route-maps
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]: 
                          # configure route maps
                          for peer, peer_info in vrf.get('bgp_peers', {}).items():
                              if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                  config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"] = {
                                      "sequence_numbers": {
                                          10: {
                                              "type": "permit",
                                              "set": []
                                          }
                                      }
                                  }
                                  if peer_info.get('set_ipv4_next_hop'):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ip next-hop {peer_info['set_ipv4_next_hop']}")
                                  elif peer_info.get('set_ipv6_next_hop'):
                                      (config['route_maps'][f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"]
                                      ['sequence_numbers'][10]['set']).append(f"ipv6 next-hop {peer_info['set_ipv6_next_hop']}")

                  # static-routes 
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          for static_route in vrf.get("static_routes", []):
                              sr = {}
                              sr["destination_address_prefix"] = static_route.get("destination_address_prefix")
                              sr["vrf"] = vrf["name"]
                              sr["gateway"] = static_route.get("gateway")
                              sr["distance"] = static_route.get("distance")
                              sr["tag"] = static_route.get("tag")
                              sr["name"] = static_route.get("name")
                              sr["metric"] = static_route.get("metric")
                              sr["interface"] = static_route.get("interface")
                              config["static_routes"].append(sr)

                          for svi in vrf.get("svis", []):
                              svi_varp = svi.get("ip_virtual_router_addresses", [])
                              for dest_addr_prefix in svi_varp:
                                  if "/" in dest_addr_prefix:
                                      config["static_routes"].append({
                                          "destination_address_prefix": str(ipaddress.ip_interface(dest_addr_prefix).network),
                                          "vrf": vrf["name"],
                                          "name": "VARP",
                                          "interface": f"Vlan{svi['id']}"
                                      })

                  # vrfs 
                  for tenant in network_services_data["tenants"]:
                      for vrf in tenant["vrfs"]:
                          config["vrfs"][vrf["name"]] = {
                              "tenant": tenant["name"],
                              "ip_routing": True
                          }

                  # router-ospf
                  if switch_facts["underlay_routing_protocol"] == "ospf":
                      for tenant in network_services_data["tenants"]:
                          for vrf in tenant["vrfs"]:
                              if vrf.get("ospf") and vrf["ospf"].get("enabled"):
                                  network_services_data["ospf_configured"] = True
                                  break

                      if network_services_data.get("ospf_configured"):
                          # config["router_ospf"]["process_ids"][]
                          for tenant in network_services_data["tenants"]:
                              for vrf in tenant["vrfs"]:
                                  if vrf.get("ospf") and vrf["ospf"].get("enabled"):
                                      vrf_ospf_interfaces = []
                                      ospf_process_id = vrf["ospf"]["process_id"]
                                      ospf_router_id = vrf["ospf"].get("router_id", switch_facts["router_id"])
                                      for l3_interface in vrf.get("l3_interfaces", []):
                                          if switch_facts["serial_number"] in l3_interface.get("nodes", []) and l3_interface.get("interfaces") and l3_interface.get("ospf", {}).get("enabled"):
                                              for i, node in enumerate(l3_interface["nodes"]):
                                                  if node == switch_facts["serial_number"]:
                                                      vrf_ospf_interfaces.append(l3_interface["interfaces"][i])
                                      for svi in vrf.get("svis", []):
                                          vrf_ospf_interfaces.append(f"Vlan{svi['id']}")
                                      if switch_facts.get("mlag_l3") and vrf.get("mlag_ibgp_peering_vlan"):
                                          vrf_ospf_interfaces.append("Vlan{}".format(vrf["mlag_ibgp_peering_vlan"]))
                                      if ospf_process_id not in config["router_ospf"]["process_ids"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id] = {}
                                      # vrf
                                      config["router_ospf"]["process_ids"][ospf_process_id]["vrf"] = vrf["name"]
                                      # passive interface default
                                      config["router_ospf"]["process_ids"][ospf_process_id]["passive_interface_default"] = True
                                      # ospf_router_id
                                      config["router_ospf"]["process_ids"][ospf_process_id]["router_id"] = ospf_router_id
                                      # no passive interfaces
                                      config["router_ospf"]["process_ids"][ospf_process_id]["no_passive_interfaces"] = config["router_ospf"]["process_ids"][ospf_process_id].get("no_passive_interfaces", []) + vrf_ospf_interfaces
                                      # bfd enable
                                      if vrf["ospf"]["bfd"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id]["bfd_enable"] = True
                                      # max_lsa
                                      if vrf["ospf"]["max_lsa"]:
                                          config["router_ospf"]["process_ids"][ospf_process_id]["max_lsa"] = vrf["ospf"]["max_lsa"]
                                      # redistribute bgp
                                      if vrf["ospf"].get("redistribute_bgp", {}).get("enabled"):
                                          # set if not already set
                                          if not config["router_ospf"]["process_ids"][ospf_process_id].get("redistribute"):
                                              config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"] = {"bgp": {}}
                                          # enable
                                          config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"]["bgp"]["enabled"] = True
                                          # route-map
                                          if vrf["ospf"]["redistribute_bgp"].get("route_map"):
                                              config["router_ospf"]["process_ids"][ospf_process_id]["redistribute"]["bgp"]["route_map"] = vrf["ospf"]["redistribute_bgp"]["route_map"]

                  # router-bgp
                  if switch_facts["underlay_routing_protocol"] == "bgp":
                      config['router_bgp']['vrfs'] = {}
                      for tenant in network_services_data["tenants"]:
                          for vrf in tenant["vrfs"]:
                              address_family_ipv4_neighbors = []
                              address_family_ipv6_neighbors = []
                              # initialize vrf
                              config['router_bgp']['vrfs'][vrf['name']] = {
                                  "router_id": switch_facts['router_id'],
                                  "route_distinguisher": vrf.get("route_distinguisher"),
                                  "neighbors": {},
                                  "redistribute_routes": {
                                      # "connected": {}
                                      # "attached-host": {}
                                  },
                                  "address_families": {
                                      "ipv4": {"neighbors": {}, "networks": {}},
                                      "ipv6": {"neighbors": {}, "networks": {}}
                                  },
                                  "eos_cli": []
                              }
                              if vrf['name'] != "default":
                                  config['router_bgp']['vrfs'][vrf['name']]['redistribute_routes']['connected'] = {}
                              # mlag ibgp peer
                              if switch_facts.get('mlag_l3') and vrf.get('mlag_peer_l3_ip'):
                                  # Add mlag_ip to nieghbors and address family
                                  config['router_bgp']['vrfs'][vrf['name']]['neighbors'][vrf['mlag_peer_l3_ip']] = {
                                      "remote_as": switch_facts['bgp_as'],
                                      "description": switch_facts['mlag_peer'],
                                      "send_community": "all",
                                      "next_hop_self": True,
                                  }
                                  address_family_ipv4_neighbors.append(vrf['mlag_peer_l3_ip'])
                              # external bgp peers
                              for peer, peer_info in vrf.get('bgp_peers', {}).items():
                                  if validIPAddress(peer) is True:
                                      address_family_ipv4_neighbors.append(peer)
                                  elif validIPAddress(peer) is False:
                                      address_family_ipv6_neighbors.append(peer)
                                  else:
                                      ctx.warning(f"Invalid BGP peer address provided: {switch_facts['site']} Services -> VRF {vrf['name']} -> {peer}")
                                      continue
                                  if peer_info.get('set_ipv4_next_hop') or peer_info.get('set_ipv6_next_hop'):
                                      peer_info.update({"route_map_out": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"})
                                      if peer_info.get('default_originate'):
                                          if not peer_info['default_originate'].get('route_map'):
                                              peer_info['default_originate'].update(
                                                  {"route_map": f"RM-{vrf['name']}-{peer}-SET-NEXT-HOP-OUT"}
                                              )
                                      if peer_info.get('set_ipv4_next_hop'):
                                          peer_info.pop("set_ipv4_next_hop")
                                      if peer_info.get('set_ipv6_next_hop'):
                                          peer_info.pop("set_ipv6_next_hop")
                                  config['router_bgp']['vrfs'][vrf['name']]['neighbors'][peer] = peer_info


              return config


          # Get studio info from ctx
          my_device = ctx.getDevice()
          workspace_id = ctx.studio.workspaceId

          # Initialize variables
          my_switch_facts = {}
          my_config = {}

          # Pre-populate dictionaries used for getting switch facts
          role_dict = populate_multi_value_dict(workspace_id, 'Role')

          campus_dict = populate_single_value_dict(workspace_id, 'Campus')
          site_dict = populate_single_value_dict(workspace_id, 'Site')
          campus_pod_dict = populate_single_value_dict(workspace_id, 'Campus-Pod')
          node_id_dict = populate_single_value_dict(workspace_id, 'NodeId')

          # Set my_switch_facts' switch properties
          my_switch_facts = set_switch_facts_properties(my_device.id, campus)

          ctx.info(f"{my_switch_facts['hostname']} Device Properties: {my_switch_facts}")

          if my_switch_facts is None:
              return

          # Set all switches in same site as my_switch's switch_facts properties
          all_switch_facts_in_my_site = set_switch_facts_properties_for_query("Site", my_switch_facts["site"], campus)

          # Set uplink info for all switch_facts in all_switch_facts_in_my_site
          for switch_facts in all_switch_facts_in_my_site.values():
              switch_facts = set_switch_uplink_info(switch_facts, campus)

          # The below can probably be done just on my_switch_facts at first but then needs to be done on all of my_switch_facts neighbors
          # Set downlink info for my_switch_facts from all_switch_facts_in_my_site
          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] == my_switch_facts["serial_number"]:
                  switch_facts = set_switch_downlink_info(switch_facts)

          my_neighbors = all_switch_facts_in_my_site[my_switch_facts["serial_number"]]["uplink_switches_ids"] + \
                          all_switch_facts_in_my_site[my_switch_facts["serial_number"]]["downlink_switches_ids"]

          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] in my_neighbors:
                  switch_facts = set_switch_downlink_info(switch_facts)

          # Set switch_facts for all of my_switch_facts neighbors and my_switch_facts
          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] in my_neighbors + [my_switch_facts["serial_number"]]:
                  switch_facts = set_switch_facts(switch_facts, campus)

          # Get network services applied to each campus_pod switch (part 1a)
          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] in my_neighbors + [my_switch_facts["serial_number"]] and switch_facts["type"] in ["leaf", "memberleaf"]:
                  switch_facts = get_network_services_leaf_switch(switch_facts, campus)

          # Get network services applied to each spline switch (part 1b)
          #  Need to get network services for spline switches after campus pod leaf switches because
          #  the studio does not allow users to assign VLANs to spline switches so VLANs are assigned to splines
          #  based on downstream campus pod VLANs
          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] in my_neighbors + [my_switch_facts["serial_number"]] and switch_facts["type"] in ["spline"]:
                  switch_facts = get_network_services_spline_switch(switch_facts)

          # Set topology facts ( in order to set transit p2p and port-channel links ) 
          for switch_facts in all_switch_facts_in_my_site.values():
              if switch_facts["serial_number"] in my_neighbors + [my_switch_facts["serial_number"]]:
                  switch_facts = set_topology_facts(switch_facts)

          # Get my_switch_facts from all_switch_facts_in_my_site
          my_switch_facts = all_switch_facts_in_my_site[my_switch_facts["serial_number"]]

          # Get network services in AVD format (part 2)
          my_switch_facts = get_tenants(my_switch_facts, campus)

          ctx.info(f"Tenants: {my_switch_facts['all_tenants']}")


          # Set structured config
          my_config = {
              "spanning_tree": {},
              "vlans": {},
              "vlan_interfaces": {},
              "port_channel_interfaces": {},
              "ethernet_interfaces": {},
              "loopback_interfaces": {},
              "prefix_lists": {},
              "route_maps": {},
              ## "router_bfd": {},
              "router_bgp": {
                  "peer_groups": {},
                  "address_family_ipv4": {
                      "peer_groups": {}
                  },
                  "address_family_evpn": {
                      "peer_groups": {}
                  },
                  "neighbor_interfaces": {},
                  "neighbors": {},
                  "redistribute_routes": {
                      "connected": {}
                  }
              },
              "router_ospf": {
                  "process_ids": {}
              },
              "vrfs": {},
              "virtual_source_nat_vrfs": {},
              "static_routes": []
          }

          my_config = set_base_config(my_config, my_switch_facts)
          my_config = set_mlag_config(my_config, my_switch_facts)
          my_config = set_underlay_config(my_config, my_switch_facts)
          my_config = set_overlay_config(my_config, my_switch_facts)
          my_config = set_vxlan_config(my_config, my_switch_facts)
          my_config = set_inband_management_config(my_config, my_switch_facts)
          my_config = set_network_services_config(my_config, my_switch_facts)

          config = my_config
          %>
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - routing model
          % if config.get("service_routing_protocols_model") is not None and config.get("service_routing_protocols_model") == "multi-agent":
          service routing protocols model multi-agent
          !
          % endif
          ## eos - spanning-tree
          % if config.get("spanning_tree") is not None:
          %     if config["spanning_tree"].get("mode") is not None:
          spanning-tree mode ${ config["spanning_tree"].get("mode") }
          %     endif
          %     if config["spanning_tree"].get("no_spanning_tree_vlan") is not None:
          no spanning-tree vlan-id ${ config["spanning_tree"].get("no_spanning_tree_vlan") }
          %     endif
          %     if config["spanning_tree"].get("mode", "") == "mstp":
          %         for mst_instance_id in natural_sort(config["spanning_tree"].get("mst_instances", {}).keys()):
          %             if config["spanning_tree"]["mst_instances"][mst_instance_id].get("priority"):
          spanning-tree mst ${ mst_instance_id } priority ${ config["spanning_tree"]["mst_instances"][mst_instance_id]["priority"] }
          %             endif
          %         endfor

          %     elif  config["spanning_tree"].get("mode", "") == "rapid-pvst":
          %         for vlan_id in natural_sort(config["spanning_tree"].get("rapid_pvst_instances", {}).keys()):
          %             if config["spanning_tree"]["rapid_pvst_instances"][vlan_id].get("priority"):
          spanning-tree vlan-id ${ vlan_id } priority ${ config["spanning_tree"]["rapid_pvst_instances"][vlan_id]["priority"] }
          %             endif
          %         endfor
          %     else:
          %         if config["spanning_tree"].get("rstp_priority"):
          spanning-tree priority ${ config["spanning_tree"]["rstp_priority"] }
          %         endif
          %     endif
          %     if config['spanning_tree'].get('mst', {}).get('configuration'):
          !
          spanning-tree mst configuration
          %         if config['spanning_tree']['mst']['configuration'].get('name'):
             name ${ config['spanning_tree']['mst']['configuration']['name'] }
          %         endif
          %         if config['spanning_tree']['mst']['configuration'].get('revision'):
             revision ${ config['spanning_tree']['mst']['configuration']['revision'] }
          %         endif
          %         for instance in natural_sort(config['spanning_tree']['mst']['configuration'].get('instances', {}).keys()):
          %             if config['spanning_tree']['mst']['configuration']['instances'][instance].get('vlans'):
             instance ${ instance } vlan ${ list_compress(config['spanning_tree']['mst']['configuration']['instances'][instance]['vlans']) }
          %             endif
          %         endfor
          %     endif
          !
          % endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
             name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
             state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
             trunk group ${ trunk_group }
          %               endfor
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          %     if vrf != "default":
          vrf instance ${ vrf }
          %       if config["vrfs"][vrf].get("description"):
             description ${ config["vrfs"][vrf]["description"] }
          %       endif
          %     endif
          !
          %   endfor
          %endif
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
             description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
             shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
             mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
             no switchport
          %     else:
             switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
             switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif %}
          %     if config["port_channel_interfaces"][port_channel_interface].get("vlans") and config["port_channel_interfaces"][port_channel_interface]["mode"] == "trunk":
             switchport trunk allowed vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
             switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
             switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mlag"):
             mlag ${ config["port_channel_interfaces"][port_channel_interface]["mlag"] }
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
             description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("boot_vlan"):
             lldp tlv transmit ztp vlan ${config["ethernet_interfaces"][ethernet_interface]["boot_vlan"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
             channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
             mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
             no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type", "") in ["l2dot1q", "l3dot1q"]:
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlan_id") and config["ethernet_interfaces"][ethernet_interface]["type"] == 'l2dot1q':
             vlan id ${ config["ethernet_interfaces"][ethernet_interface]["vlan_id"] }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
             encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %             endif
          %         else:
             switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
             switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
             switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
             switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
             switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
             vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
             ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_cost"):
             ip ospf cost ${ config["ethernet_interfaces"][ethernet_interface]["ospf_cost"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_authentication") is not None:
          %           if config["ethernet_interfaces"][ethernet_interface]["ospf_authentication"] == "simple":
             ip ospf authentication
          %           elif config["ethernet_interfaces"][ethernet_interface]["ospf_authentication"] == "message-digest":
             ip ospf authentication message-digest
          %           endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_authentication_key") is not None:
             ip ospf authentication-key 7 ${ config["ethernet_interfaces"][ethernet_interface]["ospf_authentication_key"] }
          %         endif
          %         for ospf_message_digest_key in natural_sort(config["ethernet_interfaces"][ethernet_interface].get("ospf_message_digest_keys", [])):
          %           if config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("hash_algorithm") is not None and config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("key") is not None:
             ip ospf message-digest-key ${ ospf_message_digest_key } ${ config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["hash_algorithm"] } 7 ${ config["ethernet_interfaces"][ethernet_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["key"] }
          %           endif
          %         endfor
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %         for cli_statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
             ${cli_statement}
          %         endfor
          %     endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
             description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
             shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
             no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
             vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
             ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          %     if config["loopback_interfaces"][loopback_interface].get("ospf_area"):
             ip ospf area ${ config["loopback_interfaces"][loopback_interface]["ospf_area"] }
          %     endif
          !
          %   endfor
          %endif
          ## eos - Management Interfaces
          % for management_interface in natural_sort( config.get("management_interfaces", {}).keys() ):
          interface ${ management_interface }
          %     if config["management_interfaces"][management_interface].get("description"):
            description ${ config["management_interfaces"][management_interface]["description"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("shutdown") and config["management_interfaces"][management_interface]["shutdown"] is True:
             shutdown
          %     elif config["management_interfaces"][management_interface].get("shutdown") and config["management_interfaces"][management_interface]["shutdown"] is False:
             no shutdown
          %     endif
          %     if config["management_interfaces"][management_interface].get("vrf") and config["management_interfaces"][management_interface]["vrf"] != 'default':
             vrf ${ config["management_interfaces"][management_interface]["vrf"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("ip_address"):
             ip address ${ config["management_interfaces"][management_interface]["ip_address"] }
          %     endif
          %     if config["management_interfaces"][management_interface].get("ipv6_enable") is not None and config["management_interfaces"][management_interface]["ipv6_enable"] is True:
             ipv6 enable
          %     endif
          %     if config["management_interfaces"][management_interface].get("ipv6_address"):
             ipv6 address ${ config["management_interfaces"][management_interface]["ipv6_address"] }
          %     endif
          !
          % endfor
          ## eos - VLAN Interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
             description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
             shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
             no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
             mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
             no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface].get("vrf") != 'default':
             vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
             ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries"):
             ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses", []):
             ip virtual-router address ${ ip_virtual_router_address }
          %     endfor
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
             ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config.get("vlan_interfaces")[vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
             ${ ip_helper_cli }
          %       endfor
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %      endif
          %      if config.get("vlan_interfaces")[vlan_interface].get("ospf_area"):
             ip ospf area ${ config.get("vlan_interfaces")[vlan_interface]["ospf_area"] }
          %      endif
          %      if config["vlan_interfaces"][vlan_interface].get("ospf_cost"):
             ip ospf cost ${ config["vlan_interfaces"][vlan_interface]["ospf_cost"] }
          %      endif
          %     if config["vlan_interfaces"][vlan_interface].get("ospf_authentication") is not None:
          %         if config["vlan_interfaces"][vlan_interface]["ospf_authentication"] == "simple":
             ip ospf authentication
          %         elif config["vlan_interfaces"][vlan_interface]["ospf_authentication"] == "message-digest":
             ip ospf authentication message-digest
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ospf_authentication_key") is not None:
             ip ospf authentication-key 7 ${ config["vlan_interfaces"][vlan_interface]["ospf_authentication_key"] }
          %     endif
          %     for ospf_message_digest_key in natural_sort(config["vlan_interfaces"][vlan_interface].get("ospf_message_digest_keys", [])):
          %         if config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("hash_algorithm") is not None and config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key].get("key") is not None:
             ip ospf message-digest-key ${ ospf_message_digest_key } ${ config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["hash_algorithm"] } 7 ${ config["vlan_interfaces"][vlan_interface]["ospf_message_digest_keys"][ospf_message_digest_key]["key"] }
          %         endif
          %     endfor
          %     if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %         for cli_statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
             ${cli_statement}
          %         endfor
          %     endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
             vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("source_interface"):
             vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["source_interface"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
             vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
             vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
             vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## eos - tcam profile
          % if config.get("tcam_profile") is not None:
          hardware tcam
          %     if config["tcam_profile"].get("system") is not None:
             system profile ${ config["tcam_profile"]["system"] }
          %     endif
          !
          % endif
          ## eos - ip virtual router mac
          % if config.get("ip_virtual_router_mac_address") is not None:
          ip virtual-router mac-address ${ config["ip_virtual_router_mac_address"] }
          !
          % endif
          ## eos - IP Routing
          % if config.get("ip_routing") == True:
          ip routing
          !
          % elif config.get("ip_routing") == False:
          no ip routing
          !
          % endif
          ## eos - VRFs
          % if config.get('vrfs'):
          %   for vrf in config["vrfs"]:
          %       if config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config["vrfs"][vrf].get("ip_routing") is not None and config["vrfs"][vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % for static_route in config.get("static_routes", []):
          <%    static_route_cli = "ip route" %>
          %     if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%        static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %     endif
          %     if static_route.get("destination_address_prefix"):
          <%        static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %     endif
          %     if static_route.get("interface"):
          <%        static_route_cli = static_route_cli + " " + static_route["interface"] %>
          %     endif
          %     if static_route.get("gateway"):
          <%        static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %     endif
          %     if static_route.get("distance"):
          <%        static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %     endif
          %     if static_route.get("tag"):
          <%        static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %     endif
          %     if static_route.get("name"):
          <%        static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %     endif
          %     if static_route.get("metric"):
          <%        static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %     endif
          ${ static_route_cli }
          !
          %    endfor %}
          ## eos - Router Multicast
          % if config.get("router_multicast"):
          router multicast
          %     if config["router_multicast"].get("ipv4"):
             ipv4
          %         if config["router_multicast"]["ipv4"].get("routing"):
                routing
          %         endif
          %         if config["router_multicast"]["ipv4"].get("multipath"):
                multipath ${ config["router_multicast"]["ipv4"]["multipath"] }
          %         endif
          %         if config["router_multicast"]["ipv4"].get("software_forwarding"):
                software-forwarding ${ config["router_multicast"]["ipv4"]["software_forwarding"] }
          %         endif
          %     endif
          !
          % endif
          ## eos - prefix-lists
          % if config.get("prefix_lists") is not None:
          %    for prefix_list in config["prefix_lists"].keys():
          ip prefix-list ${ prefix_list }
          %       for sequence in config["prefix_lists"][prefix_list]["sequence_numbers"].keys():
          %         if config["prefix_lists"][prefix_list]["sequence_numbers"][sequence].get("action") is not None:
             seq ${ sequence } ${ config["prefix_lists"][prefix_list]["sequence_numbers"][sequence]["action"] }
          %         endif
          %       endfor
          !
          %    endfor
          % endif
          ## eos - mlag configuration
          % if config.get("mlag_configuration") is not None and config["mlag_configuration"].get("enabled") == True:
          mlag configuration
          %     if config["mlag_configuration"].get("domain_id") is not None:
             domain-id ${ config["mlag_configuration"]["domain_id"] }
          %     endif
          %     if config["mlag_configuration"].get("local_interface") is not None:
             local-interface ${ config["mlag_configuration"]["local_interface"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address") is not None:
             peer-address ${ config["mlag_configuration"]["peer_address"] }
          %     endif
          %     if config["mlag_configuration"].get("peer_address_heartbeat") is not None:
          %       if config["mlag_configuration"]["peer_address_heartbeat"].get("peer_ip") is not None:
          %           if config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") is not None and config["mlag_configuration"]["peer_address_heartbeat"].get("vrf") != 'default':
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] } vrf ${ config["mlag_configuration"]["peer_address_heartbeat"]["vrf"] }
          ## using the default VRF #}
          %           else:
             peer-address heartbeat ${ config["mlag_configuration"]["peer_address_heartbeat"]["peer_ip"] }
          %           endif
          %       endif
          %     endif
          %     if config["mlag_configuration"].get("peer_link") is not None:
             peer-link ${ config["mlag_configuration"]["peer_link"] }
          %     endif
          %     if config["mlag_configuration"].get("dual_primary_detection_delay") is not None:
             dual-primary detection delay ${ config["mlag_configuration"]["dual_primary_detection_delay"] } action errdisable all-interfaces
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_mlag") is not None:
             reload-delay mlag ${ config["mlag_configuration"]["reload_delay_mlag"] }
          %     endif
          %     if config["mlag_configuration"].get("reload_delay_non_mlag") is not None:
             reload-delay non-mlag ${ config["mlag_configuration"]["reload_delay_non_mlag"] }
          %     endif
          !
          % endif
          ## eos - Route Maps
          % if config.get("route_maps") is not None:
          %   for route_map in config["route_maps"].keys():
          %       for sequence in config["route_maps"][route_map]["sequence_numbers"].keys():
          %           if config["route_maps"][route_map]["sequence_numbers"][sequence].get("type") is not None:
          route-map ${ route_map } ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["type"] } ${ sequence }
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("description") is not None:
             description ${ config["route_maps"][route_map]["sequence_numbers"][sequence]["description"] }
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("match") is not None:
          %                   for match_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["match"]:
             match ${ match_rule }
          %                   endfor
          %               endif
          %               if config["route_maps"][route_map]["sequence_numbers"][sequence].get("set") is not None:
          %                   for set_rule in config["route_maps"][route_map]["sequence_numbers"][sequence]["set"]:
             set ${ set_rule }
          %                   endfor
          %               endif
          !
          %           endif
          %       endfor
          %   endfor
          % endif
          ## eos - peer-filters
          % if config.get("peer_filters") is not None:
          %   for peer_filter in config["peer_filters"].keys():
          peer-filter ${ peer_filter }
          %     for sequence in config["peer_filters"][peer_filter]["sequence_numbers"].keys():
          %         if config["peer_filters"][peer_filter]["sequence_numbers"][sequence].get("match") is not None:
             ${ sequence } match ${ config["peer_filters"][peer_filter]["sequence_numbers"][sequence]["match"] }
          %         endif
          %     endfor
          !
          %   endfor
          % endif
          ## eos - Router bfd
          % if config.get("router_bfd") is not None and config.get("router_bfd") != {}:
          router bfd
          %   if config["router_bfd"].get("multihop") is not None:
          %     if config["router_bfd"]["multihop"].get("interval") is not None and config["router_bfd"]["multihop"].get("min_rx") is not None and config["router_bfd"]["multihop"].get("multiplier") is not None:
             multihop interval ${ config["router_bfd"]["multihop"]["interval"] } min-rx ${ config["router_bfd"]["multihop"]["min_rx"] } multiplier ${ config["router_bfd"]["multihop"]["multiplier"] }
          %     endif
          %   endif
          !
          % endif
          ## eos - Router BGP
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
             router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("maximum_paths"):
          <% max_paths_cli = "maximum-paths {} ".format(config["router_bgp"]["maximum_paths"]) %>
          %        if config["router_bgp"].get("ecmp"):
          <% max_paths_cli += "ecmp {}".format(config["router_bgp"]["ecmp"]) %>
                  % endif
             ${max_paths_cli}
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
             bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
             neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
             neighbor ${ peer_group } shutdown
          %         endif
             neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
             neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
             neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
             neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
             neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
             neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
             neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
             neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
             neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
             neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
             neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
             neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
             neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
             neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
             neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
             neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in natural_sort(config["router_bgp"]["neighbors"].keys()):
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
             neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
             neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
             neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
             neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
             neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
             neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
             neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
             neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
             neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
             neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
             neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
             neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
             ${ redistribute_route_cli }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
             ${ bgp_default }
          %       endfor
          !
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
             vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].rd is not None:
                rd ${ config["router_bgp"]["vlans"][vlan].rd }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
             !
             vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
                rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
                route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
                route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
                route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
                redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
                vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
             !
             address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
                no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
                host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
                host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
                domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
             !
             address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
                neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
                neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
                neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
                no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
                neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
                no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
             !
             vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
                rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
                route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
                route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
                router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
                timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
                network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
                network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
                neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
                neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
                neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
                neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
                neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
                ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
                neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
                neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
                neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
                neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
                neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
                ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
                neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
                neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
                ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
                ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
             !
          % endif
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## router-ospf
          %if config.get("router_ospf") and config["router_ospf"].get("process_ids"):
          %for process_id in config["router_ospf"]["process_ids"].keys():
          %     if config["router_ospf"]["process_ids"][process_id].get("vrf"):
          router ospf ${ process_id } vrf ${ config["router_ospf"]["process_ids"][process_id]["vrf"] }
          %     else:
          router ospf ${ process_id }
          %     endif
          %     if config["router_ospf"]["process_ids"].get("log_adjacency_changes_detail"):
             log-adjacency-changes detail
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("router_id"):
             router-id ${ config["router_ospf"]["process_ids"][process_id]["router_id"] }
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("passive_interface_default"):
             passive-interface default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("no_passive_interfaces"):
          %         for interface in config["router_ospf"]["process_ids"][process_id]["no_passive_interfaces"]:
             no passive-interface ${ interface }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("network_prefixes"):
          %         for network_prefix in natural_sort(config["router_ospf"]["process_ids"][process_id]["network_prefixes"].keys()):
             network ${ network_prefix } area ${ config["router_ospf"]["process_ids"][process_id]["network_prefixes"][network_prefix]["area"] }
          %         endfor
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("bfd_enable"):
             bfd default
          %     endif
          %     if config["router_ospf"]["process_ids"][process_id].get("ospf_defaults"):
          %         for ospf_default in config["router_ospf"]["process_ids"][process_id]["ospf_defaults"]:
             ${ospf_default}
          %         endfor
          %     endif
          !
          %endfor
          %endif
      input_schema:
        fields:
          values:
            campusPodRouterIdPool:
              id: campusPodRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each leaf's Loopback0 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodUplinkIpv4Pool:
              id: campusPodUplinkIpv4Pool
              name: uplinkIpv4Pool
              label: Uplink Ipv4 Pool
              description: IPv4 subnet to use to connect to uplink switches
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerVlan:
              id: leafMlagPeerVlan
              name: mlagPeerVlan
              label: MLAG Peer VLAN
              description: MLAG Peer Link (control link) SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            leafMlagPeerIPv4Pool:
              id: leafMlagPeerIPv4Pool
              name: mlagPeerIPv4Pool
              label: MLAG Peer IPv4 Pool
              description: IP address pool used for MLAG Peer Link (control link)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerL3Vlan:
              id: leafMlagPeerL3Vlan
              name: mlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: Underlay L3 peering SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            leafMlagPeerL3IPv4Pool:
              id: leafMlagPeerL3IPv4Pool
              name: mlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IP address pool used for MLAG underlay L3 peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafVirtualRouterMacAddress:
              id: leafVirtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Virtual router mac address for anycast gateway
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfaceName:
              id: leafMlagPeerInterfaceName
              name: mlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagPeerInterfaces:
              id: leafMlagPeerInterfaces
              name: mlagPeerInterfaces
              label: MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the primary and secondary leaf in this Campus Pod.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafMlagPeerInterfaceName
                key: ''
            leafMlagDetails:
              id: leafMlagDetails
              name: mlagDetails
              label: MLAG Details
              description: MLAG settings to be applied on leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafMlagPeerVlan
                    - leafMlagPeerIPv4Pool
                    - leafMlagPeerL3Vlan
                    - leafMlagPeerL3IPv4Pool
                    - leafVirtualRouterMacAddress
                    - leafMlagPeerInterfaces
            campusPodSpanningTreeMode:
              id: campusPodSpanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - MSTP
                    - Rapid-PVST
                    - RSTP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafSpanningTreePriority:
              id: leafSpanningTreePriority
              name: leafSpanningTreePriority
              label: Leaf Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, uses EOS default. If no value is entered and L3 is selected for Campus Type, defaults to 4096.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            memberLeafSpanningTreePriority:
              id: memberLeafSpanningTreePriority
              name: memberLeafSpanningTreePriority
              label: Member Leaf Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, uses EOS default.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            campusPodSpanningTreeDetails:
              id: campusPodSpanningTreeDetails
              name: spanningTreeDetails
              label: Spanning Tree Details
              description: Spanning tree settings to be applied on Campus Pod switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodSpanningTreeMode
                    - leafSpanningTreePriority
                    - memberLeafSpanningTreePriority
            leafVtepLoopbackIPv4Pool:
              id: leafVtepLoopbackIPv4Pool
              name: vtepLoopbackIPv4Pool
              label: VTEP Loopback IPv4 Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each leaf's Loopback1 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpAsRange:
              id: campusPodBgpAsRange
              name: bgpAsns
              label: BGP AS Range
              description: Define the ASN range from which BGP ASNs are allocated to each Campus Pod's primary and secondary leaf switch.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaultsConfigStatement:
              id: campusPodBgpDefaultsConfigStatement
              name: bgpDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodBgpDefaults:
              id: campusPodBgpDefaults
              name: bgpDefaults
              label: BGP Defaults
              description: Configure additional commands under the 'router bgp' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodBgpDefaultsConfigStatement
                key: ''
            leafBgpDetails:
              id: leafBgpDetails
              name: bgpDetails
              label: BGP Details
              description: BGP settings to be applied on Leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodBgpAsRange
                    - campusPodBgpDefaults
            l2CampusInbandManagementVlan:
              id: l2CampusInbandManagementVlan
              name: inbandManagementVlan
              label: Inband Management VLAN
              description: VLAN number assigned to Inband Management SVI in default VRF
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            l2CampusInbandManagementSubnet:
              id: l2CampusInbandManagementSubnet
              name: inbandManagementSubnet
              label: Inband Management Subnet
              description: Assign a range larger than total leafs + 5
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusInbandManagementDetails:
              id: l2CampusInbandManagementDetails
              name: inbandManagementDetails
              label: Inband Management Details
              description: Inband Management settings used for Campus Pod switches.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l2CampusInbandManagementVlan
                    - l2CampusInbandManagementSubnet
            leafOspfDefaultsConfigStatement:
              id: leafOspfDefaultsConfigStatement
              name: ospfDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafOspfDefaults:
              id: leafOspfDefaults
              name: ospfDefaults
              label: OSPF Defaults
              description: Configure additional commands under the 'router ospf <process-id>' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafOspfDefaultsConfigStatement
                key: ''
            leafOspfDetails:
              id: leafOspfDetails
              name: ospfDetails
              label: OSPF Details
              description: OSPF settings to be applied on Leaf switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafOspfDefaults
            campusPodDefaults:
              id: campusPodDefaults
              name: campusPodDefaults
              label: Campus Pod Defaults
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodRouterIdPool
                    - campusPodUplinkIpv4Pool
                    - leafMlagDetails
                    - campusPodSpanningTreeDetails
                    - leafVtepLoopbackIPv4Pool
                    - leafBgpDetails
                    - l2CampusInbandManagementDetails
                    - leafOspfDetails
            splineRouterIdPool:
              id: splineRouterIdPool
              name: routerIdPool
              label: Router ID Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each spline's Loopback0 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineSpanningTreeMode:
              id: splineSpanningTreeMode
              name: spanningTreeMode
              label: Spanning Tree Mode
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: MSTP
                static_options:
                  values:
                    - RSTP
                    - MSTP
                    - Rapid-PVST
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineSpanningTreePriority:
              id: splineSpanningTreePriority
              name: splineSpanningTreePriority
              label: Spanning Tree Priority
              description: If no value is entered and L2 is selected for Campus Type, defaults to 4096. If no value is entered and L3 is selected for Campus Type, uses EOS default.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            splineSpanningTreeDetails:
              id: splineSpanningTreeDetails
              name: spanningTreeDetails
              label: Spanning Tree Details
              description: Spanning tree settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineSpanningTreeMode
                    - splineSpanningTreePriority
            splineMlagPeerVlan:
              id: splineMlagPeerVlan
              name: mlagPeerVlan
              label: MLAG Peer VLAN
              description: MLAG Peer Link (control link) SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '4094'
                range: null
                static_options: null
                dynamic_options: null
            splineMlagPeerIPv4Pool:
              id: splineMlagPeerIPv4Pool
              name: mlagPeerIPv4Pool
              label: MLAG Peer IPv4 Pool
              description: IP address pool used for MLAG Peer Link (control link)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerL3Vlan:
              id: splineMlagPeerL3Vlan
              name: mlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: Underlay L3 peering SVI interface id
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            splineMlagPeerL3IPv4Pool:
              id: splineMlagPeerL3IPv4Pool
              name: mlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: IP address pool used for MLAG underlay L3 peering
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineVirtualRouterMacAddress:
              id: splineVirtualRouterMacAddress
              name: virtualRouterMacAddress
              label: Virtual Router MAC Address
              description: Virtual router mac address for anycast gateway
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 00:1c:73:00:00:99
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfaceName:
              id: splineMlagPeerInterfaceName
              name: mlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagPeerInterfaces:
              id: splineMlagPeerInterfaces
              name: mlagPeerInterfaces
              label: MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the splines.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineMlagPeerInterfaceName
                key: ''
            splineMlagDetails:
              id: splineMlagDetails
              name: mlagDetails
              label: MLAG Details
              description: MLAG settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineMlagPeerVlan
                    - splineMlagPeerIPv4Pool
                    - splineMlagPeerL3Vlan
                    - splineMlagPeerL3IPv4Pool
                    - splineVirtualRouterMacAddress
                    - splineMlagPeerInterfaces
            splineVtepLoopbackIPv4Pool:
              id: splineVtepLoopbackIPv4Pool
              name: vtepLoopbackIPv4Pool
              label: VTEP Loopback IPv4 Pool
              description: Define the IPv4 pool from which IP addresses are allocated to each spline's Loopback1 interface.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpAsn:
              id: splineBgpAsn
              name: bgpAsns
              label: BGP ASN
              description: BGP AS assigned to spline switches
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaultsConfigStatement:
              id: splineBgpDefaultsConfigStatement
              name: bgpDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineBgpDefaults:
              id: splineBgpDefaults
              name: bgpDefaults
              label: BGP Defaults
              description: Configure additional commands under the 'router bgp' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineBgpDefaultsConfigStatement
                key: ''
            splineBgpDetails:
              id: splineBgpDetails
              name: bgpDetails
              label: BGP Details
              description: BGP settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineBgpAsn
                    - splineBgpDefaults
            splineOspfDefaultsConfigStatement:
              id: splineOspfDefaultsConfigStatement
              name: ospfDefaultsConfigStatement
              label: Config Statement
              description: Input raw EOS CLI
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineOspfDefaults:
              id: splineOspfDefaults
              name: ospfDefaults
              label: OSPF Defaults
              description: Configure additional commands under the 'router ospf <process-id>' context.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: splineOspfDefaultsConfigStatement
                key: ''
            splineOspfDetails:
              id: splineOspfDetails
              name: ospfDetails
              label: OSPF Details
              description: OSPF settings to be applied on Spline switches
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineOspfDefaults
            splineDefaults:
              id: splineDefaults
              name: splineDefaults
              label: Spline Defaults
              description: Set parameters which will be used to generate configuration across all spline switches in this site.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineRouterIdPool
                    - splineSpanningTreeDetails
                    - splineMlagDetails
                    - splineVtepLoopbackIPv4Pool
                    - splineBgpDetails
                    - splineOspfDetails
            ospfProcessId:
              id: ospfProcessId
              name: processId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '100'
                range: null
                static_options: null
                dynamic_options: null
            ospfArea:
              id: ospfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            ospfMaxLsa:
              id: ospfMaxLsa
              name: maxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '12000'
                range: null
                static_options: null
                dynamic_options: null
            ospfBfdKnob:
              id: ospfBfdKnob
              name: bfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            ospfConfiguration:
              id: ospfConfiguration
              name: ospfDetails
              label: OSPF
              description: Underlay OSFP settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - ospfProcessId
                    - ospfArea
                    - ospfMaxLsa
                    - ospfBfdKnob
            podId:
              id: podId
              name: podId
              label: Pod ID
              description: Used as an index for certain inputs defined under the Campus Pod Defaults section.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            leafUplinkInterfaceName:
              id: leafUplinkInterfaceName
              name: uplinkInterface
              label: Leaf Interface
              description: Leaf switch's uplink interface to spline. For example, `Ethernet 27`.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkHostname:
              id: leafUplinkHostname
              name: hostname
              label: Leaf Hostname
              description: Hostname of the Leaf
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkSplineHostname:
              id: leafUplinkSplineHostname
              name: uplinkSwitchHostname
              label: Spline Hostname
              description: Upstream spline switch's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkSplineInterface:
              id: leafUplinkSplineInterface
              name: uplinkSwitchInterface
              label: Spline Interface
              description: Upstream spline switch's interface connecting to the leaf switch.  For example, `Ethernet 1`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafUplinkInterfaceDetails:
              id: leafUplinkInterfaceDetails
              name: leafUplinkInterfaceDetails
              label: Leaf Uplink Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafUplinkInterfaceName
                    - leafUplinkHostname
                    - leafUplinkSplineHostname
                    - leafUplinkSplineInterface
            leafUplinkInterfaces:
              id: leafUplinkInterfaces
              name: leafUplinkInterfaces
              label: Leaf Uplink Interfaces
              description: Define the links the Leaf switches will use to connect to the upstream Spline switches.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: leafUplinkInterfaceDetails
                key: ''
            memberLeafUplinkInterfaceName:
              id: memberLeafUplinkInterfaceName
              name: uplinkInterface
              label: Interface Name
              description: Member Leaf switch's uplink interface to Leaf. For example, `Ethernet 27`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkHostname:
              id: memberLeafUplinkHostname
              name: hostname
              label: Member-Leaf Hostname
              description: Member Leaf's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkLeafHostname:
              id: memberLeafUplinkLeafHostname
              name: uplinkSwitchHostname
              label: Leaf Hostname
              description: Upstream leaf switch's hostname
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkLeafInterface:
              id: memberLeafUplinkLeafInterface
              name: uplinkSwitchInterface
              label: Leaf Interface
              description: Upstream leaf switch's interface connecting to the member-leaf switch.  For example, `Ethernet 1`
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            memberLeafUplinkInterfaceDetails:
              id: memberLeafUplinkInterfaceDetails
              name: memberLeafUplinkInterfaceDetails
              label: Member Leaf Uplink Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - memberLeafUplinkInterfaceName
                    - memberLeafUplinkHostname
                    - memberLeafUplinkLeafHostname
                    - memberLeafUplinkLeafInterface
            memberLeafUplinkInterfaces:
              id: memberLeafUplinkInterfaces
              name: memberLeafUplinkInterfaces
              label: Member Leaf Uplink Interfaces
              description: Define the links the Member-Leaf switches will use to connect to the upstream Leaf switches in the Campus Pod.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: memberLeafUplinkInterfaceDetails
                key: ''
            campusPodMlagPeerInterfaceName:
              id: campusPodMlagPeerInterfaceName
              name: campusPodMlagPeerInterfaceName
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            campusPodMlagPeerInterfaces:
              id: campusPodMlagPeerInterfaces
              name: campusPodMlagPeerInterfaces
              label: Leaf MLAG Peer Interfaces
              description: Define the interfaces that will make up the MLAG peer link for the primary and secondary leaf in this Campus Pod. Note that this will override any MLAG peer interfaces defined under the Campus Pod Defaults MLAG Details section.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: campusPodMlagPeerInterfaceName
                key: ''
            campusPodFacts:
              id: campusPodFacts
              name: campusPodFacts
              label: Campus Pod Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - podId
                    - leafUplinkInterfaces
                    - memberLeafUplinkInterfaces
                    - campusPodMlagPeerInterfaces
            campusPods:
              id: campusPods
              name: campusPods
              label: Campus Pods
              description: A Campus Pod is a group of switches that acts as an IDF. Create Campus-Pods and define how the switches in the Campus Pod should be connected.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusPodFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            mstInstanceId:
              id: mstInstanceId
              name: mstInstanceId
              label: Instance ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mstInstanceSplineStpPriority:
              id: mstInstanceSplineStpPriority
              name: mstInstanceSplineStpPriority
              label: Spline Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mstInstanceLeafStpPriority:
              id: mstInstanceLeafStpPriority
              name: mstInstanceLeafStpPriority
              label: Leaf Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mstInstanceMemberLeafStpPriority:
              id: mstInstanceMemberLeafStpPriority
              name: mstInstanceMemberLeafStpPriority
              label: Member Leaf Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            mstInstanceDetails:
              id: mstInstanceDetails
              name: mstInstanceDetails
              label: MST Instance Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - mstInstanceId
                    - mstInstanceSplineStpPriority
                    - mstInstanceLeafStpPriority
                    - mstInstanceMemberLeafStpPriority
            mstInstances:
              id: mstInstances
              name: mstInstances
              label: MST Instances
              description: MST Instance Settings
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: mstInstanceDetails
                key: mstInstanceId
            allowAllVlansOnTrunkToggle:
              id: allowAllVlansOnTrunkToggle
              name: allowAllVLANs
              label: Allow All VLANs
              description: Allow all VLANs on trunk interfaces or only necessary VLANs based on what services are applied to switches.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfName:
              id: vrfName
              name: vrfName
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagPeerL3Vlan:
              id: vrfMlagPeerL3Vlan
              name: vrfMlagPeerL3Vlan
              label: MLAG Peer L3 VLAN
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfMlagPeerL3IPv4Pool:
              id: vrfMlagPeerL3IPv4Pool
              name: vrfMlagPeerL3IPv4Pool
              label: MLAG Peer L3 IPv4 Pool
              description: If no IPv4 pool is entered, will default to IPv4 pool entered in default VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3Peering:
              id: vrfMlagL3Peering
              name: mlagL3PeeringDetails
              label: MLAG L3 Peering
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfMlagPeerL3Vlan
                    - vrfMlagPeerL3IPv4Pool
            vrfStaticRoutesDescription:
              id: vrfStaticRoutesDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesApply:
              id: vrfStaticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfStaticRoutesHostname:
              id: vrfStaticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfStaticRoutesDevicesGroup:
              id: vrfStaticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesHostname
            vrfStaticRoutesDevicesResolver:
              id: vrfStaticRoutesDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfStaticRoutesDestinationAddressPrefix:
              id: vrfStaticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesGateway:
              id: vrfStaticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesInterface:
              id: vrfStaticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesDistance:
              id: vrfStaticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesTag:
              id: vrfStaticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesMetric:
              id: vrfStaticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesDetails:
              id: vrfStaticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDestinationAddressPrefix
                    - vrfStaticRoutesGateway
                    - vrfStaticRoutesInterface
                    - vrfStaticRoutesDistance
                    - vrfStaticRoutesTag
                    - vrfStaticRoutesMetric
            vrfStaticRoutesGroup:
              id: vrfStaticRoutesGroup
              name: staticRoutesGroup
              label: Static Routes Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDescription
                    - vrfStaticRoutesDevicesResolver
                    - vrfStaticRoutesDetails
            vrfStaticRoutes:
              id: vrfStaticRoutes
              name: staticRoutes
              label: Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfStaticRoutesGroup
                key: vrfStaticRoutesDescription
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersNeighborIpAddress:
              id: vrfExternalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersApply:
              id: vrfExternalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersHostname:
              id: vrfExternalBgpPeersHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfExternalBgpPeersDevicesGroup:
              id: vrfExternalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersHostname
            vrfExternalBgpPeersDevicesResolver:
              id: vrfExternalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfExternalBgpPeersRemoteAs:
              id: vrfExternalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersDescription:
              id: vrfExternalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersPassword:
              id: vrfExternalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersSendCommunity:
              id: vrfExternalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopSelf:
              id: vrfExternalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersMaximumRoutes:
              id: vrfExternalBgpPeersMaximumRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesWarningLimit:
              id: vrfExternalBgpPeersMaxRoutesWarningLimit
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesGroup:
              id: vrfExternalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersMaximumRoutes
                    - vrfExternalBgpPeersMaxRoutesWarningLimit
            vrfExternalBgpPeersUpdateSource:
              id: vrfExternalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersEbgpMultihop:
              id: vrfExternalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersWeight:
              id: vrfExternalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersIpv4NextHop:
              id: vrfExternalBgpPeersIpv4NextHop
              name: ipv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersIpv6NextHop:
              id: vrfExternalBgpPeersIpv6NextHop
              name: ipv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopGroup:
              id: vrfExternalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersIpv4NextHop
                    - vrfExternalBgpPeersIpv6NextHop
            vrfExternalBgpPeersRouteMapIn:
              id: vrfExternalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapOut:
              id: vrfExternalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapGroup:
              id: vrfExternalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersRouteMapIn
                    - vrfExternalBgpPeersRouteMapOut
            vrfExternalBgpPeersDefaultOriginateAlwaysToggle:
              id: vrfExternalBgpPeersDefaultOriginateAlwaysToggle
              name: always
              label: Always
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersDefaultOriginateGroup:
              id: vrfExternalBgpPeersDefaultOriginateGroup
              name: defaultOriginate
              label: Default Originate
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersDefaultOriginateAlwaysToggle
            vrfExternalBgpPeersLocalAs:
              id: vrfExternalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersGroup:
              id: vrfExternalBgpPeersGroup
              name: externalBgpPeerDetails
              label: External BGP Peers Group
              description: Group of members for External BGP Peers
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersNeighborIpAddress
                    - vrfExternalBgpPeersDevicesResolver
                    - vrfExternalBgpPeersRemoteAs
                    - vrfExternalBgpPeersDescription
                    - vrfExternalBgpPeersPassword
                    - vrfExternalBgpPeersSendCommunity
                    - vrfExternalBgpPeersNextHopSelf
                    - vrfExternalBgpPeersMaxRoutesGroup
                    - vrfExternalBgpPeersUpdateSource
                    - vrfExternalBgpPeersEbgpMultihop
                    - vrfExternalBgpPeersWeight
                    - vrfExternalBgpPeersNextHopGroup
                    - vrfExternalBgpPeersRouteMapGroup
                    - vrfExternalBgpPeersDefaultOriginateGroup
                    - vrfExternalBgpPeersLocalAs
            vrfExternalBgpPeers:
              id: vrfExternalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfExternalBgpPeersGroup
                key: vrfExternalBgpPeersDescription
            vrfOspfProcessId:
              id: vrfOspfProcessId
              name: vrfOspfProcessId
              label: Process ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfOspfMaxLsa:
              id: vrfOspfMaxLsa
              name: vrfOspfMaxLsa
              label: Max LSA
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfOspfBfd:
              id: vrfOspfBfd
              name: vrfOspfBfd
              label: BFD
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfOspfEnabled:
              id: vrfOspfEnabled
              name: vrfOspfEnabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfOspfConfiguration:
              id: vrfOspfConfiguration
              name: vrfOspfConfiguration
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfOspfProcessId
                    - vrfOspfMaxLsa
                    - vrfOspfBfd
                    - vrfOspfEnabled
            vrfL3InterfaceName:
              id: vrfL3InterfaceName
              name: name
              label: Interface Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceIpAddress:
              id: vrfL3InterfaceIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceDescription:
              id: vrfL3InterfaceDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEnabled:
              id: vrfL3InterfaceEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfL3InterfaceMtu:
              id: vrfL3InterfaceMtu
              name: mtu
              label: MTU
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceCliStatement:
              id: vrfL3InterfaceCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceEosCli:
              id: vrfL3InterfaceEosCli
              name: eosCli
              label: EOS CLI
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceCliStatement
                key: ''
            vrfL3InterfaceOspfEnabled:
              id: vrfL3InterfaceOspfEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfL3InterfaceOspfArea:
              id: vrfL3InterfaceOspfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfCost:
              id: vrfL3InterfaceOspfCost
              name: cost
              label: Cost
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceOspfPointToPoint:
              id: vrfL3InterfaceOspfPointToPoint
              name: pointToPoint
              label: Point-to-Point
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            vrfL3InterfaceOspfAuthentication:
              id: vrfL3InterfaceOspfAuthentication
              name: authentication
              label: Authentication
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Simple
                    - Message-Digest
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfSimpleAuthKey:
              id: vrfL3InterfaceOspfSimpleAuthKey
              name: simpleAuthKey
              label: Simple Auth Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyId:
              id: vrfL3InterfaceOspfMessageDigestKeyId
              name: id
              label: ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm:
              id: vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm
              name: hashAlgorithm
              label: Hash Algorithm
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeyKey:
              id: vrfL3InterfaceOspfMessageDigestKeyKey
              name: key
              label: Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfL3InterfaceOspfMessageDigestKeysGroup:
              id: vrfL3InterfaceOspfMessageDigestKeysGroup
              name: messageDigestKeysGroup
              label: Message Digest Keys Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceOspfMessageDigestKeyId
                    - vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm
                    - vrfL3InterfaceOspfMessageDigestKeyKey
            vrfL3InterfaceOspfMessageDigestKeys:
              id: vrfL3InterfaceOspfMessageDigestKeys
              name: messageDigestKeys
              label: Message Digest Keys
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceOspfMessageDigestKeysGroup
                key: ''
            vrfL3InterfaceOspf:
              id: vrfL3InterfaceOspf
              name: ospf
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceOspfEnabled
                    - vrfL3InterfaceOspfArea
                    - vrfL3InterfaceOspfCost
                    - vrfL3InterfaceOspfPointToPoint
                    - vrfL3InterfaceOspfAuthentication
                    - vrfL3InterfaceOspfSimpleAuthKey
                    - vrfL3InterfaceOspfMessageDigestKeys
            vrfL3InterfaceDetails:
              id: vrfL3InterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfL3InterfaceName
                    - vrfL3InterfaceIpAddress
                    - vrfL3InterfaceDescription
                    - vrfL3InterfaceEnabled
                    - vrfL3InterfaceMtu
                    - vrfL3InterfaceEosCli
                    - vrfL3InterfaceOspf
            vrfL3InterfacesCollection:
              id: vrfL3InterfacesCollection
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfL3InterfaceDetails
                key: vrfL3InterfaceName
            vrfL3InterfacesDevice:
              id: vrfL3InterfacesDevice
              name: l3Interfaces
              label: L3 Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfL3InterfacesCollection
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfDetails:
              id: vrfDetails
              name: vrfDetails
              label: VRF Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - vrfMlagL3Peering
                    - vrfStaticRoutes
                    - vrfRedistributeStaticRoutesToggle
                    - vrfExternalBgpPeers
                    - vrfOspfConfiguration
                    - vrfL3InterfacesDevice
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: Configure VRFs on gateway switches at this site
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfDetails
                key: vrfName
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviVrf:
              id: vlanCampusSviVrf
              name: vrf
              label: VRF
              description: VRF this VLAN will be configured in.  If no value is selected, VLAN will be put in the default VRF.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            l2CampusSviIpVirtualRouterAddress:
              id: l2CampusSviIpVirtualRouterAddress
              name: sviIpVirtualRouterAddress
              label: IP Virtual Router Address
              description: Virtual IP address for SVI shared between splines to enable VARP.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusPrimarySplineSviIpAddress:
              id: l2CampusPrimarySplineSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Spline SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to primary spline.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l2CampusSecondarySplineSviIpAddress:
              id: l2CampusSecondarySplineSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Spline SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to secondary spline.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviGroup:
              id: vlanCampusSviGroup
              name: sviDetails
              label: SVI Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanCampusSviVrf
                    - l2CampusSviIpVirtualRouterAddress
                    - l2CampusPrimarySplineSviIpAddress
                    - l2CampusSecondarySplineSviIpAddress
            vlanDhcpHelpersServer:
              id: vlanDhcpHelpersServer
              name: dhcpServer
              label: DHCP Server
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersSourceInterface:
              id: vlanDhcpHelpersSourceInterface
              name: dhcpSourceInterface
              label: DHCP Source Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersGroup:
              id: vlanDhcpHelpersGroup
              name: dhcpHelperDetails
              label: DHCP Helper Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpHelpersServer
                    - vlanDhcpHelpersSourceInterface
            vlanDhcpHelpers:
              id: vlanDhcpHelpers
              name: dhcpHelpers
              label: DHCP Helpers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpHelpersGroup
                key: ''
            vlanName:
              id: vlanName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusSviIpVirtualRouterAddress:
              id: l3CampusSviIpVirtualRouterAddress
              name: sviIpVirtualRouterAddress
              label: IP Virtual Router Address
              description: Virtual IP address for SVI shared between primary and secondary leaf to enable VARP.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: cidr
                length: null
                pattern: null
                dynamic_options: null
            l3CampusPrimaryLeafSviIpAddress:
              id: l3CampusPrimaryLeafSviIpAddress
              name: primarySwitchSviIpAddress
              label: Primary Leaf SVI IP Address
              description: IP address (in CIDR notation) for SVI assigned to primary leaf.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusSecondaryLeafSviIpAddress:
              id: l3CampusSecondaryLeafSviIpAddress
              name: secondarySwitchSviIpAddress
              label: Secondary Leaf SVI IP Address
              description: 'IP address (in CIDR notation) for SVI assigned to secondary leaf. If no value is entered, IP address will be allocated automatically based on virtual IP address. '
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            l3CampusVlanName:
              id: l3CampusVlanName
              name: name
              label: Name
              description: If no value is entered, the value entered in the Name field below will be used.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodGroup:
              id: vlansCampusPodGroup
              name: podDetails
              label: PoD Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - l3CampusSviIpVirtualRouterAddress
                    - l3CampusPrimaryLeafSviIpAddress
                    - l3CampusSecondaryLeafSviIpAddress
                    - l3CampusVlanName
            vlansCampusPodResolver:
              id: vlansCampusPodResolver
              name: campusPod
              label: Campus PoDs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlansCampusPodGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            vlanSviEosCliStatement:
              id: vlanSviEosCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCli:
              id: vlanSviEosCli
              name: eosCli
              label: EOS CLI
              description: Raw CLI to be applied on SVI
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviEosCliStatement
                key: ''
            vlanMstInstance:
              id: vlanMstInstance
              name: vlanMstInstance
              label: MST Instance
              description: MST instance this VLAN belongs to. If left blank, VLAN will be a member of the default instance (0). Create MST instances in the 'MST Instances' section on the Site page.
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options:
                  values:
                    - '{"fieldId":"mstInstanceId"}'
            vlanStpPrioritySpline:
              id: vlanStpPrioritySpline
              name: vlanStpPrioritySpline
              label: Spline STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanStpPriorityLeaf:
              id: vlanStpPriorityLeaf
              name: vlanStpPriorityLeaf
              label: Leaf STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanStpPriorityMemberLeaf:
              id: vlanStpPriorityMemberLeaf
              name: vlanStpPriorityMemberLeaf
              label: Member Leaf STP Priority
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vlanSpanningTreeDetails:
              id: vlanSpanningTreeDetails
              name: vlanSpanningTreeDetails
              label: VLAN Spanning Tree Details
              description: Edit any of the default spanning tree settings
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanMstInstance
                    - vlanStpPrioritySpline
                    - vlanStpPriorityLeaf
                    - vlanStpPriorityMemberLeaf
            sviOspfEnabled:
              id: sviOspfEnabled
              name: enabled
              label: Enabled
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            sviOspfPointToPoint:
              id: sviOspfPointToPoint
              name: pointToPoint
              label: Point-to-Point
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: true
            sviOspfArea:
              id: sviOspfArea
              name: area
              label: Area
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: 0.0.0.0
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfCost:
              id: sviOspfCost
              name: cost
              label: Cost
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            sviOspfAuthentication:
              id: sviOspfAuthentication
              name: authentication
              label: Authentication
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Simple
                    - Message-Digest
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfSimpleAuthKey:
              id: sviOspfSimpleAuthKey
              name: simpleAuthKey
              label: Simple Auth Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfHashAlgorithm:
              id: sviOspfHashAlgorithm
              name: hashAlgorithm
              label: Hash Algorithm
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: sha512
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfKey:
              id: sviOspfKey
              name: key
              label: Key
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            sviOspfKeyId:
              id: sviOspfKeyId
              name: id
              label: ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            sviOspfMessageDigestKeysDetails:
              id: sviOspfMessageDigestKeysDetails
              name: sviOspfMessageDigestKeysDetails
              label: Message Digest Keys Group
              description: Group of members for messageDigestKeys
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - sviOspfHashAlgorithm
                    - sviOspfKey
                    - sviOspfKeyId
            sviOspfMessageDigestKeys:
              id: sviOspfMessageDigestKeys
              name: messageDigestKeys
              label: Message Digest Keys
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: sviOspfMessageDigestKeysDetails
                key: ''
            sviOspfConfiguration:
              id: sviOspfConfiguration
              name: sviOspfConfiguration
              label: OSPF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - sviOspfEnabled
                    - sviOspfPointToPoint
                    - sviOspfArea
                    - sviOspfCost
                    - sviOspfAuthentication
                    - sviOspfSimpleAuthKey
                    - sviOspfMessageDigestKeys
            vlansDetails:
              id: vlansDetails
              name: vlanDetails
              label: VLAN Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanCampusSviGroup
                    - vlanDhcpHelpers
                    - vlanName
                    - vlansCampusPodResolver
                    - vlanSviEosCli
                    - vlanSpanningTreeDetails
                    - sviOspfConfiguration
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: Configure VLANs on switches at this site
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlansDetails
                key: vlanId
            siteServices:
              id: siteServices
              name: services
              label: Services
              description: Create and assign services to switches in this site.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - allowAllVlansOnTrunkToggle
                    - vrfs
                    - vlans
            campusType:
              id: campusType
              name: campusType
              label: Campus Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - L3
                    - L2
                format: null
                length: null
                pattern: null
                dynamic_options: null
            p2pLinkName:
              id: p2pLinkName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            p2pLinkIncludeInUnderlayRoutingProtocol:
              id: p2pLinkIncludeInUnderlayRoutingProtocol
              name: includeInUnderlayRoutingProtocol
              label: Include in Underlay Routing Protocol
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            p2pLinkHostname:
              id: p2pLinkHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            p2pLinkEthernetInterface:
              id: p2pLinkEthernetInterface
              name: ethernetInterface
              label: Ethernet Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            p2pLinkIpAddress:
              id: p2pLinkIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            p2pLinkInterfaces:
              id: p2pLinkInterfaces
              name: interfaces
              label: Interfaces
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - p2pLinkHostname
                    - p2pLinkEthernetInterface
                    - p2pLinkIpAddress
            p2pLinkInterfaceDetails:
              id: p2pLinkInterfaceDetails
              name: interfaceDetails
              label: Interface Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: p2pLinkInterfaces
                key: ''
            p2pLinkDetails:
              id: p2pLinkDetails
              name: p2PLinkDetails
              label: P2P Link Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - p2pLinkName
                    - p2pLinkIncludeInUnderlayRoutingProtocol
                    - p2pLinkInterfaceDetails
            p2pLinks:
              id: p2pLinks
              name: interfaces
              label: Interfaces To Core
              description: Configure L3 interfaces northbound from the Spline switches to a core router.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: p2pLinkDetails
                key: p2pLinkName
            accessInterfacePortProfileName:
              id: accessInterfacePortProfileName
              name: portProfileName
              label: Name
              description: Name of Port-Profile that can be referenced under Access Interfaces configuration
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            accessInterfacePortProfileGroup:
              id: accessInterfacePortProfileGroup
              name: portProfileGroup
              label: Port Profiles Group
              description: Group of members for Port Profiles
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - accessInterfacePortProfileName
            accessInterfacePortProfiles:
              id: accessInterfacePortProfiles
              name: portProfiles
              label: Port Profiles
              description: Create port profiles that serve as templates for certain interface configuration characteristics.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: accessInterfacePortProfileGroup
                key: accessInterfacePortProfileName
            accessInterfaceTopLevelDescription:
              id: accessInterfaceTopLevelDescription
              name: TopLevelDescription
              label: Interface Set Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            accessInterfaceInterfaces:
              id: accessInterfaceInterfaces
              name: interfaces
              label: Interfaces
              description: Interface or range of interfaces to configure using AVD's range_expand syntax (https://avd.sh/en/stable/plugins/index.html#range_expand-filter)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            accessInterfaceTargetSwitches:
              id: accessInterfaceTargetSwitches
              name: accessInterfaceTargetSwitches
              label: Switches
              description: Select the switches to configure a range of interfaces on.
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: accessInterfaceInterfaces
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            accessInterfaceLowLevelDescription:
              id: accessInterfaceLowLevelDescription
              name: accessInterfaceLowLevelDescription
              label: Description
              description: Description to be set on access interfaces
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            accessInterfacesDetails:
              id: accessInterfacesDetails
              name: accessInterfacesDetails
              label: Access Interfaces Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - accessInterfaceTopLevelDescription
                    - accessInterfaceTargetSwitches
                    - accessInterfaceLowLevelDescription
            accessInterfaces:
              id: accessInterfaces
              name: accessInterfaces
              label: Access Interfaces
              description: Define sets of access interfaces to configure
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: accessInterfacesDetails
                key: accessInterfaceTopLevelDescription
            accessInterfaceConfiguration:
              id: accessInterfaceConfiguration
              name: accessInterfaceConfiguration
              label: Access Interface Configuration
              description: Configure access interfaces for switches in this site.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - accessInterfacePortProfiles
                    - accessInterfaces
            splineEvpnRoleDefault:
              id: splineEvpnRoleDefault
              name: splineEvpnRoleDefault
              label: EVPN Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Server
                    - Client
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineMlagSupportDefault:
              id: splineMlagSupportDefault
              name: splineMlagSupportDefault
              label: MLAG Support
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineVtepDefault:
              id: splineVtepDefault
              name: splineVtepDefault
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineConnectedEndpointsDefault:
              id: splineConnectedEndpointsDefault
              name: splineConnectedEndpointsDefault
              label: Connected Endpoints
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL2NetworkServicesDefault:
              id: splineL2NetworkServicesDefault
              name: splineL2NetworkServicesDefault
              label: L2 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            splineL3NetworkServicesDefault:
              id: splineL3NetworkServicesDefault
              name: splineL3NetworkServicesDefault
              label: L3 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultSplineProperties:
              id: defaultSplineProperties
              name: defaultSplineProperties
              label: Default Spline Properties
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - splineEvpnRoleDefault
                    - splineMlagSupportDefault
                    - splineVtepDefault
                    - splineConnectedEndpointsDefault
                    - splineL2NetworkServicesDefault
                    - splineL3NetworkServicesDefault
            leafEvpnRoleDefault:
              id: leafEvpnRoleDefault
              name: leafEvpnRoleDefault
              label: EVPN Role
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - Server
                    - Client
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafMlagSupport:
              id: leafMlagSupport
              name: leafMlagSupport
              label: MLAG Support
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafVtepDefault:
              id: leafVtepDefault
              name: leafVtepDefault
              label: VTEP
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafConnectedEndpointsDefault:
              id: leafConnectedEndpointsDefault
              name: leafConnectedEndpointsDefault
              label: Connected Endpoints
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafL2NetworkServicesDefault:
              id: leafL2NetworkServicesDefault
              name: leafL2NetworkServicesDefault
              label: L2 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            leafL3NetworkServicesDefault:
              id: leafL3NetworkServicesDefault
              name: leafL3NetworkServicesDefault
              label: L3 Network Services
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'Yes'
                    - 'No'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            defaultLeafProperties:
              id: defaultLeafProperties
              name: defaultLeafProperties
              label: Default Leaf Properties
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - leafEvpnRoleDefault
                    - leafMlagSupport
                    - leafVtepDefault
                    - leafConnectedEndpointsDefault
                    - leafL2NetworkServicesDefault
                    - leafL3NetworkServicesDefault
            nodeTypeProperties:
              id: nodeTypeProperties
              name: nodeTypeProperties
              label: Node Type Properties
              description: Customize role properties for switches in this site.  Set fields to None to use defaults.
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - defaultSplineProperties
                    - defaultLeafProperties
            siteUnderlayRoutingProtocol:
              id: siteUnderlayRoutingProtocol
              name: siteUnderlayRoutingProtocol
              label: Underlay Routing Protocol
              description: Set the routing protocol used for underlay connectivity for this site.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: BGP
                static_options:
                  values:
                    - BGP
                    - OSPF
                format: null
                length: null
                pattern: null
                dynamic_options: null
            siteOverlayRoutingProtocol:
              id: siteOverlayRoutingProtocol
              name: siteOverlayRoutingProtocol
              label: Overlay Routing Protocol
              description: Set the routing protocol used for the overlay connectivity for this site.
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - BGP
                format: null
                length: null
                pattern: null
                dynamic_options: null
            siteRoutingProtocols:
              id: siteRoutingProtocols
              name: siteRoutingProtocols
              label: Routing Protocols
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - siteUnderlayRoutingProtocol
                    - siteOverlayRoutingProtocol
            siteFacts:
              id: siteFacts
              name: siteFacts
              label: Site Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campusPodDefaults
                    - splineDefaults
                    - ospfConfiguration
                    - campusPods
                    - mstInstances
                    - siteServices
                    - campusType
                    - p2pLinks
                    - accessInterfaceConfiguration
                    - nodeTypeProperties
                    - siteRoutingProtocols
            siteResolver:
              id: siteResolver
              name: site
              label: Site
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: siteFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            campusDetails:
              id: campusDetails
              name: campusDetails
              label: Campus Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - siteResolver
            campus:
              id: campus
              name: campus
              label: Campus Fabrics
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campus
        layout:
          value: |
            {
              "siteFacts":{
                "key":"siteFacts",
                "type":"INPUT",
                "order":[
                  "campusType",
                  "siteRoutingProtocols",
                  "splineTagger",
                  "splineDefaults",
                  "campusPods",
                  "campusPodDefaults",
                  "ospfConfiguration",
                  "mstInstances",
                  "siteServices",
                  "accessInterfaceConfiguration",
                  "p2pLinks",
                  "nodeTypeProperties"
                ]
              },
              "fabricSubnet":{
                "key":"fabricSubnet",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "fabricChildSubnetsMask":{
                "key":"fabricChildSubnetsMask",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vxlanOverlay":{
                "key":"vxlanOverlay",
                "type":"INPUT",
                "dependency":{
                  "fabricType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vtepAddressRange":{
                "key":"vtepAddressRange",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "leafBgpAS":{
                "key":"leafBgpAS",
                "dependency":{
                  "campusPodUnderlayRoutingProtocol":{
                    "value":[
                      "bgp"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "campusPodFacts":{
                "key":"campusPodFacts",
                "type":"INPUT",
                "order":[
                  "podId",
                  "leafTagger",
                  "leafUplinkInterfaces",
                  "campusPodMlagPeerInterfaces",
                  "memberLeafTagger",
                  "memberLeafUplinkInterfaces"
                ]
              },
              "campusPodBgpDefaultsConfigStatement":{
                "key":"campusPodBgpDefaultsConfigStatement",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "campusPodDefaults":{
                "key":"campusPodDefaults",
                "type":"INPUT",
                "order":[
                  "campusPodSpanningTreeDetails",
                  "leafMlagDetails",
                  "campusPodUplinkIpv4Pool",
                  "campusPodRouterIdPool",
                  "leafVtepLoopbackIPv4Pool",
                  "leafOspfDetails",
                  "leafBgpDetails",
                  "l2CampusInbandManagementDetails"
                ]
              },
              "splineDefaults":{
                "key":"splineDefaults",
                "type":"INPUT",
                "order":[
                  "splineSpanningTreeDetails",
                  "splineMlagDetails",
                  "splineRouterIdPool",
                  "splineVtepLoopbackIPv4Pool",
                  "splineOspfDetails",
                  "splineBgpDetails"
                ]
              },
              "campusPodUnderlayRoutingProtocol":{
                "key":"campusPodUnderlayRoutingProtocol",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodRouterIdPool":{
                "key":"campusPodRouterIdPool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "campusPodBgpAsRange":{
                "key":"campusPodBgpAsRange",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "splineBgpAs":{
                "key":"splineBgpAs",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "splineBgpDefaultsConfigStatement":{
                "key":"splineBgpDefaultsConfigStatement",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "siteOverlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "ospfProcessId":{
                "key":"ospfProcessId",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfArea":{
                "key":"ospfArea",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfMaxLsa":{
                "key":"ospfMaxLsa",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "ospfBfdKnob":{
                "key":"ospfBfdKnob",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "campusPodUplinkIpv4Pool":{
                "key":"campusPodUplinkIpv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineVtepKnob":{
                "key":"splineVtepKnob",
                "type":"INPUT",
                "dependency":{
                  "vxlanOverlay":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mlagConfiguration":{
                "key":"mlagConfiguration",
                "type":"INPUT",
                "order":[
                  "mlagPeerLinkVlan",
                  "mlagPeerIPv4Pool",
                  "mlagSubnetMask",
                  "mlagPeerL3Vlan",
                  "mlagPeerL3IPv4Pool",
                  "mlagPeerL3SubnetMask",
                  "mlagPortChannelId",
                  "virtualRouterMacAddress",
                  "lacpMode"
                ]
              },
              "splineTagger":{
                "type":"TAGGER",
                "parentKey":"siteFacts",
                "key":"splineTagger",
                "name":"Splines",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Spline",
                "tagType":"DEVICE",
                "description":"Splines are often the switch at the MDF layer which sit between the core and IDF layers.  Each spline at this site should have a unique NodeId value starting from 1.",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "roleTagger":{
                "type":"TAGGER",
                "parentKey":"campusDetails",
                "key":"roleTagger",
                "name":"Role",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagType":"DEVICE",
                "description":"Assign a role to each switch in this campus.",
                "columns":[
                  {
                    "tagLabel":"Site",
                    "suggestedValues":[
                      
                    ]
                  },
                  {
                    "tagLabel":"Role",
                    "suggestedValues":[
                      "Spline",
                      "Leaf",
                      "Member-Leaf"
                    ]
                  },
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "campusDetails":{
                "key":"campusDetails",
                "type":"INPUT",
                "order":[
                  "siteResolver",
                  "roleTagger"
                ]
              },
              "leafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"leafTagger",
                "name":"Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "memberLeafTagger":{
                "type":"TAGGER",
                "parentKey":"campusPodFacts",
                "key":"memberLeafTagger",
                "name":"Member Leafs",
                "assignmentType":"SINGLE",
                "prepopulate":true,
                "tagFilterQuery":"Role:Member-Leaf ",
                "tagType":"DEVICE",
                "description":"Assign Leaf Node ID",
                "columns":[
                  {
                    "tagLabel":"NodeId",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "campusPodResolver":{
                "key":"campusPodResolver",
                "type":"INPUT",
                "isPageLayout":true,
                "showDefaultRow":false
              },
              "overlayDetails":{
                "key":"overlayDetails",
                "type":"INPUT",
                "order":[
                  "vxlanOverlay",
                  "vtepAddressRange"
                ]
              },
              "campusPods":{
                "key":"campusPods",
                "isPageLayout":true,
                "type":"INPUT",
                "showDefaultRow":false
              },
              "siteResolver":{
                "key":"siteResolver",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "campus":{
                "key":"campus",
                "type":"INPUT",
                "showDefaultRow":false
              },
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlansCampusPodResolver":{
                "key":"vlansCampusPodResolver",
                "type":"INPUT"
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "l3CampusSviIpVirtualRouterAddress":{
                "key":"l3CampusSviIpVirtualRouterAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlansDetails":{
                "key":"vlansDetails",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlansCampusPodResolver",
                  "vlanName",
                  "vlanCampusSviGroup",
                  "vlanDhcpHelpers",
                  "sviOspfConfiguration",
                  "vlanSviEosCli",
                  "vlanSpanningTreeDetails"
                ]
              },
              "vlanCampusSviGroup":{
                "key":"vlanCampusSviGroup",
                "type":"INPUT",
                "order":[
                  "vlanCampusSviVrf",
                  "l2CampusSviIpVirtualRouterAddress",
                  "l2CampusPrimarySplineSviIpAddress",
                  "l2CampusSecondarySplineSviIpAddress"
                ]
              },
              "vlanL2CampusSviIpAddress":{
                "key":"vlanL2CampusSviIpAddress",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT"
              },
              "vrfStaticRoutes":{
                "key":"vrfStaticRoutes",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfExternalBgpPeers":{
                "key":"vrfExternalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanSpanningTreePriority":{
                "key":"vlanSpanningTreePriority",
                "dependency":{
                  "spanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "vlanMstInstance":{
                "key":"vlanMstInstance",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "mstInstanceId":{
                "key":"mstInstanceId",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  },
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "mstPriority":{
                "key":"mstPriority",
                "type":"INPUT",
                "dependency":{
                  "spanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersNeighborIpAddress":{
                "key":"vrfExternalBgpPeersNeighborIpAddress",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersApply":{
                "key":"vrfExternalBgpPeersApply",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersRemoteAs":{
                "key":"vrfExternalBgpPeersRemoteAs",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersDescription":{
                "key":"vrfExternalBgpPeersDescription",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersPassword":{
                "key":"vrfExternalBgpPeersPassword",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersSendCommunity":{
                "key":"vrfExternalBgpPeersSendCommunity",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfExternalBgpPeersNextHopSelf":{
                "key":"vrfExternalBgpPeersNextHopSelf",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersMaximumRoutes":{
                "key":"vrfExternalBgpPeersMaximumRoutes",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfExternalBgpPeersMaxRoutesWarningLimit":{
                "key":"vrfExternalBgpPeersMaxRoutesWarningLimit",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersUpdateSource":{
                "key":"vrfExternalBgpPeersUpdateSource",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersEbgpMultihop":{
                "key":"vrfExternalBgpPeersEbgpMultihop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersWeight":{
                "key":"vrfExternalBgpPeersWeight",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersIpv4NextHop":{
                "key":"vrfExternalBgpPeersIpv4NextHop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersIpv6NextHop":{
                "key":"vrfExternalBgpPeersIpv6NextHop",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersRouteMapIn":{
                "key":"vrfExternalBgpPeersRouteMapIn",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersRouteMapOut":{
                "key":"vrfExternalBgpPeersRouteMapOut",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersDefaultOriginateAlwaysToggle":{
                "key":"vrfExternalBgpPeersDefaultOriginateAlwaysToggle",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfExternalBgpPeersLocalAs":{
                "key":"vrfExternalBgpPeersLocalAs",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSpanningTreeDetails":{
                "key":"vlanSpanningTreeDetails",
                "type":"INPUT",
                "order":[
                  "vlanMstInstance",
                  "vlanStpPrioritySpline",
                  "vlanStpPriorityLeaf",
                  "vlanStpPriorityMemberLeaf"
                ]
              },
              "mstInstanceDetails":{
                "key":"mstInstanceDetails",
                "type":"INPUT",
                "order":[
                  "mstInstanceId",
                  "mstInstanceSplineStpPriority",
                  "mstInstanceLeafStpPriority",
                  "mstInstanceMemberLeafStpPriority"
                ]
              },
              "p2pLinks":{
                "key":"p2pLinks",
                "type":"INPUT",
                "isPageLayout":true
              },
              "p2pLinkDetails":{
                "key":"p2pLinkDetails",
                "type":"INPUT",
                "order":[
                  "p2pLinkName",
                  "p2pLinkInterfaceDetails",
                  "p2pLinkIncludeInUnderlayRoutingProtocol"
                ]
              },
              "podId":{
                "key":"podId",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "leafMlagPeerL3Vlan":{
                "key":"leafMlagPeerL3Vlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "leafMlagPeerL3IPv4Pool":{
                "key":"leafMlagPeerL3IPv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafVirtualRouterMacAddress":{
                "key":"leafVirtualRouterMacAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mstInstanceMemberLeafStpPriority":{
                "key":"mstInstanceMemberLeafStpPriority",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "mstInstanceLeafStpPriority":{
                "key":"mstInstanceLeafStpPriority",
                "type":"INPUT",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "mstInstanceSplineStpPriority":{
                "key":"mstInstanceSplineStpPriority",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "MSTP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPrioritySpline":{
                "key":"vlanStpPrioritySpline",
                "dependency":{
                  "splineSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPriorityLeaf":{
                "key":"vlanStpPriorityLeaf",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "vlanStpPriorityMemberLeaf":{
                "key":"vlanStpPriorityMemberLeaf",
                "type":"INPUT",
                "dependency":{
                  "campusPodSpanningTreeMode":{
                    "value":[
                      "Rapid-PVST"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vlanAssignmentSwitchTagger":{
                "type":"TAGGER",
                "parentKey":"vlansCampusPodGroup",
                "key":"vlanAssignmentSwitchTagger",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches where the VLAN will be configured.",
                "columns":[
                  {
                    "tagLabel":"Campus-Pod",
                    "suggestedValues":[
                      
                    ]
                  }
                ],
                "fieldOverrides":{
                  "description":"For viewing purposes only. Do NOT change the values in this table."
                }
              },
              "sviOspfSimpleAuthKey":{
                "key":"sviOspfSimpleAuthKey",
                "dependency":{
                  "sviOspfAuthentication":{
                    "value":[
                      "Simple"
                    ],
                    "mode":"SHOW"
                  },
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "type":"INPUT",
                "dependencyType":"AND"
              },
              "sviOspfMessageDigestKeysDetails":{
                "key":"sviOspfMessageDigestKeysDetails",
                "type":"INPUT",
                "order":[
                  "sviOspfKeyId",
                  "sviOspfHashAlgorithm",
                  "sviOspfKey"
                ]
              },
              "sviOspfEnabled":{
                "key":"sviOspfEnabled",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfPointToPoint":{
                "key":"sviOspfPointToPoint",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfArea":{
                "key":"sviOspfArea",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfCost":{
                "key":"sviOspfCost",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfAuthentication":{
                "key":"sviOspfAuthentication",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfKeyId":{
                "key":"sviOspfKeyId",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "sviOspfHashAlgorithm":{
                "key":"sviOspfHashAlgorithm",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "sviOspfKey":{
                "key":"sviOspfKey",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l2CampusPrimarySplineSviIpAddress":{
                "key":"l2CampusPrimarySplineSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l2CampusSecondarySplineSviIpAddress":{
                "key":"l2CampusSecondarySplineSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l2CampusSviIpVirtualRouterAddress":{
                "key":"l2CampusSviIpVirtualRouterAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "sviOspfConfiguration":{
                "key":"sviOspfConfiguration",
                "type":"INPUT",
                "order":[
                  "sviOspfEnabled",
                  "sviOspfArea",
                  "sviOspfCost",
                  "sviOspfPointToPoint",
                  "sviOspfAuthentication",
                  "sviOspfSimpleAuthKey",
                  "sviOspfMessageDigestKeys"
                ]
              },
              "splineVtepLoopbackIPv4Pool":{
                "key":"splineVtepLoopbackIPv4Pool",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "splineVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafVtepLoopbackIPv4Pool":{
                "key":"leafVtepLoopbackIPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "leafVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfOspfConfiguration":{
                "key":"vrfOspfConfiguration",
                "type":"INPUT",
                "order":[
                  "vrfOspfEnabled",
                  "vrfOspfProcessId",
                  "vrfOspfMaxLsa",
                  "vrfOspfBfd"
                ]
              },
              "vrfOspfProcessId":{
                "key":"vrfOspfProcessId",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfOspfEnabled":{
                "key":"vrfOspfEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfOspfMaxLsa":{
                "key":"vrfOspfMaxLsa",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfOspfBfd":{
                "key":"vrfOspfBfd",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l3CampusPrimaryLeafSviIpAddress":{
                "key":"l3CampusPrimaryLeafSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l3CampusSecondaryLeafSviIpAddress":{
                "key":"l3CampusSecondaryLeafSviIpAddress",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerVlan":{
                "key":"splineMlagPeerVlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerIPv4Pool":{
                "key":"splineMlagPeerIPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerL3Vlan":{
                "key":"splineMlagPeerL3Vlan",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerL3IPv4Pool":{
                "key":"splineMlagPeerL3IPv4Pool",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineVirtualRouterMacAddress":{
                "key":"splineVirtualRouterMacAddress",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineMlagPeerInterfaceName":{
                "key":"splineMlagPeerInterfaceName",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  },
                  "splineMlagSupportDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "splineBgpAsn":{
                "key":"splineBgpAsn",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  },
                  "siteOverlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"OR",
                "type":"INPUT"
              },
              "leafUplinkInterfaceDetails":{
                "key":"leafUplinkInterfaceDetails",
                "type":"INPUT",
                "order":[
                  "leafUplinkHostname",
                  "leafUplinkInterfaceName",
                  "leafUplinkSplineHostname",
                  "leafUplinkSplineInterface"
                ]
              },
              "memberLeafUplinkInterfaceDetails":{
                "key":"memberLeafUplinkInterfaceDetails",
                "type":"INPUT",
                "order":[
                  "memberLeafUplinkHostname",
                  "memberLeafUplinkInterfaceName",
                  "memberLeafUplinkLeafHostname",
                  "memberLeafUplinkLeafInterface"
                ]
              },
              "accessInterfaces":{
                "key":"accessInterfaces",
                "type":"INPUT",
                "isPageLayout":true
              },
              "l2CampusInbandManagementVlan":{
                "key":"l2CampusInbandManagementVlan",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "l2CampusInbandManagementSubnet":{
                "key":"l2CampusInbandManagementSubnet",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L2"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "siteOverlayRoutingProtocol":{
                "key":"siteOverlayRoutingProtocol",
                "type":"INPUT",
                "dependencyType":"OR",
                "dependency":{
                  "splineVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  },
                  "leafVtepDefault":{
                    "value":[
                      "Yes"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "siteServices":{
                "key":"siteServices",
                "type":"INPUT",
                "order":[
                  "vrfs",
                  "vlans",
                  "allowAllVlansOnTrunkToggle"
                ]
              },
              "splineOspfDefaultsConfigStatement":{
                "key":"splineOspfDefaultsConfigStatement",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "leafOspfDefaultsConfigStatement":{
                "key":"leafOspfDefaultsConfigStatement",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  },
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfDetails":{
                "key":"vrfDetails",
                "type":"INPUT",
                "order":[
                  "vrfName",
                  "vrfMlagL3Peering",
                  "vrfStaticRoutes",
                  "vrfRedistributeStaticRoutesToggle",
                  "vrfOspfConfiguration",
                  "vrfExternalBgpPeers",
                  "vrfL3InterfacesDevice"
                ]
              },
              "l3CampusVlanName":{
                "key":"l3CampusVlanName",
                "dependencyType":"AND",
                "type":"INPUT",
                "dependency":{
                  "campusType":{
                    "value":[
                      "L3"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfRedistributeStaticRoutesToggle":{
                "key":"vrfRedistributeStaticRoutesToggle",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "cfedd130-b898-4446-91ec-971c7d1c2985":{
                "type":"TAGGER",
                "parentKey":"vrfStaticRoutesDevicesGroup",
                "key":"cfedd130-b898-4446-91ec-971c7d1c2985",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches which will have the static route configured on them.",
                "columns":[
                  {
                    "tagLabel":"Site",
                    "suggestedValues":[
                      
                    ]
                  }
                ]
              },
              "vrfStaticRoutesApply":{
                "key":"vrfStaticRoutesApply",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "campusType":{
                    "value":[
                      "__ANY__"
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "vrfL3InterfacesCollection":{
                "key":"vrfL3InterfacesCollection",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfL3InterfaceDetails":{
                "key":"vrfL3InterfaceDetails",
                "type":"INPUT",
                "order":[
                  "vrfL3InterfaceName",
                  "vrfL3InterfaceIpAddress",
                  "vrfL3InterfaceDescription",
                  "vrfL3InterfaceEnabled",
                  "vrfL3InterfaceMtu",
                  "vrfL3InterfaceOspf",
                  "vrfL3InterfaceEosCli"
                ]
              },
              "vrfL3InterfaceOspfSimpleAuthKey":{
                "key":"vrfL3InterfaceOspfSimpleAuthKey",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Simple"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfEnabled":{
                "key":"vrfL3InterfaceOspfEnabled",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfaceOspfArea":{
                "key":"vrfL3InterfaceOspfArea",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfaceOspfCost":{
                "key":"vrfL3InterfaceOspfCost",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfaceOspfPointToPoint":{
                "key":"vrfL3InterfaceOspfPointToPoint",
                "type":"INPUT",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND"
              },
              "vrfL3InterfaceOspfAuthentication":{
                "key":"vrfL3InterfaceOspfAuthentication",
                "type":"INPUT",
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vrfL3InterfaceOspfMessageDigestKeyId":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyId",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyHashAlgorithm",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "vrfL3InterfaceOspfMessageDigestKeyKey":{
                "key":"vrfL3InterfaceOspfMessageDigestKeyKey",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "OSPF"
                    ],
                    "mode":"SHOW"
                  },
                  "sviOspfAuthentication":{
                    "value":[
                      "Message-Digest"
                    ],
                    "mode":"SHOW"
                  }
                },
                "dependencyType":"AND",
                "type":"INPUT"
              },
              "1d13d361-e090-456d-8f9e-22ac4c97af48":{
                "type":"TAGGER",
                "parentKey":"vrfExternalBgpPeersDevicesGroup",
                "key":"1d13d361-e090-456d-8f9e-22ac4c97af48",
                "name":"Switches",
                "assignmentType":"SINGLE",
                "prepopulate":false,
                "tagType":"DEVICE",
                "description":"View the switches which will have the BGP peer configured on them.",
                "columns":[
                  {
                    "tagLabel":"Site",
                    "suggestedValues":[
                      
                    ]
                  }
                ],
                "dependencyType":"AND",
                "dependency":{
                  "siteUnderlayRoutingProtocol":{
                    "value":[
                      "BGP"
                    ],
                    "mode":"SHOW"
                  }
                }
              }
            }