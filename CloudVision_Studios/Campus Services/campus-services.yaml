- service: arista.studio.v1.StudioConfigService
  method: Set
  body:
    value:
      key:
        studio_id: 5848cc0b-7bcd-4bfb-972a-de3e3e41530e
        workspace_id: ''
      display_name: Campus Services
      description: ''
      template:
        type: TEMPLATE_TYPE_MAKO
        body: |
          <%
          import sys
          import os
          import json
          import ipaddress
          import re
          from collections import OrderedDict
          import tagsearch_python.tagsearch_pb2_grpc as tsgr
          import tagsearch_python.tagsearch_pb2 as tspb
          from arista.tag.v2.tag_pb2 import Tag, \
              TagKey, \
              TagAssignment, \
              TagAssignmentKey, \
              TagAssignmentConfig

          def convert(text):
              return int(text) if text.isdigit() else text.lower()

          def alphanum_key(key):
              return [convert(c) for c in re.split('([0-9]+)', str(key))]

          def natural_sort(iterable):
              if iterable is None:
                  return list()
              return sorted(iterable, key=alphanum_key)

          def string_to_list(string_to_convert):
              numbers = []
              segments = [ segment.strip() for segment in string_to_convert.split(",") ]
              for segment in segments:
                  if "-" in segment:
                      for i in range(int(segment.split("-")[0]), int(segment.split("-")[1]) + 1):
                          numbers.append(i)
                  else:
                      numbers.append(int(segment))    
              return numbers

          from itertools import count, groupby
          def list_compress(list_to_compress):
              if not isinstance(list_to_compress, list):
                  raise TypeError('value must be of type list, got %s' % type(list_to_compress))
              G = (list(x) for y, x in groupby(sorted(list_to_compress), lambda x, c=count(): next(c) - x))
              return (",".join("-".join(map(str, (g[0], g[-1])[:len(g)])) for g in G))

          def validIPAddress(ip):
              '''
              Returns True for a valid ipv4 address
              Returns False for a valid ipv6 address
              Return None for a nonvalid ip address
              '''
              try:
                  return True if type(ipaddress.ip_address(ip)) is ipaddress.IPv4Address else False
              except ValueError:
                  return None

          def get_interfaces_info(switch_facts):
              device_id = switch_facts["serial_number"]
              uplink_interfaces = {}
              downlink_interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None:
                      if switches_in_my_campus.get(peer_device.id):
                          neighbor = switches_in_my_campus.get(peer_device.id)
                          if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3"):
                              if neighbor["network_services"].get("l2") and not neighbor["network_services"].get("l3"):
                                  downlink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                              elif not neighbor["network_services"].get("l2") and neighbor["network_services"].get("l3"):
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
                          
                          elif switch_facts["network_services"].get("l2") and not switch_facts["network_services"].get("l3"):
                              if neighbor["network_services"].get("l2") and neighbor["network_services"].get("l3"):
                                  uplink_interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}

              return OrderedDict(natural_sort(uplink_interfaces.items())), \
                      OrderedDict(natural_sort(downlink_interfaces.items())), \

          def set_topology_facts(switch_facts):
              topology_facts = {
                  "links": {}
              }
              if switch_facts["uplink_type"] == "p2p":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["peer_bgp_as"] = uplink_switch_facts.get("bgp_as")
                      link_facts["type"] = "underlay_p2p"
                      link_facts["ip_address"] = str(get_p2p_uplinks_ip(switch_facts, uplink_switch_facts))
                      link_facts["peer_ip_address"] = str(get_p2p_uplinks_peer_ip(switch_facts, uplink_switch_facts))
                      if switch_facts.get("underlay_multicast"):
                          link_facts["pim_enabled"] = True
                      else:
                          link_facts["pim_enabled"] = False
                      topology_facts["links"][uplink_interface] = link_facts

              elif switch_facts["uplink_type"] == "port-channel":
                  for i, uplink_interface in enumerate(switch_facts["uplink_interfaces"]):
                      link_facts = {}
                      uplink_switch_id = switch_facts["uplink_switches_ids"][i]
                      uplink_switch_facts = switches_in_my_campus[uplink_switch_id]
                      link_facts["peer_id"] = uplink_switch_facts["serial_number"]
                      link_facts["peer"] = uplink_switch_facts["hostname"]
                      link_facts["peer_interface"] = switch_facts["uplink_switch_interfaces"][i]
                      link_facts["allowed_vlans"] = get_all_vlans(switch_facts)
                      link_facts["type"] = "underlay_l2"
                      if switch_facts.get("mlag_role") is not None and switch_facts["mlag_role"] == "secondary":
                          mlag_peer_switch_facts =  switches_in_my_campus[switch_facts["mlag_peer_serial_number"]]
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', mlag_peer_switch_facts["uplink_switch_interfaces"][0]))
                      else:
                          link_facts["channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_interfaces"][0]))
                          link_facts["peer_channel_group_id"] = "".join(re.findall(r'\d', switch_facts["uplink_switch_interfaces"][0]))
                      topology_facts["links"][uplink_interface] = link_facts

              switch_facts["topology"] = topology_facts
              return switch_facts

          def get_mlag_peer(switch_facts):
              mlag_peer_switch_serial_number = None
              if switch_facts["network_services"].get("l2"):
                  if switch_facts["network_services"].get("l3"):
                      # VTEP
                      if switch_facts.get("mlag"):
                          # Get MLAG peer from interface details
                          # Assumption is that this switch's MLAG peer should be the only neighbor switch with 
                          # both L2 and L3 network services enabled
                          for info in switch_facts["interfaces"].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                              if neighbor_switch_facts and neighbor_switch_facts["network_services"].get("l2") \
                                 and neighbor_switch_facts["network_services"].get("l3"):
                                  mlag_peer_switch_serial_number = neighbor_switch_facts["serial_number"]
                                  break
                  else:
                      # Layer 2 switch
                      if switch_facts.get("mlag"):
                          # Get MLAG peer from neighbor details
                          # Assumption is that this switch has to be either a DC L2 Leaf or a Campus Pod L2 Primary/Secondary Leaf switch
                          # since L2/L3 switches hit above if statement and Campus Pod member switches shouldn't have MLAG enabled
                          for info in switch_facts["interfaces"].values():
                              neighbor_switch_facts = get_switch_basics_from_tags(info["neighborId"])
                              if neighbor_switch_facts is None:
                                  continue
                              if neighbor_switch_facts["network_services"].get("l2") \
                                 and not neighbor_switch_facts["network_services"].get("l3"):
                                  # Check to see if neighbor has mlag enabled as well
                                  if neighbor_switch_facts.get("mlag"):
                                      mlag_peer_switch_serial_number = neighbor_switch_facts["serial_number"]
                                      break
              return mlag_peer_switch_serial_number

          def get_all_interfaces_info(switch_facts):
              device_id = switch_facts["serial_number"]
              interfaces = {}
              for i in ctx.topology.getDevices(deviceIds=[device_id])[0].getInterfaces():
                  peer_device, peer_interface = i.getPeerInfo()
                  if peer_device is not None:
                      interfaces[i.name] = {"neighborId": peer_device.id, "neighborHostname": peer_device.hostName, "neighborInterface": peer_interface.name}
              return interfaces

          def normalize_service_info(switch_facts, vlans, vrfs):
              '''
              vlans is a dictionary of vlan dictionaries
              '''
              switch_facts["vrfs"] = {
                  "default": {
                      "svis": {}
                  }
              }
              for vrf, info in vrfs.items():
                  switch_facts["vrfs"][vrf] = {
                      "svis":{}
                  }
                  if info.get("ibgp_details") and info["ibgp_details"].get("iBgpSubnet") and switch_facts.get("mlag"):
                      switch_facts["vrfs"][vrf]["enable_mlag_ibgp_peering_vrfs"] = True
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"] = info["ibgp_details"]["iBgpVlanId"]
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet"] = info["ibgp_details"]["iBgpSubnet"]
                      switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"] = info["ibgp_details"]["iBgpSubnetMask"]

                  # normalize l3 interfaces
                  ## for iface in info.get("l3_interfaces").resolve(device=switch_facts["serial_number"])["interfaces"]:
                  ##     l3_interface = {}
                  ##     l3_interface["interfaces"] = [iface["name"]]
                  ##     l3_interface["ip_addresses"] = [iface["ipAddress"]]
                  ##     l3_interface["nodes"] = [switch_facts["serial_number"]]
                  ##     l3_interface["description"] = iface["description"]
                  ##     l3_interface["enabled"] = iface["enabled"]
                  ##     l3_interface["mtu"] = iface["mtu"]
                  ##     l3_interface["encapsulation_dot1q_vlan"] = None
                  ##     l3_interface["eos_cli"] = iface["eosCli"]
                  ##     switch_facts["vrfs"][vrf]["l3_interfaces"].append(l3_interface)

                  # normalize static routes
                  for sr in info.get("static_routes"):
                      # if static route is to be configured on switch
                      if sr["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          static_route = {}
                          static_route["destination_address_prefix"] = sr["routeDetails"].get("destinationAddressPrefix")
                          static_route["gateway"] = sr["routeDetails"].get("gateway")
                          static_route["distance"] = sr["routeDetails"].get("distance")
                          static_route["tag"] = sr["routeDetails"].get("tag")
                          static_route["name"] = sr["description"].replace(" ", "_")
                          static_route["metric"] = sr["routeDetails"].get("metric")
                          static_route["interface"] = sr["routeDetails"].get("interface")
                          static_route["nodes"] = [switch_facts["serial_number"]]
                          switch_facts["vrfs"][vrf]["static_routes"].append(static_route)

                  # normalize redistribute routes
                  switch_facts["vrfs"][vrf]["redistribute_static"] = info.get("redistribute_static_routes")
                  
                  # normalize external bgp peers
                  for bgp_peer in info.get("external_bgp_peers"):
                      # if bgp peer is to be configured on switch
                      if bgp_peer["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          peer_info = {}
                          peer_info["remote_as"] = bgp_peer["remoteAs"]
                          if bgp_peer.get("description") and bgp_peer["description"].strip() != "":
                              peer_info["description"] = bgp_peer["description"]
                          if bgp_peer.get("password") and bgp_peer["password"].strip() != "":
                              peer_info["password"] = bgp_peer["password"]
                          if bgp_peer.get("sendCommunity") and bgp_peer["sendCommunity"].strip() != "":
                              peer_info["send_community"] = bgp_peer["sendCommunity"]
                          if bgp_peer.get("nextHopSelf") and bgp_peer["nextHopSelf"].strip() != "":
                              peer_info["next_hop_self"] = bgp_peer["nextHopSelf"]
                          if bgp_peer["maxRoutes"].get("maximumRoutes"):
                              peer_info["maximum_routes"] = bgp_peer["maxRoutes"].get("maximumRoutes")
                          if bgp_peer["maxRoutes"].get("warningLimit"):
                              peer_info["warning_limit_routes"] = bgp_peer["maxRoutes"].get("warningLimit")
                          if bgp_peer["defaultOriginate"].get("always") and bgp_peer["defaultOriginate"]["always"].strip() != "":
                              peer_info["default_originate"] = {
                                  "always": bgp_peer["defaultOriginate"].get("always")
                              }
                          if bgp_peer.get("updateSource") and bgp_peer["updateSource"].strip() != "":
                              peer_info["update_source"] = bgp_peer["updateSource"]
                          if bgp_peer.get("ebgpMultihop"):
                              peer_info["ebgp_multihop"] = bgp_peer["ebgpMultihop"]

                          peer_info["nodes"] = [switch_facts["serial_number"]]
                          
                          if bgp_peer["nextHop"].get("iPv4NextHop") and bgp_peer["nextHop"]["iPv4NextHop"].strip() != "":
                              peer_info["set_ipv4_next_hop"] = bgp_peer["nextHop"]["iPv4NextHop"]
                          if bgp_peer["nextHop"].get("iPv6NextHop") and bgp_peer["nextHop"]["iPv6NextHop"].strip() != "":
                              peer_info["set_ipv6_next_hop"] = bgp_peer["nextHop"]["iPv6NextHop"]
                          if bgp_peer["routeMap"].get("routeMapOut") and bgp_peer["routeMap"]["routeMapOut"].strip() != "":
                              peer_info["route_map_out"] = bgp_peer["routeMap"]["routeMapOut"] 
                          if bgp_peer["routeMap"].get("routeMapIn") and bgp_peer["routeMap"]["routeMapIn"].strip() != "":
                              peer_info["route_map_in"] = bgp_peer["routeMap"]["routeMapIn"]
                          if bgp_peer.get("weight"):
                              peer_info["weight"] = bgp_peer["weight"]
                          if bgp_peer.get("localAs"):
                              peer_info["local_as"] = bgp_peer["localAs"]
                          switch_facts["vrfs"][vrf]["bgp_peers"][bgp_peer["neighborIpAddress"]] = peer_info

              switch_facts["l2vlans"] = {}
              for vlan, vlan_info in vlans.items():
                  vlan_dict = {
                      "name": vlan_info["name"],
                      "dhcp_server_details": vlan_info["dhcp_server_details"],
                      "eos_cli": vlan_info["eos_cli"]
                  }
                  if vlan_info["svi_ip_address"] is not None and vlan_info["svi_ip_address"].strip() not in ["", "None"]:
                      # configure ip virtual-router address and real ip address
                      svi_vip = vlan_info["svi_ip_address"]
                      svi_network = ipaddress.ip_interface(svi_vip).network
                      first_host = list(svi_network.hosts())[0]
                      last_host = list(svi_network.hosts())[-1]
                      if str(first_host) == svi_vip.split("/")[0]:
                          position = "start"
                      elif str(last_host) == svi_vip.split("/")[0]:
                          position = "end"
                      else:
                          assert False, "Error: {}'s virtual IP address must be either the " \
                          "first or last host address in the subnet if 'ip virtual-router address'"\
                          " config type is set".format(vlan)
                      if switch_facts.get("mlag_role") and switch_facts["mlag_role"] == "secondary":
                          # take higher host address closest to vip
                          if position == "start":
                              svi_ip = list(svi_network.hosts())[2]
                          else:
                              svi_ip = list(svi_network.hosts())[-2]
                      else:
                          # take lower host address closest to vip
                          if position == "start":
                              svi_ip = list(svi_network.hosts())[1]
                          else:
                              svi_ip = list(svi_network.hosts())[-3]
                      vlan_dict["ip_virtual_router_addresses"] = [svi_vip]
                      vlan_dict["ip_address"] = "{}/{}".format(svi_ip, svi_network.prefixlen)
                      if vlan_info.get("vrf") and vlan_info["vrf"].strip() not in ["", "None"]:
                          vrf = vlan_info["vrf"].strip()
                          vlan_dict["vrf"] = vlan_info["vrf"].strip()
                      else:
                          vrf = "default"
                          vlan_dict["vrf"] = "default"
                      switch_facts["vrfs"][vrf]["svis"][vlan] = vlan_dict
                  else:
                      switch_facts["l2vlans"][vlan] = vlan_dict
              return switch_facts

          def get_all_vlans(switch_facts):
              all_vlans = []
              for vrf_info in switch_facts["vrfs"].values():
                  if vrf_info.get("svis"):
                      all_vlans += [ int(svi) for svi in vrf_info["svis"].keys() ]

              all_vlans += [ int(vlan) for vlan in switch_facts["l2vlans"].keys() ] 
              return all_vlans

          def set_base_config(config, switch_facts):    
              # Set router-bgp
              if switch_facts["network_services"].get("l3"):
                  # set bgp if relevant
                  if switch_facts.get("bgp_as"):
                      config["router_bgp"]["as"] = switch_facts["bgp_as"]
                      config["router_bgp"]["router_id"] = switch_facts["router_id"]

              return config


          def set_network_services_config(config, switch_facts):
              # Configure vlans
              if switch_facts["network_services"].get("l2"):
                  # Enable dhcp smart relay
                  config["ip_dhcp_relay"] = {
                      "information_option": True
                  }
                  # Enable dhcp snooping
                  config["ip_dhcp_snooping"] = {
                      "information_option": True,
                      "vlans": []
                  }
                  # Set l3 vlan config
                  for vrf in switch_facts["vrfs"].keys():
                      # Create vlans
                      for svi in switch_facts["vrfs"][vrf]["svis"].keys():
                          #Create L3 vlans
                          config["vlans"][svi] = {
                              "name": switch_facts["vrfs"][vrf]["svis"][svi]["name"]
                          }
                          # Create L3 SVI with helper address pointing towards CVP
                          config["vlan_interfaces"]["Vlan{}".format(svi)] = {}
                          config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                              "127.0.0.1": {}
                          }
                          # enable snooping on that vlan
                          config["ip_dhcp_snooping"]["vlans"].append(svi)

                      # Set vrf ibgp peering vlan params
                      if switch_facts.get("mlag") and switch_facts["network_services"].get("l3") \
                          and switch_facts["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                          config["vlans"][ibgp_vlan] = {
                              "name": "MLAG_iBGP_{}".format(vrf),
                              "trunk_groups": ["MLAG_VRF_PEER"]
                          }
                          
                  # Set l2 vlan config
                  for vlan, info in switch_facts["l2vlans"].items():
                      config["vlans"][vlan] = {
                          "name": info["name"]
                      }
                      # Create L2 SVI with helper address pointing towards CVP
                      config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                          "127.0.0.1": {}
                      }
                      # enable snooping on the vlan
                      config["ip_dhcp_snooping"]["vlans"].append(vlan)

                  if switch_facts["allow_all_vlans"] == False:
                      # Get transit port-channels to be set for allowed_vlans
                      underlay_data = {}
                      underlay_data["links"] = switch_facts["topology"]["links"]
                      # First add interface details from devices whose uplink interface neighbors are this switch
                      for sn in switch_facts["downlink_switches_ids"]:
                          neighbor_switch_facts = switches_in_my_campus[sn]
                          for neighbor_link, neighbor_link_info in neighbor_switch_facts["topology"]["links"].items():
                              if neighbor_link_info["peer_id"] == switch_facts["serial_number"]:
                                  link = {}
                                  link["peer_id"] = neighbor_switch_facts["serial_number"]
                                  link["peer"] = neighbor_switch_facts["hostname"]
                                  link["peer_interface"] = neighbor_link
                                  link["type"] = neighbor_link_info["type"]
                                  link["channel_group_id"] = neighbor_link_info.get("peer_channel_group_id")
                                  link["peer_channel_group_id"] = neighbor_link_info.get("channel_group_id")
                                  link["allowed_vlans"] = neighbor_link_info.get("allowed_vlans")
                                  interface = neighbor_link_info["peer_interface"]
                                  underlay_data["links"][interface] = link

                      # set transit port-channel interfaces
                      port_channel_list = []
                      for iface in underlay_data["links"]:
                          link = underlay_data["links"][iface]
                          if link["type"] == "underlay_l2" and \
                          link.get("channel_group_id") and \
                          link.get("channel_group_id") not in port_channel_list:
                              port_channel_list.append(link["channel_group_id"])
                              config["port_channel_interfaces"]["Port-Channel{}".format(link["channel_group_id"])] = {
                                  "mode": "trunk",
                                  "vlans": list_compress(link["allowed_vlans"])
                              }

              # if mlag is enabled
              if switch_facts.get("mlag"):
                  # Get mlag_peer_switch facts
                  mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts["mlag_peer_serial_number"])
                  mlag_peer_switch_facts = set_switch_facts(mlag_peer_switch_facts, campus)
                  # Initialize mlag port-channel interface for ibgp trunk groups
                  config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])] = {"trunk_groups": []}

              if switch_facts["network_services"].get("l3"):
                  for vrf, info in switch_facts["vrfs"].items():
                      if vrf == "default":
                          config["ip_routing"] = True
                      else:
                          # configure vrfs
                          config["vrfs"][vrf] = {
                              "ip_routing": True
                          }
                      # configure static routes
                      if info.get("static_routes") is not None:
                          for static_route in info["static_routes"]:
                              sr = {
                                  "destination_address_prefix": static_route["destination_address_prefix"],
                                  "vrf": vrf
                              }
                              if static_route.get("gateway") and static_route["gateway"].strip() != "":
                                  sr["gateway"] = static_route["gateway"]
                              if static_route.get("distance") and static_route["distance"].strip() != "":
                                  sr["distance"] = static_route["distance"]
                              if static_route.get("tag") and static_route["tag"].strip() != "":
                                  sr["tag"] = static_route["tag"]
                              if static_route.get("name") and static_route["name"].strip() != "":
                                  sr["name"] = static_route["name"]
                              if static_route.get("metric") and static_route["metric"].strip() != "":
                                  sr["metric"] = static_route["metric"]
                              if static_route.get("interface") and static_route["interface"].strip() != "":
                                  sr["interface"] = static_route["interface"]
                              config["static_routes"].append(sr)
                              
                      # configure ethernet interfaces
                      ## if info.get("l3_interfaces") is not None:
                      ##     l3_interface_subif_parents = []
                      ##     for l3_iface in info["l3_interfaces"]:
                      ##         eth_iface = {}
                      ##         l3_interface_subif_id = None
                      ##         if "." in l3_iface["interfaces"][0]:
                      ##             if l3_iface.get("encapsulation_dot1q_vlan"):
                      ##                 l3_interface_subif_id = l3_iface["encapsulation_dot1q_vlan"]
                      ##             else:
                      ##                 l3_interface_subif_id = l3_iface["interfaces"][0].split('.')[1]
                      ##             l3_interface_subif_parents.append(l3_iface["interfaces"][0].split('.')[0])
                      ##         if l3_interface_subif_id is not None:
                      ##             eth_iface["type"] = "l3dot1q"
                      ##             eth_iface["encapsulation_dot1q_vlan"] = l3_interface_subif_id
                      ##         else:
                      ##             eth_iface["type"] = "routed"
                      ##         eth_iface["peer_type"] = "l3_interface"
                      ##         eth_iface["vrf"] = vrf
                      ##         eth_iface["ip_address"] = l3_iface["ip_addresses"][0]
                      ##         if l3_iface.get("mtu"):
                      ##             eth_iface["mtu"] = l3_iface["mtu"]
                      ##         if l3_iface.get("enabled"):
                      ##             eth_iface["shutdown"] = False
                      ##         else:
                      ##             eth_iface["shutdown"] = True
                      ##         if l3_iface.get("description") and l3_iface["description"].strip() != "":
                      ##             eth_iface["description"] = l3_iface["description"]
                      ##         if l3_iface.get("eos_cli"):
                      ##             eth_iface["eos_cli"] = l3_iface["eos_cli"]
                      ##         config["ethernet_interfaces"][l3_iface["interfaces"][0]] = eth_iface
                      ##     for parent_iface in l3_interface_subif_parents:
                      ##         config["ethernet_interfaces"][parent_iface] = {
                      ##             "type": "routed",
                      ##             "peer_type": "l3_interface",
                      ##             "shutdown": False
                      ##         }

                      # configure route maps
                      if info.get("bgp_peers"):
                          for peer, peer_info in info["bgp_peers"].items():
                              if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                  config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)] = {
                                      "sequence_numbers": {
                                          10: {
                                              "type": "permit",
                                              "set": []
                                          }
                                      }
                                  }
                                  if peer_info.get("set_ipv4_next_hop"):
                                      config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                      ["sequence_numbers"][10]["set"].append(peer_info["set_ipv4_next_hop"])
                                  elif peer_info.get("set_ipv6_next_hop"):
                                      config["route_maps"]["RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)]\
                                      ["sequence_numbers"][10]["set"].append("set_ipv6_next_hop")


                      if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3"):
                          # configure svis
                          for svi, svi_info in switch_facts["vrfs"][vrf]["svis"].items():
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["vrf"] = vrf

                              # Configure VIP and IP
                              if svi_info.get("ip_address_virtual"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_address_virtual"] = svi_info["ip_address_virtual"]
                              if svi_info.get("ip_virtual_router_addresses"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_virtual_router_addresses"] = svi_info["ip_virtual_router_addresses"]
                              if svi_info.get("ip_address"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]\
                                  ["ip_address"] = svi_info["ip_address"]

                              # Add any ip helper addresses
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"] = {
                                  "127.0.0.1": {
                                      "vrf": "default"
                                  }
                              }
                              if svi_info.get("ip_helpers"):
                                  for helper_address, dhcp_info in svi_info["ip_helpers"].items():
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["ip_helpers"][helper_address] = {
                                          "source_interface": dhcp_info.get("source_interface")
                                      }
                              # if mtu
                              if svi_info.get("mtu"):
                                  config["vlan_interfaces"]["Vlan{}".format(svi)]["mtu"] = svi_info["mtu"]
                              # if arp aging timeout
                              if svi_info.get("arp"):
                                  if svi_info["arp"].get("aging_timeout"):
                                      config["vlan_interfaces"]["Vlan{}".format(svi)]["arp_aging_timeout"] = svi_info["arp"]["aging_timeout"]
                              # configure eos_cli statements
                              config["vlan_interfaces"]["Vlan{}".format(svi)]["eos_cli"] = svi_info["eos_cli"]                       

                      # configure vrf ibgp mlag peer interface
                      if switch_facts.get("mlag") \
                          and info.get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = info["mlag_ibgp_peering_vlan"]
                          ibgp_peering_subnet = info["mlag_ibgp_peering_subnet"]
                          ibgp_peering_subnet_mask = info["mlag_ibgp_peering_subnet_mask"]
                          mlag_ip = str(get_mlag_ip(
                                  switch_facts, 
                                  ibgp_peering_subnet, 
                                  ibgp_peering_subnet_mask,
                                  switch_facts["mlag_role"]
                                  )
                              )
                          config["vlan_interfaces"]["Vlan{}".format(ibgp_vlan)] = {
                              "type": "underlay_peering",
                              "shutdown": False,
                              "description": "MLAG_PEER_L3_iBGP:{}".format(vrf),
                              "vrf": vrf,
                              "ip_address": "{}/{}".format(mlag_ip, ibgp_peering_subnet_mask)
                          }
                          if "MLAG_VRF_PEER" not in config["port_channel_interfaces"]\
                              ["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"]:
                              config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]\
                                  ["trunk_groups"].append("MLAG_VRF_PEER")

              # Set bgp
              if switch_facts["network_services"].get("l3") and switch_facts.get("bgp_as"):
                  config["router_bgp"]["vrfs"] = {}
                  config["router_bgp"]["vlans"] = {}
                  # Set vrfs
                  for vrf, vrf_info in switch_facts["vrfs"].items():
                      if vrf == "default":
                          continue
                      address_family_ipv4_neighbors = [] 
                      address_family_ipv6_neighbors = []
                      # initialize vrf
                      config["router_bgp"]["vrfs"][vrf] = {
                          "router_id": switch_facts["router_id"],
                          "neighbors": {},
                          "redistribute_routes": {
                              ## "connected": {}
                              # "attached-host": {}
                          },
                          "address_families": {
                              "ipv4": {"neighbors": {}, "networks":{}},
                              "ipv6": {"neighbors": {}, "networks":{}}
                          }
                      }
                      # get and set mlag peer config
                      if switch_facts.get("mlag") \
                      and switch_facts["vrfs"][vrf].get("enable_mlag_ibgp_peering_vrfs"):
                          ibgp_vlan = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_vlan"]
                          ibgp_peering_subnet = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet"]
                          ibgp_peering_subnet_mask = switch_facts["vrfs"][vrf]["mlag_ibgp_peering_subnet_mask"]
                          mlag_peer_ip = str(get_mlag_ip(
                                  switch_facts, 
                                  ibgp_peering_subnet, 
                                  ibgp_peering_subnet_mask,
                                  mlag_peer_switch_facts["mlag_role"]
                                  )
                              )
                          # Add mlag_ip to nieghbors and address family
                          config["router_bgp"]["vrfs"][vrf]["neighbors"][mlag_peer_ip] = {
                              "remote_as": switch_facts["bgp_as"],
                              "description": mlag_peer_switch_facts["hostname"]
                          }
                          address_family_ipv4_neighbors.append(mlag_peer_ip)
                      # set external bgp peers
                      if vrf_info.get("bgp_peers"):
                          for peer, peer_info in vrf_info["bgp_peers"].items():
                              if validIPAddress(peer) == True:
                                  address_family_ipv4_neighbors.append(peer)
                              elif validIPAddress(peer) == False:
                                  address_family_ipv6_neighbors.append(peer)
                              else:
                                  continue
                              if peer_info.get("set_ipv4_next_hop") or peer_info.get("set_ipv6_next_hop"):
                                  peer_info.update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                  if peer_info.get("default_originate"):
                                      if not peer_info["default_originate"].get("route_map"):
                                          peer_info["default_originate"].update({"route_map_out": "RM-{}-{}-SET-NEXT-HOP-OUT".format(vrf, peer)})
                                  if peer_info.get("set_ipv4_next_hop"):
                                      peer_info.pop("set_ipv4_next_hop")
                                  if peer_info.get("set_ipv6_next_hop"):
                                      peer_info.pop("set_ipv6_next_hop")
                              config["router_bgp"]["vrfs"][vrf]["neighbors"][peer] = peer_info
                      # redistribute static routes
                      if vrf_info.get("redistribute_static"):
                          config["router_bgp"]["vrfs"][vrf]["redistribute_routes"]["static"] = {}
                      # activate neighbors for ipv4 address family
                      if len(address_family_ipv4_neighbors) > 0:
                          for neighbor in address_family_ipv4_neighbors:
                              config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"]["neighbors"][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv4"])
                      # activate neighbors for ipv6 address family
                      if len(address_family_ipv6_neighbors) > 0:
                          for neighbor in address_family_ipv6_neighbors:
                              config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"]["neighbors"][neighbor] = {
                                  "activate": True
                              }
                      else:
                          del(config["router_bgp"]["vrfs"][vrf]["address_families"]["ipv6"])
              
              # clean up
              if config["router_bgp"].get("vrfs"):
                  # Clean up bgp config if only vrf present is default vrf
                  vrfs_to_delete = []
                  for vrf, info in config["router_bgp"]["vrfs"].items():
                      if len(info["neighbors"]) == 0:
                          vrfs_to_delete.append(vrf)
                  for vrf in vrfs_to_delete:
                      del(config["router_bgp"]["vrfs"][vrf])
                  # get rid of bgp entirely if there are no vrfs
                  if len(config["router_bgp"]["vrfs"]) == 0:
                      del(config["router_bgp"])
              if switch_facts.get("mlag") and \
                  len(config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"]) == 0:
                  del(config["port_channel_interfaces"]["Port-Channel{}".format(switch_facts["mlag_port_channel_id"])]["trunk_groups"])
              return config


          def get_switch_basics_from_tags(device_id):
              switch_facts = {"serial_number": device_id}
              switch_facts["network_services"] = {}
              tags_to_facts = {
                  "hostname": "hostname",
                  "model": "platform",
                  "node_id": "id",
                  "router_bgp.as": "bgp_as",
                  "router_bgp.router_id": "router_id",
                  "mlag_configuration.peer_link": "mlag_port_channel_id",
                  "Campus": "campus",
                  "Campus-PoD": "group",
                  "Leaf-Domain": "group",
                  "group_id": "group_id",
                  "vtep": "vtep"
              }
              # Network services is a special case
              tags_to_facts["network_services"] = None

              tsclient = ctx.getApiClient(tsgr.TagSearchStub)
              for label in tags_to_facts.keys():
                  if label == "hostname":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.hostName:
                              switch_facts[tags_to_facts[label]] = dev.hostName
                      continue
                  elif label == "model":
                      for dev in ctx.topology.getDevices(deviceIds=[device_id]):
                          if dev.modelName:
                              switch_facts[tags_to_facts[label]] = dev.modelName
                      continue
                  elif label == "network_services":
                      tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                      for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                          try:
                              query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                          except:
                              continue
                          else:
                              for match in tagmresp.matches:
                                  if match.device.device_id == device_id:
                                      if tag.value.lower() == "l2":
                                          switch_facts["network_services"]["l2"] = True
                                      elif tag.value.lower() == "l3":
                                          switch_facts["network_services"]["l3"] = True
                  else:
                      tvsr = tspb.TagValueSearchRequest(label=label, workspace_id=workspace_id, topology_studio_request=True)
                      for tag in tsclient.GetTagValueSuggestions(tvsr).tags:
                          try:
                              query= "{}:\"{}\" AND device:{}".format(tag.label, tag.value, device_id)
                              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
                              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
                          except:
                              continue
                          else:
                              for match in tagmresp.matches:
                                  if match.device.device_id == device_id:
                                      switch_facts[tags_to_facts[tag.label]] = tag.value
                                      break
              # Set l2 and l3 network_services if they haven't been set
              if switch_facts["network_services"].get("l2") is None:
                  switch_facts["network_services"]["l2"] = False
              if switch_facts["network_services"].get("l3") is None:
                  switch_facts["network_services"]["l3"] = False

              # normalize mlag_port_channel_id
              if switch_facts.get("mlag_port_channel_id"):
                  switch_facts["mlag_port_channel_id"] = "".join(re.findall(r'\d', switch_facts["mlag_port_channel_id"]))
                  switch_facts["mlag"] = True
              else:
                  switch_facts["mlag"] = False

              # normalize vtep
              if switch_facts.get("vtep"):
                  if re.match(r'true', switch_facts["vtep"], flags=re.IGNORECASE):
                      switch_facts["vtep"] = True
                  else:
                      switch_facts["vtep"] = False
              else:
                  switch_facts["vtep"] = False

              # Set other keys
              if switch_facts["network_services"].get("l3"):
                  switch_facts["uplink_type"] = "p2p"
              else:
                  switch_facts["uplink_type"] = "port-channel"

              if not switch_facts.get("campus"):
                  return

              return switch_facts

          def set_switch_facts(switch_facts, campus_resolver):
              campus_resolved = campus_resolver.resolve(device=switch_facts["serial_number"])
              site_resolved = campus_resolved["campusDetails"]["site"].resolve(device=switch_facts["serial_number"])
              site_group = site_resolved["siteFacts"]

              device_id = switch_facts["serial_number"]

              switch_facts["allow_all_vlans"] = site_group["allowAllVlans"]
              # Get interface info from studio topology tags
              uplink_interfaces, downlink_interfaces = get_interfaces_info(switch_facts)

              # Used to get mlag peer
              switch_facts["interfaces"] = get_all_interfaces_info(switch_facts)

              # Define switch uplink info
              switch_facts["uplink_switches_ids"] = [ info["neighborId"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switches"] = [ info["neighborHostname"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_switch_interfaces"] = [ info["neighborInterface"] for info in uplink_interfaces.values() ]
              switch_facts["uplink_interfaces"] = [ iface for iface in uplink_interfaces.keys() ]

              # Define switch downlink neighbor ids
              switch_facts["downlink_switches_ids"] = [ info["neighborId"] for info in downlink_interfaces.values() ]

              # Get mlag peer and mlag details
              if switch_facts.get("mlag"):
                  switch_facts["mlag_peer_serial_number"] = get_mlag_peer(switch_facts)

              # Set mlag relevant facts
              if switch_facts.get("mlag_peer_serial_number"):
                  mlag_peer_switch_facts = get_switch_basics_from_tags(switch_facts["mlag_peer_serial_number"])
                  switch_facts["mlag"] = True
                  if int(switch_facts["id"]) < int(mlag_peer_switch_facts["id"]):
                      switch_facts["mlag_role"] = "primary"
                      switch_facts["mlag_primary_id"] = int(switch_facts["id"])
                  else:
                      switch_facts["mlag_role"] = "secondary"
                      switch_facts["mlag_primary_id"] = int(mlag_peer_switch_facts["id"])

              return switch_facts

          def get_switches_in_my_campus_basics(switch_facts):
              # Dictionary of switches that will be returned
              switches_in_my_campus = {}

              #Create tagstub
              tsclient = ctx.getApiClient(tsgr.TagSearchStub)

              #Get switches in same Campus
              query= "{}:\"{}\"".format("Campus", switch_facts["campus"])
              tagmr = tspb.TagMatchRequestV2(query=query, workspace_id=workspace_id, topology_studio_request=True)
              tagmresp =  tsclient.GetTagMatchesV2(tagmr)
              for match in tagmresp.matches:
                  switch_in_my_campus_facts = get_switch_basics_from_tags(match.device.device_id)
                  if switch_in_my_campus_facts is None:
                      continue
                  if match.device.device_id not in switches_in_my_campus:
                      switches_in_my_campus[match.device.device_id] = switch_in_my_campus_facts
              return switches_in_my_campus

          def get_services_applied_to_switch(switch_facts, campus_resolver):
              '''
              Returns switch facts with 'applied_vlans' and 'applied_vrfs' keys set and values for those keys being a list of vlan IDs and vrfs, respectively
              '''
              campus_resolved = campus_resolver.resolve(device=switch_facts["serial_number"])
              site_resolved = campus_resolved["campusDetails"]["site"].resolve(device=switch_facts["serial_number"])
              vlans_input = site_resolved["siteFacts"]["vlans"]
              vrfs_input = site_resolved["siteFacts"]["vrfs"]
              # format vrfs
              vrfs = {}
              switch_vrfs = {}
              for vrf in vrfs_input:
                  vrfs[vrf["name"]] = {
                      "ibgp_details": vrf["ibgpDetails"],
                      ## "l3_interfaces": vrf["l3Interfaces"],
                      "static_routes": vrf["staticRoutes"],
                      "redistribute_static_routes": vrf["redistributeStaticRoutes"],
                      "external_bgp_peers": vrf["externalBgpPeers"],
                  }
              # format vlans and determine if they should be applied to switch
              switch_vlans = {}
              for vlan in vlans_input:
                  # check if vlan is applied
                  if switch_facts["network_services"].get("l2") and switch_facts["network_services"].get("l3"):
                      vlan_applied = True
                  else:   
                      if vlan["campusPoD"].resolve(device=switch_facts["serial_number"]) is not None and \
                              vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"]:
                          vlan_applied = vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"]["apply"]
                      else:
                          vlan_applied = False
                  # if vlan is applied, format and add details to switch_vlans
                  if vlan_applied == True:
                      vlan_info = {
                          "name": vlan["name"],
                          "vrf": vlan["sviDetails"]["vrf"],
                          "dhcp_server_details": vlan["dhcpHelpers"],
                          ## "arp": vlan["arp"],
                          ## "mtu": vlan["mtu"],
                          "eos_cli": vlan["eosCli"]
                      }
                      # Set svi ip address
                      vlan_info["svi_ip_address"] = None
                      if network_type == "L3":
                          if vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"]:
                              vlan_info["svi_ip_address"] = vlan["campusPoD"].resolve(device=switch_facts["serial_number"])["poDDetails"].get("sviIpAddress")
                      else:
                          vlan_info["svi_ip_address"] = vlan["sviDetails"]["ipAddress"]

                      # add vlan to switch_vlans
                      switch_vlans[vlan["vlanId"]] = vlan_info

                      # add vrf to switch_vrfs if necessary
                      if vlan_info.get("vrf") and vlan_info["vrf"].strip() not in ["", "None"]:
                          switch_vrfs[vlan_info["vrf"]] = vrfs[vlan_info["vrf"]]

              # Get vrfs that should be configured on the switch
              for vrf, info in vrfs.items():
                  vrf_set = None
                  ## # check if any l3 interfaces resolve
                  ## if len(info.get("l3_interfaces").resolve(device=switch_facts["serial_number"])["interfaces"]) > 0:
                  ##     switch_vrfs[vrf] = info
                  ##     continue        

                  # check if apply column resolves for any static routes
                  for sr in info.get("static_routes"):
                      # if static route is to be configured on switch
                      if sr["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          switch_vrfs[vrf] = info
                          break
                  if switch_vrfs.get(vrf):
                      continue
                  # check if apply column resolves for external bgp neighbors
                  for bgp_peer in info.get("external_bgp_peers"):
                      # if bgp peer is to be configured on switch
                      if bgp_peer["devices"].resolve(device=switch_facts["serial_number"])["devices"]["hostname"].resolve(device=switch_facts["serial_number"]).get("apply"):
                          switch_vrfs[vrf] = info
                          break
                  if switch_vrfs.get(vrf):
                      continue

              switch_facts = normalize_service_info(switch_facts, switch_vlans, switch_vrfs)

          # Get studio info from ctx
          my_device = ctx.getDevice()
          workspace_id = ctx.studio.workspaceId

          # Initialize variables
          my_switch_facts = {}
          my_config = {}

          ## campus_resolved = campus.resolve(device=my_device.id)
          ## if campus_resolved["campusDetails"] is not None:
          ##     site_resolved = campus_resolved["campusDetails"]["site"].resolve(device=my_device.id)
          ## else:
          ##     site_resolved = None
          ## if site_resolved["siteFacts"] is not None:
          ##     network_type = "L2" if site_resolved["siteFacts"]["networkType"] == True else "L3"
          ##     input_vlans = site_resolved["siteFacts"]["vlans"]
          ##     input_vrfs = site_resolved["siteFacts"]["vrfs"]
          ## else:
          ##     network_type = None
          ##     input_vlans = None
          ##     input_vrfs = None

          # set switch_facts
          my_switch_facts = get_switch_basics_from_tags(my_device.id)

          if my_switch_facts is not None:
              # Get basic switch facts for all switches in the same campus as my_switch
              switches_in_my_campus = get_switches_in_my_campus_basics(my_switch_facts)

              # Get all switch facts
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = set_switch_facts(switch_facts, campus)

              # get services applied to switches
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = get_services_applied_to_switch(switch_facts, campus)

              # Get topology facts ( in order to set transit p2p and port-channel links )
              for switch_facts in switches_in_my_campus.values():
                  switch_facts = set_topology_facts(switch_facts)

              # Reset my_switch_facts
              my_switch_facts = switches_in_my_campus[my_device.id]

              # default vrf should be added automatically in normalize_service_info function so need to account for that in below 'if' statement
              if len(my_switch_facts["vrfs"].keys()) > 1 or len(my_switch_facts["vrfs"]["default"]["svis"]) > 0 or len(my_switch_facts["l2vlans"].keys()) > 0:
                  my_config = {
                      "vrfs": {},
                      "vlans": {},
                      "vlan_interfaces": {},
                      "port_channel_interfaces": {},
                      "ethernet_interfaces": {},
                      "loopback_interfaces": {},
                      "virtual_source_nat_vrfs": {},
                      "static_routes": [],
                      "route_maps": {},
                      "router_bgp": {
                          "peer_groups": {},
                      }
                  }
                  my_config = set_base_config(my_config, my_switch_facts)
                  my_config = set_network_services_config(my_config, my_switch_facts)

          config = my_config
          switch_facts = my_switch_facts
          %>
          ## ${json.dumps(switch_facts, indent=2)}
          ## ---------------------------
          ## ${json.dumps(config,indent=2)}
          % if config.get("ip_dhcp_relay"):
          %     if config["ip_dhcp_relay"].get("information_option"):
          ip dhcp relay information option
          %     endif
          !
          % endif
          ## eos - ip dhcp snooping
          %if config.get("ip_dhcp_snooping"):
          ip dhcp snooping
          !
          %   if config["ip_dhcp_snooping"].get("information_option"):
          ip dhcp snooping information option
          %   endif
          %   if config["ip_dhcp_snooping"].get("vlans"):
          %       for vlan in config["ip_dhcp_snooping"]["vlans"]:
          ip dhcp snooping vlan ${vlan}
          %       endfor
          %   endif
          !
          %endif
          ## eos - IP IGMP Snooping
          % if config.get("ip_igmp_snooping"):
          %    if not config["ip_igmp_snooping"].get("globally_enabled"):
          no ip igmp snooping
          %    elif config["ip_igmp_snooping"].get("vlans"):
          %      for vlan in natural_sort(config["ip_igmp_snooping"]["vlans"].keys()):
          %          if config["ip_igmp_snooping"]["vlans"]["enabled"]["querier"] == False:
          no ip igmp snooping vlan ${ vlan } querier
          %          endif %}
          !
          %      endfor %}
          !
          %    endif
          %endif
          ## eos - VLANs
          %if config.get("vlans") is not None:
          %     for vlan in natural_sort(config.get("vlans")):
          vlan ${ vlan }
          %          if config.get("vlans")[vlan].get("name") is not None:
          name ${ config.get("vlans")[vlan].get("name") }
          %          endif
          %          if config.get("vlans")[vlan].get("state") is not None:
          state ${ config.get("vlans")[vlan].get("state") }
          %          endif
          %          if config.get("vlans")[vlan].get("trunk_groups") is not None:
          %               for trunk_group in config.get("vlans")[vlan].get("trunk_groups"):
          trunk group ${ trunk_group }
          %               endfor
          %          endif
          !
          %    endfor %}
          %endif
          ## vrfs
          % if config.get("vrfs") is not None:
          %   for vrf in natural_sort(config["vrfs"].keys()):
          vrf instance ${ vrf }
          %     if config["vrfs"][vrf].get("description"):
          description ${ config["vrfs"][vrf]["description"] }
          %     endif
          !
          %   endfor
          ## eos- Port-Channel Interfaces
          % if config.get("port_channel_interfaces") is not None:
          %   for port_channel_interface in natural_sort(config["port_channel_interfaces"].keys()):
          interface ${ port_channel_interface }
          %     if config["port_channel_interfaces"][port_channel_interface].get("description") is not None:
          description ${ config["port_channel_interfaces"][port_channel_interface]["description"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("shutdown") == True:
          shutdown
          %     elif config["port_channel_interfaces"][port_channel_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mtu") is not None:
          mtu ${ config["port_channel_interfaces"][port_channel_interface]["mtu"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("type") is not None and config["port_channel_interfaces"][port_channel_interface].get("type") == "routed":
          no switchport
          %     else:
          switchport
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "access":
          switchport access vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("vlans") and config["port_channel_interfaces"][port_channel_interface]["mode"] == "trunk":
             switchport trunk allowed vlan ${ config["port_channel_interfaces"][port_channel_interface]["vlans"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("mode") is not None and config["port_channel_interfaces"][port_channel_interface].get("mode") == "trunk":
          switchport mode ${ config["port_channel_interfaces"][port_channel_interface]["mode"] }
          %     endif
          %     if config["port_channel_interfaces"][port_channel_interface].get("trunk_groups") is not None:
          %       for trunk_group in config["port_channel_interfaces"][port_channel_interface]["trunk_groups"]:
          switchport trunk group ${ trunk_group }
          %       endfor
          %     endif
          !
          %   endfor
          % endif
          ## eos - Ethernet Interfaces
          %if config.get("ethernet_interfaces") is not None:
          %for ethernet_interface in natural_sort(config["ethernet_interfaces"].keys()):
          interface ${ethernet_interface }
          %     if config["ethernet_interfaces"][ethernet_interface].get("description") is not None:
          description ${config["ethernet_interfaces"][ethernet_interface]["description"]}
          %     endif
          %     if config["ethernet_interfaces"][ethernet_interface].get("channel_group") is not None:
          channel-group ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["id"] } mode ${ config["ethernet_interfaces"][ethernet_interface]["channel_group"]["mode"] }
          %     else:
          %         if config["ethernet_interfaces"][ethernet_interface].get("mtu") is not None:
          mtu ${ config["ethernet_interfaces"][ethernet_interface]["mtu"] }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface].get("type") == "routed":
          no switchport
          %         elif config["ethernet_interfaces"][ethernet_interface].get("type") is not None and config["ethernet_interfaces"][ethernet_interface]["type"] == "l3dot1q" and config["ethernet_interfaces"][ethernet_interface].get("encapsulation_dot1q_vlan"):
          encapsulation dot1q vlan ${ config["ethernet_interfaces"][ethernet_interface]["encapsulation_dot1q_vlan"] }
          %         else:
          switchport
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "access":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport access vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None and config["ethernet_interfaces"][ethernet_interface].get("mode") == "trunk":
          %             if config["ethernet_interfaces"][ethernet_interface].get("vlans") is not None:
          switchport trunk allowed vlan ${ config["ethernet_interfaces"][ethernet_interface].get("vlans") }
          %             endif
          %             if config["ethernet_interfaces"][ethernet_interface].get("native_vlan") is not None:
          switchport trunk native vlan ${ config["ethernet_interfaces"][ethernet_interface].get("native_vlan") }
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("mode") is not None:
          switchport mode ${ config["ethernet_interfaces"][ethernet_interface].get("mode") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("trunk_groups") is not None:
          %             for trunk_group in config["ethernet_interfaces"][ethernet_interface].get("trunk_groups"):
          switchport trunk group ${ trunk_group }
          %             endfor
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("vrf") is not None:
          vrf ${ config["ethernet_interfaces"][ethernet_interface].get("vrf") }
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ip_address") is not None:
          ip address ${ config["ethernet_interfaces"][ethernet_interface].get("ip_address") }
          %             if config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries") is not None:
          %                 for ip_address_secondary in config["ethernet_interfaces"][ethernet_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %                 endfor
          %             endif
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_network_point_to_point"):
             ip ospf network point-to-point
          %         endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("ospf_area"):
             ip ospf area ${ config["ethernet_interfaces"][ethernet_interface]["ospf_area"] }
          %         endif
          %     endif
          %         if config["ethernet_interfaces"][ethernet_interface].get("pim"):
          %           if config["ethernet_interfaces"][ethernet_interface]["pim"]["ipv4"].get("sparse_mode"):
             pim ipv4 sparse-mode
          %           endif
          %         endif
          %    if config["ethernet_interfaces"][ethernet_interface].get("eos_cli"):
          %       for statement in config["ethernet_interfaces"][ethernet_interface]["eos_cli"]:
          ${statement}
          %       endfor
          %    endif
          !
          %endfor
          %endif
          ## eos - Loopback Interfaces
          %if config.get("loopback_interfaces") is not None:
          %   for loopback_interface in natural_sort(config.get("loopback_interfaces").keys()):
          interface ${ loopback_interface }
          %       if config["loopback_interfaces"][loopback_interface].get("description") is not None:
          description ${ config["loopback_interfaces"][loopback_interface].get("description") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == True:
          shutdown
          %       elif config["loopback_interfaces"][loopback_interface].get("shutdown") is not None and config["loopback_interfaces"][loopback_interface].get("shutdown") == False:
          no shutdown
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("vrf") is not None:
          vrf ${ config["loopback_interfaces"][loopback_interface].get("vrf") }
          %       endif
          %       if config["loopback_interfaces"][loopback_interface].get("ip_address") is not None:
          ip address ${ config["loopback_interfaces"][loopback_interface].get("ip_address") }
          %           if config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries") is not None:
          %               for ip_address_secondary in config["loopback_interfaces"][loopback_interface].get("ip_address_secondaries"):
          ip address ${ ip_address_secondary } secondary
          %               endfor
          %           endif
          %       endif
          !
          %   endfor
          %endif
          ## vlan-interfaces
          % if config.get("vlan_interfaces") is not None:
          %   for vlan_interface in natural_sort(config.get("vlan_interfaces").keys()):
          interface ${ vlan_interface }
          %     if config.get("vlan_interfaces")[vlan_interface].get("description") is not None:
          description ${ config.get("vlan_interfaces")[vlan_interface].get("description") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("shutdown") == True:
          shutdown
          %     elif config.get("vlan_interfaces")[vlan_interface].get("shutdown") == False:
          no shutdown
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("mtu") is not None:
          mtu ${ config.get("vlan_interfaces")[vlan_interface].get("mtu") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("no_autostate") == True:
          no autostate
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("vrf") is not None and config.get("vlan_interfaces")[vlan_interface]["vrf"] != "default":
          vrf ${ config.get("vlan_interfaces")[vlan_interface].get("vrf") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address") is not None:
          ip address ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address") }
          %         if config.get("vlan_interfaces")[vlan_interface].get("ip_address_secondaries") is not None:
          %             for ip_address_secondary in config["vlan_interfaces"][vlan_interface]["ip_address_secondaries"]:
          ip address ${ ip_address_secondary } secondary
          %             endfor
          %         endif
          %     endif
          %     if config["vlan_interfaces"][vlan_interface].get("ip_virtual_router_addresses") is not None:
          %         for ip_virtual_router_address in config["vlan_interfaces"][vlan_interface]["ip_virtual_router_addresses"]:
          ip virtual-router address ${ ip_virtual_router_address }
          %         endfor
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") is not None:
          ip address virtual ${ config.get("vlan_interfaces")[vlan_interface].get("ip_address_virtual") }
          %     endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("ip_helpers") is not None:
          %       for ip_helper in config["vlan_interfaces"][vlan_interface].get("ip_helpers").keys():
          <%        ip_helper_cli = "ip helper-address " + ip_helper %>
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("vrf") is not None:
          <%            ip_helper_cli = ip_helper_cli + " vrf " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("vrf") %>
          %         endif
          %         if config["vlan_interfaces"][vlan_interface]["ip_helpers"][ip_helper].get("source_interface") is not None:
          <%            ip_helper_cli = ip_helper_cli + " source-interface " + config.get("vlan_interfaces")[vlan_interface]["ip_helpers"][ip_helper].get("source_interface") %>
          %         endif %}
          ${ ip_helper_cli }
          %       endfor
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("arp_aging_timeout") is not None:
          arp aging timeout ${ config.get("vlan_interfaces")[vlan_interface]["arp_aging_timeout"] }
          %    endif
          %     if config.get("vlan_interfaces")[vlan_interface].get("igmp"):
          ip igmp
          %       if config.get("vlan_interfaces")[vlan_interface]["igmp"].get("query_interval"):
          ip igmp query-interval ${config.get("vlan_interfaces")[vlan_interface]["igmp"]["query_interval"]}
          %       endif
          %     endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("multicast"):
          %       if config.get("vlan_interfaces")[vlan_interface]["multicast"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("static"):
          multicast ipv4 static
          %           endif
          %       endif
          %    endif
          %    if config.get("vlan_interfaces")[vlan_interface].get("pim"):
          %       if config.get("vlan_interfaces")[vlan_interface]["pim"].get("ipv4"):
          %           if config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"].get("local_interface"):
          pim ipv4 local-interface ${config.get("vlan_interfaces")[vlan_interface]["multicast"]["ipv4"]["local_interface"]}
          %           endif
          %       endif
          %    endif
          %    if config["vlan_interfaces"][vlan_interface].get("eos_cli"):
          %       for statement in config["vlan_interfaces"][vlan_interface]["eos_cli"]:
          ${statement}
          %       endfor
          %    endif
          !
          %   endfor
          % endif
          ## vxlan-interfaces
          % if config.get("vxlan_interface"):
          interface Vxlan1
          %     if config["vxlan_interface"]["Vxlan1"].get("source_interface"):
          vxlan source-interface ${ config["vxlan_interface"]["Vxlan1"]["source_interface"] }
          %     endif
          %     if config["vxlan_interface"]["Vxlan1"].get("vxlan"):
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("virtual_router_encapsulation_mac_address"):
          vxlan virtual-router encapsulation mac-address ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["virtual_router_encapsulation_mac_address"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"].get("vxlan_udp_port"):
          vxlan udp-port ${ config["vxlan_interface"]["Vxlan1"]["vxlan_udp_port"] }
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vlans"):
          %             for vlan in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"].keys():
          vxlan vlan ${ vlan } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan].get("multicast"):
          vxlan vlan ${ vlan } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vlans"][vlan]["multicast"]["group"]}
          %               endif
          %             endfor
          %         endif
          %         if config["vxlan_interface"]["Vxlan1"]["vxlan"].get("vrfs"):
          %             for vrf in config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"].keys():
          vxlan vrf ${ vrf } vni ${ config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["vni"] }
          %               if config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf].get("multicast"):
          vxlan vlan ${ vrf } multicast group ${config["vxlan_interface"]["Vxlan1"]["vxlan"]["vrfs"][vrf]["multicast"]["group"]}
          %               endif
          %             endfor %}
          %         endif
          %     endif
          !
          % endif
          ## ip-routing
          %   for vrf in config.get("vrfs"):
          %       if config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == True  and vrf != 'default':
          ip routing vrf ${ vrf }
          %       elif config.get("vrfs")[vrf].get("ip_routing") is not None and config.get("vrfs")[vrf].get("ip_routing") == False  and vrf != 'default':
          no ip routing vrf ${ vrf }
          %       endif
          %   endfor
          !
          % endif
          ## static routes
          % if config.get("static_routes"):
          %     for static_route in config["static_routes"]:
          <%         static_route_cli = "ip route" %>
          %         if static_route.get("vrf") and static_route["vrf"] != 'default':
          <%             static_route_cli = static_route_cli + " vrf " + static_route["vrf"] %>
          %         endif
          %         if static_route.get("destination_address_prefix"):
          <%             static_route_cli = static_route_cli + " " + static_route["destination_address_prefix"] %>
          %         endif
          %         if static_route.get("interface"):
          <%             static_route_cli = static_route_cli + " " + static_route["interface"].upper() %>
          %         endif
          %         if static_route.get("gateway"):
          <%             static_route_cli = static_route_cli + " " + static_route["gateway"] %>
          %         endif
          %         if static_route.get("distance"):
          <%             static_route_cli = static_route_cli + " " + static_route["distance"] %>
          %         endif
          %         if static_route.get("tag"):
          <%             static_route_cli = static_route_cli + " tag " + static_route["tag"] %>
          %         endif
          %         if static_route.get("name"):
          <%             static_route_cli = static_route_cli + " name " + static_route["name"] %>
          %         endif
          %         if static_route.get("metric"):
          <%             static_route_cli = static_route_cli + " metric " + static_route["metric"] %>
          %         endif
          ${ static_route_cli }
          !
          %    endfor %}
          % endif
          ## virtual source nat
          % if config.get("virtual_source_nat_vrfs"):
          %     for vrf in natural_sort(config["virtual_source_nat_vrfs"].keys()):
          %         if config["virtual_source_nat_vrfs"][vrf].get("ip_address"):
          ip address virtual source-nat vrf ${ vrf } address ${ config["virtual_source_nat_vrfs"][vrf]["ip_address"] }
          %         endif
          %     endfor
          !
          % endif
          ## router-bgp
          % if config.get("router_bgp") is not None:
          % if config["router_bgp"].get("as") is not None:
          router bgp ${ config["router_bgp"]["as"] }
          %     if config["router_bgp"].get("router_id") is not None:
          router-id ${ config["router_bgp"]["router_id"] }
          %     endif
          %     if config["router_bgp"].get("bgp_defaults") is not None:
          %       for bgp_default in config["router_bgp"]["bgp_defaults"]:
          ${ bgp_default }
          %       endfor
          %     endif
          %     if config["router_bgp"].get("peer_groups") is not None:
          %       for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bgp_listen_range_prefix") is not None and config["router_bgp"]["peer_groups"][peer_group].get("peer_filter") is not None:
          bgp listen range ${ config["router_bgp"]["peer_groups"][peer_group]["bgp_listen_range_prefix"] } peer-group ${ peer_group } peer-filter ${ config["router_bgp"]["peer_groups"][peer_group]["peer_filter"] }
          %         endif
          %       endfor
          %     for peer_group in config["router_bgp"]["peer_groups"].keys():
          %         if config["router_bgp"]["peer_groups"][peer_group].get("description") is not None:
          neighbor ${ peer_group } description ${ config["router_bgp"]["peer_groups"][peer_group]["description"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("shutdown") == True:
          neighbor ${ peer_group } shutdown
          %         endif
          neighbor ${ peer_group } peer group
          %         if config["router_bgp"]["peer_groups"][peer_group].get("remote_as") is not None:
          neighbor ${ peer_group } remote-as ${ config["router_bgp"]["peer_groups"][peer_group]["remote_as"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("local_as") is not None:
          neighbor ${ peer_group } local-as ${ config["router_bgp"]["peer_groups"][peer_group]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_self") == True:
          neighbor ${ peer_group } next-hop-self
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("next_hop_unchanged") == True:
          neighbor ${ peer_group } next-hop-unchanged
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("update_source") is not None:
          neighbor ${ peer_group } update-source ${ config["router_bgp"]["peer_groups"][peer_group]["update_source"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_reflector_client") == True:
          neighbor ${ peer_group } route-reflector-client
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("bfd") == True:
          neighbor ${ peer_group } bfd
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("ebgp_multihop") is not None:
          neighbor ${ peer_group } ebgp-multihop ${ config["router_bgp"]["peer_groups"][peer_group]["ebgp_multihop"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("password") is not None:
          neighbor ${ peer_group } password 7 ${ config["router_bgp"]["peer_groups"][peer_group]["password"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None and config["router_bgp"]["peer_groups"][peer_group]["send_community"] == "all":
          neighbor ${ peer_group } send-community
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("send_community") is not None:
          neighbor ${ peer_group } send-community ${ config["router_bgp"]["peer_groups"][peer_group]["send_community"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None and config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes_warning_limit") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] } warning-limit ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes_warning_limit"] }
          %         elif config["router_bgp"]["peer_groups"][peer_group].get("maximum_routes") is not None:
          neighbor ${ peer_group } maximum-routes ${ config["router_bgp"]["peer_groups"][peer_group]["maximum_routes"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("weight") is not None:
          neighbor ${ peer_group } weight ${ config["router_bgp"]["peer_groups"][peer_group]["weight"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("timers") is not None:
          neighbor ${ peer_group } timers ${ config["router_bgp"]["peer_groups"][peer_group]["timers"] }
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_in") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["peer_groups"][peer_group].get("route_map_out") is not None:
          neighbor ${ peer_group } route-map ${ config["router_bgp"]["peer_groups"][peer_group]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for neighbor_interface in router_bgp.neighbor_interfaces | arista.avd.natural_sort %}
          ## {%         set neighbor_interface_cli = "neighbor interface " ~ neighbor_interface %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].peer_group is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " peer-group " ~ router_bgp.neighbor_interfaces[neighbor_interface].peer_group %}
          ## {%         endif %}
          ## {%         if router_bgp.neighbor_interfaces[neighbor_interface].remote_as is arista.avd.defined %}
          ## {%             set neighbor_interface_cli = neighbor_interface_cli ~ " remote-as " ~ router_bgp.neighbor_interfaces[neighbor_interface].remote_as %}
          ## {%         endif %}
          ## ##    {{ neighbor_interface_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("neighbors") is not None:
          %       for neighbor in config["router_bgp"]["neighbors"].keys():
          %         if config["router_bgp"]["neighbors"][neighbor].get("peer_group") is not None:
          neighbor ${ neighbor } peer group ${ config["router_bgp"]["neighbors"][neighbor]["peer_group"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("remote_as") is not None:
          neighbor ${ neighbor } remote-as ${ config["router_bgp"]["neighbors"][neighbor].remote_as }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("next_hop_self") == True:
          neighbor ${ neighbor } next-hop-self
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("shutdown") == True:
          neighbor ${ neighbor } shutdown
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("local_as") is not None:
          neighbor ${ neighbor } local-as ${ config["router_bgp"]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("description") is not None:
          neighbor ${ neighbor } description ${ config["router_bgp"]["neighbors"][neighbor]["description"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("update_source") is not None:
          neighbor ${ neighbor } update-source ${ config["router_bgp"]["neighbors"][neighbor]["update_source"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("bfd") == True:
          neighbor ${ neighbor } bfd
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("password") is not None:
          neighbor ${ neighbor } password 7 ${ config["router_bgp"]["neighbors"][neighbor]["password"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("weight") is not None:
          neighbor ${ neighbor } weight ${ config["router_bgp"]["neighbors"][neighbor]["weight"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("timers") is not None:
          neighbor ${ neighbor } timers ${ config["router_bgp"]["neighbors"][neighbor]["timers"] }
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_in") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_in"] } in
          %         endif
          %         if config["router_bgp"]["neighbors"][neighbor].get("route_map_out") is not None:
          neighbor ${ neighbor } route-map ${ config["router_bgp"]["neighbors"][neighbor]["route_map_out"] } out
          %         endif
          %       endfor
          %     endif
          ## {%     for aggregate_address in router_bgp.aggregate_addresses | arista.avd.natural_sort %}
          ## {%         set aggregate_address_cli = "aggregate-address " ~ aggregate_address %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].as_set is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " as-set" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].summary_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " summary-only" %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].attribute_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~  " attribute-map " ~ router_bgp.aggregate_addresses[aggregate_address].attribute_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].match_map is arista.avd.defined %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " match-map " ~ router_bgp.aggregate_addresses[aggregate_address].match_map %}
          ## {%         endif %}
          ## {%         if router_bgp.aggregate_addresses[aggregate_address].advertise_only is arista.avd.defined(true) %}
          ## {%             set aggregate_address_cli = aggregate_address_cli ~ " advertise-only" %}
          ## {%         endif %}
          ##    {{ aggregate_address_cli }}
          ## {%     endfor %}
          %     if config["router_bgp"].get("redistribute_routes") is not None:
          %       for redistribute_route in config["router_bgp"]["redistribute_routes"].keys():
          <%         redistribute_route_cli = "redistribute " + redistribute_route %>
          %         if config["router_bgp"]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%             redistribute_route_cli = redistribute_route_cli + " route-map " + config["router_bgp"]["redistribute_routes"][redistribute_route]["route_map"] %>
          %         endif
          ${ redistribute_route_cli }
          %       endfor
          %     endif
          ## L2VPNs - (vxlan) vlan based
          %     if config["router_bgp"].get("vlans") is not None:
          %       for vlan in config["router_bgp"]["vlans"]:
          !
          vlan ${ vlan }
          %         if config["router_bgp"]["vlans"][vlan].get("rd") is not None:
              rd ${ config["router_bgp"]["vlans"][vlan]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("both") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("route_targets") is not None and config["router_bgp"]["vlans"][vlan]["route_targets"].get("export") is not None:
          %             for route_target in config["router_bgp"]["vlans"][vlan]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlans"][vlan].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlans"][vlan]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor
          %         endif
          %       endfor
          ## vxlan vlan aware bundles
          %       if config["router_bgp"].get("vlan_aware_bundles") is not None:
          %         for vlan_aware_bundle in config["router_bgp"]["vlan_aware_bundles"].keys():
          !
          vlan-aware-bundle ${ vlan_aware_bundle }
          %         if  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("rd") is not None:
              rd ${  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["rd"] }
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("both") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["both"]:
              route-target both ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("import") is not None:
          %             for route_target in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["import"]:
              route-target import ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("route_targets") is not None and config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"].get("export") is not None:
          %             for route_target in  config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["route_targets"]["export"]:
              route-target export ${ route_target }
          %             endfor
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["redistribute_routes"]:
              redistribute ${ redistribute_route }
          %           endfor %}
          %         endif
          %         if config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle].get("vlan") is not None:
              vlan ${ config["router_bgp"]["vlan_aware_bundles"][vlan_aware_bundle]["vlan"] }
          %         endif
          %         endfor
          %       endif
          %     endif
          ## address families activation
          ## address family evpn activation ##
          %     if config["router_bgp"].get("address_family_evpn") is not None:
          !
          address-family evpn
          %         if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("enabled") == False:
              no host-flap detection
          %         else:
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("window") is not None:
              host-flap detection window ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["window"] }
          %             endif
          %             if config["router_bgp"]["address_family_evpn"].get("evpn_hostflap_detection") is not None and config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"].get("threshold") is not None:
              host-flap detection threshold ${ config["router_bgp"]["address_family_evpn"]["evpn_hostflap_detection"]["threshold"] }
          %             endif
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("domain_identifier") is not None:
              domain identifier ${ config["router_bgp"]["address_family_evpn"]["domain_identifier"] }
          %         endif
          %         if config["router_bgp"]["address_family_evpn"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_evpn"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_evpn"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %         endif
          %     endif
          ## {# address family rt-membership activation #}
          ## {%     if router_bgp.address_family_rtc is arista.avd.defined %}
          ##    !
          ##    address-family rt-membership
          ## {%         for peer_group in router_bgp.address_family_rtc.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_rtc.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target is defined %}
          ## {%                 if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.only is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } default-route-target only
          ## {%                 else %}
          ##       neighbor ${ peer_group } default-route-target
          ## {%                 endif %}
          ## {%             endif %}
          ## {%             if router_bgp.address_family_rtc.peer_groups[peer_group].default_route_target.encoding_origin_as_omit is defined %}
          ##       neighbor ${ peer_group } default-route-target encoding origin-as omit
          ## {%             endif %}
          ## {%         endfor %}
          ## {%     endif %}
          ## address family ipv4 activation
          %     if config["router_bgp"].get("address_family_ipv4") is not None:
          !
          address-family ipv4
          %       if config["router_bgp"]["address_family_ipv4"].get("networks") is not None:
          %         for network in config["router_bgp"]["address_family_ipv4"]["networks"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["networks"][network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["address_family_ipv4"]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %         endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("peer_groups") is not None:
          %           for peer_group in config["router_bgp"]["address_family_ipv4"]["peer_groups"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_in") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("route_map_out") is not None:
              neighbor ${ peer_group } route-map ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_in") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("prefix_list_out") is not None:
              neighbor ${ peer_group } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == True:
              neighbor ${ peer_group } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["peer_groups"][peer_group].get("activate") == False:
              no neighbor ${ peer_group } activate
          %             endif
          %           endfor
          %       endif
          %       if config["router_bgp"]["address_family_ipv4"].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["address_family_ipv4"]["neighbors"].keys():
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_in") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_in"] } in
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("prefix_list_out") is not None:
              neighbor ${ neighbor } prefix-list ${ config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["prefix_list_out"] } out
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("default_originate") is not None:
          <%                 neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                     neighbor_default_originate_cli = neighbor_default_originate_cli + " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == True:
              neighbor ${ neighbor } activate
          %             elif config["router_bgp"]["address_family_ipv4"]["neighbors"][neighbor].get("activate") == False:
              no neighbor ${ neighbor } activate
          %             endif
          %           endfor
          %       endif
          %     endif
          ## {# address family ipv4 multicast activation #}
          ## {%     if router_bgp.address_family_ipv4_multicast is arista.avd.defined %}
          ##    !
          ##    address-family ipv4 multicast
          ## {%         for peer_group in router_bgp.address_family_ipv4_multicast.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv4_multicast.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv4_multicast.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv4_multicast.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv4_multicast.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cli ~ " route-map " ~ router_bgp.address_family_ipv4_multicast.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family ipv6 activation #}
          ## {%     if router_bgp.address_family_ipv6 is arista.avd.defined %}
          ##    !
          ##    address-family ipv6
          ## {%         for network in router_bgp.address_family_ipv6.networks | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.networks[network].route_map is arista.avd.defined %}
          ##       network {{ network }} route-map {{ router_bgp.address_family_ipv6.networks[network].route_map }}
          ## {%             else %}
          ##       network {{ network }}
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for peer_group in router_bgp.address_family_ipv6.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out is arista.avd.defined %}
          ##       neighbor ${ peer_group } route-map {{ router_bgp.address_family_ipv6.peer_groups[peer_group].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_ipv6.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_ipv6.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_in }} in
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out is arista.avd.defined %}
          ##       neighbor {{ neighbor }} route-map {{ router_bgp.address_family_ipv6.neighbors[neighbor].route_map_out }} out
          ## {%             endif %}
          ## {%             if router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_ipv6.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for redistribute_route in router_bgp.address_family_ipv6.redistribute_routes | arista.avd.natural_sort %}
          ## {%             set redistribute_route_cli = "redistribute " ~ redistribute_route %}
          ## {%             if router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map is arista.avd.defined %}
          ## {%                 set redistribute_route_cli = redistribute_route_cl ~ " route-map " ~ router_bgp.address_family_ipv6.redistribute_routes[redistribute_route].route_map %}
          ## {%             endif %}
          ##       {{ redistribute_route_cli }}
          ## {%         endfor %}
          ## {%     endif %}
          ## {# address family vpn-ipv4 activation #}
          ## {%     if router_bgp.address_family_vpn_ipv4 is arista.avd.defined %}
          ##    !
          ##    address-family vpn-ipv4
          ## {%         if router_bgp.address_family_vpn_ipv4.domain_identifier is arista.avd.defined %}
          ##       domain identifier {{ router_bgp.address_family_vpn_ipv4.domain_identifier }}
          ## {%         endif %}
          ## {%         for peer_group in router_bgp.address_family_vpn_ipv4.peer_groups | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(true) %}
          ##       neighbor ${ peer_group } activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.peer_groups[peer_group].activate is arista.avd.defined(false) %}
          ##       no neighbor ${ peer_group } activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         for neighbor in router_bgp.address_family_vpn_ipv4.neighbors | arista.avd.natural_sort %}
          ## {%             if router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(true) %}
          ##       neighbor {{ neighbor }} activate
          ## {%             elif router_bgp.address_family_vpn_ipv4.neighbors[neighbor].activate is arista.avd.defined(false) %}
          ##       no neighbor {{ neighbor }} activate
          ## {%             endif %}
          ## {%         endfor %}
          ## {%         if router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface is arista.avd.defined %}
          ##       neighbor default encapsulation mpls next-hop-self source-interface {{ router_bgp.address_family_vpn_ipv4.neighbor_default_encapsulation_mpls_next_hop_self.source_interface }}
          ## {%         endif %}
          ## {%     endif %}
          ## L3VPNs - (vxlan) VRFs
          %     if config["router_bgp"].get("vrfs") is not None:
          %       for vrf in config["router_bgp"]["vrfs"].keys():
          !
          vrf ${ vrf }
          %         if config["router_bgp"]["vrfs"][vrf].get("rd") is not None:
              rd ${ config["router_bgp"]["vrfs"][vrf]["rd"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("import") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["import"][address_family]:
              route-target import ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("route_targets") is not None and config["router_bgp"]["vrfs"][vrf]["route_targets"].get("export") is not None:
          %             for address_family in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"].keys():
          %                 for route_target in config["router_bgp"]["vrfs"][vrf]["route_targets"]["export"][address_family]:
              route-target export ${ address_family } ${ route_target }
          %                 endfor
          %             endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("router_id") is not None:
              router-id ${ config["router_bgp"]["vrfs"][vrf]["router_id"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("evpn_multicast"):
              evpn multicast
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("timers") is not None:
              timers bgp ${ config["router_bgp"]["vrfs"][vrf]["timers"] }
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("networks") is not None:
          %           for network in config["router_bgp"]["vrfs"][vrf]["networks"].keys():
          %             if config["router_bgp"]["vrfs"][vrf].networks[network].get("route_map") is not None:
              network ${ network } route-map ${ config["router_bgp"]["vrfs"][vrf]["networks"][network]["route_map"] }
          %             else:
              network ${ network }
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("neighbors") is not None:
          %           for neighbor in config["router_bgp"]["vrfs"][vrf]["neighbors"].keys():
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("remote_as") is not None:
              neighbor ${ neighbor } remote-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["remote_as"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("peer_group") is not None:
              neighbor ${ neighbor } peer group ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["peer_group"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("password") is not None:
              neighbor ${ neighbor } password 7 ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["password"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("local_as") is not None:
              neighbor ${ neighbor } local-as ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["local_as"] } no-prepend replace-as
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("description") is not None:
              neighbor ${ neighbor } description ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["description"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("ebgp_multihop") is not None:
          <%                 neighbor_ebgp_multihop_cli = "neighbor " + neighbor + " ebgp-multihop" %>
          %                 if type(config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"]) is int:
          <%                     neighbor_ebgp_multihop_cli = neighbor_ebgp_multihop_cli + " " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["ebgp_multihop"] %>
          %                 endif
              ${ neighbor_ebgp_multihop_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("next_hop_self") == True:
              neighbor ${ neighbor } next-hop-self
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("timers") is not None:
              neighbor ${ neighbor } timers ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["timers"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None and config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] == "all":
              neighbor ${ neighbor } send-community
          %             elif config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("send_community") is not None:
              neighbor ${ neighbor } send-community ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["send_community"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("maximum_routes") is not None:
              neighbor ${ neighbor } maximum-routes ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["maximum_routes"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("default_originate") is not None:
          <%                neighbor_default_originate_cli = "neighbor " + neighbor + " default-originate" %>
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("route_map") is not None:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"]["route_map"] %>
          %                 endif
          %                 if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["default_originate"].get("always") == True:
          <%                    neighbor_default_originate_cli = neighbor_default_originate_cli+ " always" %>
          %                 endif
              ${ neighbor_default_originate_cli }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("update_source") is not None:
              neighbor ${ neighbor } update-source ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["update_source"] }
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_out") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_out"] } out
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor].get("route_map_in") is not None:
              neighbor ${ neighbor } route-map ${ config["router_bgp"]["vrfs"][vrf]["neighbors"][neighbor]["route_map_in"] } in
          %             endif
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("redistribute_routes") is not None:
          %           for redistribute_route in config["router_bgp"]["vrfs"][vrf]["redistribute_routes"].keys():
          <%             redistribute_cli = "redistribute " + redistribute_route %>
          %              if config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route].get("route_map") is not None:
          <%                 redistribute_cli = redistribute_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["redistribute_routes"][redistribute_route]["route_map"] %>
          %              endif
              ${ redistribute_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("aggregate_addresses") is not None:
          %           for aggregate_address in config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"].keys():
          <%             aggregate_address_cli = "aggregate-address " + aggregate_address %>
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("as_set") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " as-set" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("summary_only") == True:
          <%                  aggregate_address_cli = aggregate_address_cli + " summary-only" %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("attribute_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " attribute-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["attribute_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("match_map") is not None:
          <%                  aggregate_address_cli = aggregate_address_cli + " match-map " + config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address]["match_map"] %>
          %             endif
          %             if config["router_bgp"]["vrfs"][vrf]["aggregate_addresses"][aggregate_address].get("advertise_only") == True:
          <%                 aggregate_address_cli = aggregate_address_cli + " advertise-only" %>
          %             endif
              ${ aggregate_address_cli }
          %           endfor
          %         endif
          %         if config["router_bgp"]["vrfs"][vrf].get("address_families") is not None:
          %           for  address_family in config["router_bgp"]["vrfs"][vrf]["address_families"].keys():
              !
              address-family ${ address_family }
          %             for neighbor in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"].keys():
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["neighbors"][neighbor].get("activate") == True:
                  neighbor ${ neighbor } activate
          %                 endif
          %             endfor
          %             for network in config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"].keys():
          <%                network_cli = "network " + network %>
          %                 if config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network].get("route_map") is not None:
          <%                     network_cli = network_cli + " route-map " + config["router_bgp"]["vrfs"][vrf]["address_families"][address_family]["networks"][network]["route_map"] %>
          %                 endif
                  ${ network_cli }
          %             endfor
          %           endfor
          %         endif
          %       endfor
          %     endif
          !
          % endif
          % endif
      input_schema:
        fields:
          values:
            vlanId:
              id: vlanId
              name: vlanId
              label: VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanL2CampusSviIpAddress:
              id: vlanL2CampusSviIpAddress
              name: ipAddress
              label: IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanCampusSviVrf:
              id: vlanCampusSviVrf
              name: vrf
              label: VRF
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options:
                  values:
                    - '{"fieldId":"vrfName"}'
            vlanCampusSviGroup:
              id: vlanCampusSviGroup
              name: sviDetails
              label: SVI Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanL2CampusSviIpAddress
                    - vlanCampusSviVrf
            vlanDhcpHelpersServer:
              id: vlanDhcpHelpersServer
              name: dhcpServer
              label: DHCP Server
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersSourceInterface:
              id: vlanDhcpHelpersSourceInterface
              name: dhcpSourceInterface
              label: DHCP Source Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanDhcpHelpersGroup:
              id: vlanDhcpHelpersGroup
              name: dhcpHelperDetails
              label: DHCP Helper Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanDhcpHelpersServer
                    - vlanDhcpHelpersSourceInterface
            vlanDhcpHelpers:
              id: vlanDhcpHelpers
              name: dhcpHelpers
              label: DHCP Helpers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanDhcpHelpersGroup
                key: ''
            vlanName:
              id: vlanName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodSviIpAddress:
              id: vlansCampusPodSviIpAddress
              name: sviIpAddress
              label: SVI IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlansCampusPodApply:
              id: vlansCampusPodApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            vlansCampusPodGroup:
              id: vlansCampusPodGroup
              name: poDDetails
              label: PoD Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlansCampusPodSviIpAddress
                    - vlansCampusPodApply
            vlansCampusPodResolver:
              id: vlansCampusPodResolver
              name: campusPoD
              label: Campus PoDs
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vlansCampusPodGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus-Pod
                tag_filter_query: null
            vlanSviEosCliStatement:
              id: vlanSviEosCliStatement
              name: cliStatement
              label: CLI Statement
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vlanSviEosCli:
              id: vlanSviEosCli
              name: eosCli
              label: EOS CLI
              description: Raw CLI to be applied on SVI
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlanSviEosCliStatement
                key: ''
            vlansDetails:
              id: vlansDetails
              name: vlanDetails
              label: VLAN Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlanId
                    - vlanCampusSviGroup
                    - vlanDhcpHelpers
                    - vlanName
                    - vlansCampusPodResolver
                    - vlanSviEosCli
            vlans:
              id: vlans
              name: vlans
              label: VLANs
              description: VLANs configured only on all switches at this site.
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vlansDetails
                key: vlanId
            vrfName:
              id: vrfName
              name: name
              label: Name
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3PeeringVlanId:
              id: vrfMlagL3PeeringVlanId
              name: peeringVlanId
              label: Peering VLAN ID
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfMlagL3PeeringSubnet:
              id: vrfMlagL3PeeringSubnet
              name: peeringSubnet
              label: Peering Subnet
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfMlagL3PeeringSubnetMask:
              id: vrfMlagL3PeeringSubnetMask
              name: peeringSubnetMask
              label: Peering Subnet Mask
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: '31'
                range: null
                static_options:
                  values:
                    - '30'
                    - '31'
                dynamic_options: null
            vrfMlagL3Peering:
              id: vrfMlagL3Peering
              name: ibgpDetails
              label: MLAG L3 Peering
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfMlagL3PeeringVlanId
                    - vrfMlagL3PeeringSubnet
                    - vrfMlagL3PeeringSubnetMask
            vrfStaticRoutesDescription:
              id: vrfStaticRoutesDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesApply:
              id: vrfStaticRoutesApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            vrfStaticRoutesHostname:
              id: vrfStaticRoutesHostname
              name: hostname
              label: Hostname
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_ALL
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfStaticRoutesDevicesGroup:
              id: vrfStaticRoutesDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesHostname
            vrfStaticRoutesDevicesResolver:
              id: vrfStaticRoutesDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfStaticRoutesDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfStaticRoutesDestinationAddressPrefix:
              id: vrfStaticRoutesDestinationAddressPrefix
              name: destinationAddressPrefix
              label: Destination Address Prefix
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesGateway:
              id: vrfStaticRoutesGateway
              name: gateway
              label: Gateway
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesInterface:
              id: vrfStaticRoutesInterface
              name: interface
              label: Interface
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfStaticRoutesDistance:
              id: vrfStaticRoutesDistance
              name: distance
              label: Distance
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesTag:
              id: vrfStaticRoutesTag
              name: tag
              label: Tag
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesMetric:
              id: vrfStaticRoutesMetric
              name: metric
              label: Metric
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfStaticRoutesDetails:
              id: vrfStaticRoutesDetails
              name: routeDetails
              label: Route Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDestinationAddressPrefix
                    - vrfStaticRoutesGateway
                    - vrfStaticRoutesInterface
                    - vrfStaticRoutesDistance
                    - vrfStaticRoutesTag
                    - vrfStaticRoutesMetric
            vrfStaticRoutesGroup:
              id: vrfStaticRoutesGroup
              name: staticRoutesGroup
              label: Static Routes Group
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfStaticRoutesDescription
                    - vrfStaticRoutesDevicesResolver
                    - vrfStaticRoutesDetails
            vrfStaticRoutes:
              id: vrfStaticRoutes
              name: staticRoutes
              label: Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfStaticRoutesGroup
                key: ''
            vrfRedistributeStaticRoutesToggle:
              id: vrfRedistributeStaticRoutesToggle
              name: redistributeStaticRoutes
              label: Redistribute Static Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            vrfExternalBgpPeersNeighborIpAddress:
              id: vrfExternalBgpPeersNeighborIpAddress
              name: neighborIpAddress
              label: Neighbor IP Address
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersApply:
              id: vrfExternalBgpPeersApply
              name: apply
              label: Apply
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            vrfExternalBgpPeersHostname:
              id: vrfExternalBgpPeersHostname
              name: hostnames
              label: Hostnames
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersApply
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: device
                tag_filter_query: null
            vrfExternalBgpPeersDevicesGroup:
              id: vrfExternalBgpPeersDevicesGroup
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersHostname
            vrfExternalBgpPeersDevicesResolver:
              id: vrfExternalBgpPeersDevicesResolver
              name: devices
              label: Devices
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: vrfExternalBgpPeersDevicesGroup
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_MULTI_DEVICE_TAG
                input_tag_label: null
                tag_filter_query: null
            vrfExternalBgpPeersRemoteAs:
              id: vrfExternalBgpPeersRemoteAs
              name: remoteAs
              label: Remote AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersDescription:
              id: vrfExternalBgpPeersDescription
              name: description
              label: Description
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersPassword:
              id: vrfExternalBgpPeersPassword
              name: password
              label: Password
              description: Input the encrypted password (seeded with neighbor IP)
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersSendCommunity:
              id: vrfExternalBgpPeersSendCommunity
              name: sendCommunity
              label: Send Community
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - standard
                    - extended
                    - large
                    - all
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopSelf:
              id: vrfExternalBgpPeersNextHopSelf
              name: nextHopSelf
              label: Next Hop Self
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersMaximumRoutes:
              id: vrfExternalBgpPeersMaximumRoutes
              name: maximumRoutes
              label: Maximum Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesWarningLimit:
              id: vrfExternalBgpPeersMaxRoutesWarningLimit
              name: warningLimit
              label: Warning Limit
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersMaxRoutesGroup:
              id: vrfExternalBgpPeersMaxRoutesGroup
              name: maxRoutes
              label: Max Routes
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersMaximumRoutes
                    - vrfExternalBgpPeersMaxRoutesWarningLimit
            vrfExternalBgpPeersUpdateSource:
              id: vrfExternalBgpPeersUpdateSource
              name: updateSource
              label: Update Source
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersEbgpMultihop:
              id: vrfExternalBgpPeersEbgpMultihop
              name: ebgpMultihop
              label: EBGP Multihop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersWeight:
              id: vrfExternalBgpPeersWeight
              name: weight
              label: Weight
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersIpv4NextHop:
              id: vrfExternalBgpPeersIpv4NextHop
              name: iPv4NextHop
              label: IPv4 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersIpv6NextHop:
              id: vrfExternalBgpPeersIpv6NextHop
              name: iPv6NextHop
              label: IPv6 Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersNextHopGroup:
              id: vrfExternalBgpPeersNextHopGroup
              name: nextHop
              label: Next Hop
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersIpv4NextHop
                    - vrfExternalBgpPeersIpv6NextHop
            vrfExternalBgpPeersRouteMapIn:
              id: vrfExternalBgpPeersRouteMapIn
              name: routeMapIn
              label: Route Map In
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapOut:
              id: vrfExternalBgpPeersRouteMapOut
              name: routeMapOut
              label: Route Map Out
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options: null
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersRouteMapGroup:
              id: vrfExternalBgpPeersRouteMapGroup
              name: routeMap
              label: Route Map
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersRouteMapIn
                    - vrfExternalBgpPeersRouteMapOut
            vrfExternalBgpPeersDefaultOriginateAlwaysToggle:
              id: vrfExternalBgpPeersDefaultOriginateAlwaysToggle
              name: always
              label: Always
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_STRING
              string_props:
                default_value: null
                static_options:
                  values:
                    - 'True'
                    - 'False'
                format: null
                length: null
                pattern: null
                dynamic_options: null
            vrfExternalBgpPeersDefaultOriginateGroup:
              id: vrfExternalBgpPeersDefaultOriginateGroup
              name: defaultOriginate
              label: Default Originate
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersDefaultOriginateAlwaysToggle
            vrfExternalBgpPeersLocalAs:
              id: vrfExternalBgpPeersLocalAs
              name: localAs
              label: Local AS
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_INTEGER
              integer_props:
                default_value: null
                range: null
                static_options: null
                dynamic_options: null
            vrfExternalBgpPeersGroup:
              id: vrfExternalBgpPeersGroup
              name: value
              label: External BGP Peers Group
              description: Group of members for External BGP Peers
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfExternalBgpPeersNeighborIpAddress
                    - vrfExternalBgpPeersDevicesResolver
                    - vrfExternalBgpPeersRemoteAs
                    - vrfExternalBgpPeersDescription
                    - vrfExternalBgpPeersPassword
                    - vrfExternalBgpPeersSendCommunity
                    - vrfExternalBgpPeersNextHopSelf
                    - vrfExternalBgpPeersMaxRoutesGroup
                    - vrfExternalBgpPeersUpdateSource
                    - vrfExternalBgpPeersEbgpMultihop
                    - vrfExternalBgpPeersWeight
                    - vrfExternalBgpPeersNextHopGroup
                    - vrfExternalBgpPeersRouteMapGroup
                    - vrfExternalBgpPeersDefaultOriginateGroup
                    - vrfExternalBgpPeersLocalAs
            vrfExternalBgpPeers:
              id: vrfExternalBgpPeers
              name: externalBgpPeers
              label: External BGP Peers
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfExternalBgpPeersGroup
                key: ''
            vrfDetails:
              id: vrfDetails
              name: vrfDetails
              label: VRF Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vrfName
                    - vrfMlagL3Peering
                    - vrfStaticRoutes
                    - vrfRedistributeStaticRoutesToggle
                    - vrfExternalBgpPeers
            vrfs:
              id: vrfs
              name: vrfs
              label: VRFs
              description: VRFs configured only on all gateway switches at this site
              required: false
              type: INPUT_FIELD_TYPE_COLLECTION
              collection_props:
                base_field_id: vrfDetails
                key: vrfName
            networkType:
              id: networkType
              name: networkType
              label: Network Type
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: null
            allowAllVlansOnTrunkToggle:
              id: allowAllVlansOnTrunkToggle
              name: allowAllVlans
              label: Allow All VLANs
              description: When enabled, all VLANs will be allowed on transit port-channels.  When disabled, only VLANs configured at this site will be allowed to traverse transit port-channels.
              required: false
              type: INPUT_FIELD_TYPE_BOOLEAN
              boolean_props:
                default_value: false
            siteFacts:
              id: siteFacts
              name: siteFacts
              label: Site Facts
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - vlans
                    - vrfs
                    - networkType
                    - allowAllVlansOnTrunkToggle
            siteResolver:
              id: siteResolver
              name: site
              label: Site
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: siteFacts
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Site
                tag_filter_query: null
            campusDetails:
              id: campusDetails
              name: campusDetails
              label: Campus Details
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - siteResolver
            campus:
              id: campus
              name: campus
              label: Campus
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_RESOLVER
              resolver_props:
                base_field_id: campusDetails
                display_mode: RESOLVER_FIELD_DISPLAY_MODE_SPARSE
                input_mode: RESOLVER_FIELD_INPUT_MODE_SINGLE_DEVICE_TAG
                input_tag_label: Campus
                tag_filter_query: null
            root:
              id: root
              name: ''
              label: ''
              description: ''
              required: false
              type: INPUT_FIELD_TYPE_GROUP
              group_props:
                members:
                  values:
                    - campus
        layout:
          value: |
            {
              "siteFacts":{
                "key":"siteFacts",
                "type":"INPUT",
                "order":[
                  "networkType",
                  "vrfs",
                  "vlans",
                  "allowAllVlansOnTrunkToggle"
                ]
              },
              "vlans":{
                "key":"vlans",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfs":{
                "key":"vrfs",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vlanCampusSviGroup":{
                "key":"vlanCampusSviGroup",
                "type":"INPUT",
                "order":[
                  "vlanCampusSviVrf",
                  "vlanL2CampusSviIpAddress"
                ]
              },
              "vlansDetails":{
                "key":"vlansDetails",
                "type":"INPUT",
                "order":[
                  "vlanId",
                  "vlansCampusPodResolver",
                  "vlanName",
                  "vlanCampusSviGroup",
                  "vlanDhcpHelpers",
                  "vlanSviEosCli"
                ]
              },
              "networkType":{
                "key":"networkType",
                "type":"INPUT",
                "valueToLabelMap":{
                  "True":"L2",
                  "False":"L3"
                }
              },
              "vlanL2CampusSviIpAddress":{
                "key":"vlanL2CampusSviIpAddress",
                "type":"INPUT",
                "dependency":{
                  "networkType":{
                    "value":[
                      true
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlansCampusPodSviIpAddress":{
                "key":"vlansCampusPodSviIpAddress",
                "type":"INPUT",
                "dependency":{
                  "networkType":{
                    "value":[
                      false
                    ],
                    "mode":"SHOW"
                  }
                }
              },
              "vlanSviEosCliStatement":{
                "key":"vlanSviEosCliStatement",
                "type":"INPUT",
                "dependency":{
                  "vlansCampusPodSviIpAddress":{
                    "value":[
                      
                    ],
                    "mode":"HIDE"
                  }
                }
              },
              "vrfStaticRoutes":{
                "key":"vrfStaticRoutes",
                "type":"INPUT",
                "isPageLayout":true
              },
              "vrfExternalBgpPeers":{
                "key":"vrfExternalBgpPeers",
                "type":"INPUT",
                "isPageLayout":true
              }
            }